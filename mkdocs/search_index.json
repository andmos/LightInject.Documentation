{
    "docs": [
        {
            "location": "/", 
            "text": "Installing\n\n\nLightInject\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject\n\n   \n\n\n\n\n\nThis adds a reference to the LightInject.dll in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Source \n\n   \n\n\n\n\n\nThis will install a single file (LightInject.cs) into the current project.\n\n\nCreating a container\n\n\nvar container = new LightInject.ServiceContainer();\n\n\n\nThe container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope.\n\n\nDefault services\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar instance = container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(instance, typeof(Foo));\n\n\n\nNamed services\n\n\npublic class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instance = container.GetInstance\nIFoo\n(\"AnotherFoo\");\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));\n\n\n\nIf only one named registration exists, \nLightInject\n is capable of resolving this as the default service.\n\n\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instance = container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));\n\n\n\nUnresolved services\n\n\nLightInject can resolve services that are not registered with the container using the \nRegisterFallback\n method.\n\n\nvar container = new ServiceContainer();\ncontainer.RegisterFallback((type, s) =\n true, request =\n new Foo());\nvar foo = container.GetInstance\nIFoo\n();\n\n\n\nThe first argument to the \nRegisterFallback\n method makes it possible to possible to decide if the service can be \"late-resolved\".\nThe second argument is a \nServiceRequest\n instance that provides the requested service type and service name.\n\n\nIEnumerable\nT\n\n\nWhen we register multiple services with the same service type, \nLightInject\n is capable of resolving these services as an  \nIEnumerable\nT\n.\n\n\npublic class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instances = container.GetInstance\nIEnumerable\nIFoo\n()\nAssert.AreEqual(2, instances.Count());\n\n\n\nAlternatively using the \nGetAllInstances\n method.\n\n\nvar instances = container.GetAllInstances\nIFoo\n();\nAssert.AreEqual(2, instances.Count());\n\n\n\nIn addition, \nLightInject\n supports the following \nIEnumerable\nT\n sub-types. \n\n\n\n\nArray\n\n\nICollection\nT\n\n\nIList\nT\n\n\nIReadOnlyCollection\nT\n (Net 4.5 and Windows Runtime);\n\n\nIReadOnlyList\nT\n (Net 4.5 and Windows Runtime)\n\n\n\n\nBy default, \nLightInject\n will resolve all services that are compatible with the requested element type.\n\n\ncontainer.Register\nFoo\n();\ncontainer.Register\nDerivedFoo\n();\nvar instances = container.GetAllInstances\nFoo\n();\nAssert.AreEqual(2, instances.Count());\n\n\n\nThis behavior can be overridden using the \nEnableVariance\n container option.\n\n\nvar container = new ServiceContainer(new ContainerOptions { EnableVariance = false });\ncontainer.Register\nFoo\n();\ncontainer.Register\nDerivedFoo\n();\nvar instances = container.GetAllInstances\nFoo\n();\nAssert.AreEqual(1, instances.Count());\n\n\n\nValues\n\n\nRegisters the value as a constant.\n\n\ncontainer.RegisterInstance\nstring\n(\"SomeValue\");\nvar value = container.GetInstance\nstring\n();\nAssert.AreEqual(\"SomeValue, value);\n\n\n\nLifetime\n\n\nThe default behavior in \nLightInject\n is to treat all objects as transients unless otherwise specified.\n\n\ncontainer.Register\nIFoo,Foo\n();\nvar firstInstance = container.GetInstance\nIFoo\n();\nvar secondInstance = container.GetInstance\nIFoo\n();\nAssert.AreNotSame(firstInstance, secondInstance);\n\n\n\nPerScopeLifetime\n\n\nEnsures that only one instance of a given service can exists within a scope.\nThe container will call the \nDispose\n method on all disposable objects created within the scope.\n\n\ncontainer.Register\nIFoo,Foo\n(new PerScopeLifetime());\nusing(container.BeginScope())\n{\n\n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreSame(firstInstance, secondInstance);\n}\n\n\n\nNote:\n \nAn \nInvalidOperationException\n is thrown if a service registered with the \nPerScopeLifetime\n is requested outside the scope.\n\n\nPerContainerLifetime\n\n\nEnsures that only one instance of a given service can exist within the container.\nThe container will call the Dispose method on all disposable objects when the container itself is disposed.\n\n\nusing(container = new ServiceContainer())\n{\n    container.Register\nIFoo,Foo\n(new PerContainerLifetime());   \n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreSame(firstInstance, secondInstance);\n}\n\n\n\nPerRequestLifeTime\n\n\nA new instance is created for each request and the container calls \nDispose\n when the scope ends.\nThis lifetime is used when the conrete class implements \nIDisposable\n.\n\n\ncontainer.Register\nIFoo,Foo\n(new PerRequestLifeTime());\nusing(container.BeginScope())\n{       \n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreNotSame(firstInstance, secondInstance);\n}\n\n\n\n\n\nNote:\n \nAn \nInvalidOperationException\n is thrown if a service registered with the \nPerRequestLifeTime\n is requested outside the scope.\n\n\n\n\nCustom lifetime\n\n\nA custom lifetime is created by implementing the \nILifetime\n interface\n\n\ninternal interface ILifetime\n{\n    object GetInstance(Func\nobject\n instanceFactory, Scope currentScope);        \n}\n\n\n\nThe following example shows to create a custom lifetime that ensures only one instance per thread.\n\n\npublic class PerThreadLifetime : ILifetime\n{\n    ThreadLocal\nobject\n instances = new ThreadLocal\nobject\n();\n\n    public object GetInstance(Func\nobject\n instanceFactory, Scope currentScope)\n    {\n        if (instances.value == null)\n        {\n            instances.value = instanceFactory();\n        }\n        return instances.value;\n    }\n}\n\n\n\nThat is all it takes to create a custom lifetime, but what about disposable services?\n\n\npublic class PerThreadLifetime : ILifetime\n{\n    ThreadLocal\nobject\n instances = new ThreadLocal\nobject\n();\n\n    public object GetInstance(Func\nobject\n instanceFactory, Scope currentScope)\n    {           \n        if (instances.value == null)\n        {               \n            object instance = instanceFactory();                \n            IDisposable disposable = instance as IDisposable;               \n            if (disposable != null)\n            {\n                if (currentScope == null)\n                {\n                    throw new InvalidOperationException(\"Attempt to create an disposable object \n                                                        without a current scope.\")\n                }\n                currentScope.TrackInstance(disposable);\n            }\n\n            instances.value = instance;\n        }\n        return instance.value;\n    }\n}\n\n\n\nImportant\n\n\nA lifetime object controls the lifetime of a single service and can \nnever\n be shared for multiple service registrations.\n\n\nWrong\n\n\nILifetime lifetime = new PerContainerLifeTime();\ncontainer.Register\nIFoo,Foo\n(lifetime);\ncontainer.Register\nIBar,Bar\n(lifetime);\n\n\n\nRight\n\n\ncontainer.Register\nIFoo,Foo\n(new PerContainerLifeTime());\ncontainer.Register\nIBar,Bar\n(new PerContainerLifeTime());\n\n\n\nA lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations.\n\n\nAsync and Await\n\n\nBy default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread.\n\n\nWith the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread.\n\n\nTo illustrate this lets consider an example that is going to cause an instance to be resolved on another thread.\n\n\nWe start of by creating an interface that returns a \nTask\nIBar\n\n\npublic interface IAsyncFoo\n{\n    Task\nIBar\n GetBar();\n}\n\n\n\nNext we implement this interface in such a way that the \nIBar\n instance is requested on another thread.\n\n\npublic class AsyncFoo : IAsyncFoo\n{\n    private readonly Lazy\nIBar\n lazyBar;\n\n    public AsyncFoo(Lazy\nIBar\n lazyBar)\n    {\n        this.lazyBar = lazyBar;\n    }\n\n    public async Task\nIBar\n GetBar()\n    {\n        await Task.Delay(10);\n        return lazyBar.Value; \n--This code is executed on another thread (continuation).\n    }\n}\n\n\n\nThe we register the dependency (\nIBar\n) with the \nPerScopeLifetime\n that is going to cause the container to ask for the current scope so that the instance can be registered with that scope.\n\n\nvar container = new ServiceContainer();\ncontainer.Register\nIBar, Bar\n(new PerScopeLifetime());\ncontainer.Register\nIAsyncFoo, AsyncFoo\n();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance\nIAsyncFoo\n();\n    ExceptionAssert.Throws\nAggregateException\n(() =\n instance.GetBar().Wait());                \n}\n\n\n\nThis will throw an exception that states the following:\n\n\nAttempt to create a scoped instance without a current scope.\n\n\n\nThe reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread.\n\n\nTo deal with this issue, \nLightInject\n now supports scopes across the logical \nCallContext\n.  \n\n\nvar container = new ServiceContainer();\ncontainer.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider();\ncontainer.Register\nIBar, Bar\n(new PerScopeLifetime());\ncontainer.Register\nIAsyncFoo, AsyncFoo\n();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance\nIAsyncFoo\n();\n    var bar = instance.GetBar().Result;\n    Assert.IsInstanceOfType(bar, typeof(IBar));\n}\n\n\n\n\n\nNote that the \nPerLogicalCallContextScopeManagerProvider\n is only available when running under .Net 4.5.\nFor more information, please refer to the following \narticle\n by Stephen Cleary.\n\n\n\n\nDependencies\n\n\nConstructor Injection\n\n\npublic interface IFoo {}        \npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public Foo(IBar bar) \n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; } \n}\n\npublic class Bar : IBar {}\n\n\n\nImplicit service registration\n\n\nRegisters a service without specifying any information about how to resolve the constructor dependencies of the implementing type.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIBar, Bar\n();\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));\n\n\n\n\n\nNote: In the case where the implementing type(Foo) has more than one constructor, \nLightInject\n will choose the constructor with the most parameters. \n\n\n\n\nFor fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency.\n\n\ncontainer.RegisterConstructorDependency\nIBar\n((factory, parameterInfo) =\n new Bar());\n\n\n\nThis tells the container to inject a new \nBar\n instance whenever it sees an \nIBar\n constructor dependency.\n\n\nExplicit service registration\n\n\nRegisters a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies.\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nIFoo\n(factory =\n new Foo(factory.GetInstance\nIBar\n));\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.Bar);\n\n\n\nParameters\n\n\nParameters are used when we want to supply one or more values when the service is resolved.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((arg, factory) =\n new Foo(arg));\nvar foo = (Foo)container.GetInstance\nint, IFoo\n(42);\nAssert.AreEqual(42,foo.Value);\n\n\n\nWe can also do a combination of supplied values and dependencies.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value, IBar bar)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n    public IBar Bar { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value, factory.GetInstance\nIBar\n()));\nvar foo = (Foo)container.GetInstance\nint, IFoo\n(42);\nAssert.AreEqual(42, foo.Value);\nAssert.IsNotNull(foo.Bar);\n\n\n\nProperty Injection\n\n\npublic interface IFoo {}\n\npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public IBar Bar { get; set; }\n}\n\npublic class Bar : IBar {}\n\n\n\nImplicit service registration\n\n\nRegisters the service without specifying any information about how to resolve the property dependencies.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIBar, Bar\n();\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.bar);\n\n\n\n\n\nNote:\n \nLightInject\n* considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will \nNOT*\n throw an exception in the case of an unresolved property dependency.\n          \n\n\n\n\nFor fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency.\n\n\ncontainer.RegisterPropertyDependency\nIBar\n((factory, propertyInfo) =\n new Bar());\n\n\n\nThis tells the container to inject a new \nBar\n instance whenever it sees an \nIBar\n property dependency.\n\n\nExplicit service registration\n\n\nRegisters a service by providing explicit information about how to create the service instance and how to resolve the property dependencies.\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nIFoo\n(factory =\n new Foo() {Bar = factory.GetInstance\nIBar\n()}) \nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.bar);\n\n\n\nProperty injection on existing instances.\n\n\nIn the cases where we don't control the creation of the service instance, \nLightInject\n can inject property dependencies into an existing instance.\n\n\ncontainer.Register\nIBar, Bar\n();\nvar foo = new Foo();\ncontainer.InjectProperties(foo);\nAssert.IsNotNull(foo);\n\n\n\nInitializers\n\n\nUse the \nInitialize\n method to perform service instance initialization/post-processing.  \n\n\ncontainer.Register\nIFoo, FooWithPropertyDependency\n();\ncontainer.Initialize(registration =\n registration.ServiceType == typeof(IFoo), \n    (factory, instance) =\n ((FooWithPropertyDependency)instance).Bar = new Bar());\nvar foo = (FooWithProperyDependency)container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));\n\n\n\nAssembly Scanning\n\n\nLightInject is capable of registering services by looking at the types of a given assembly.\n\n\ncontainer.RegisterAssembly(typeof(IFoo).Assembly)\n\n\n\nTo filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type.\n\n\ncontainer.RegisterAssembly(typeof(IFoo).Assembly, (serviceType, implementingType) =\n serviceType.NameSpace == \"SomeNamespace\");\n\n\n\nIt is also possible to scan a set assembly files based on a search pattern.\n\n\ncontainer.RegisterAssembly(\"SomeAssemblyName*.dll\");\n\n\n\nComposition Root\n\n\nWhen \nLightInject\n scans an assembly it will look for an implementation of the \nICompositionRoot\n interface.   \n\n\npublic class SampleCompositionRoot : ICompositionRoot\n{               \n    public void Compose(IServiceRegistry serviceRegistry)\n    {     \n        serviceRegistry.Register(typeof(IFoo),typeof(Foo));\n    }\n}\n\n\n\nIf one or more implementations of the \nICompositionRoot\n interface is found, they will be created and executed.\n\n\n\n\nNote:\n \nAny other services contained within the target assembly that is not registered in the composition root, will \nNOT\n be registered.\n\n\n\n\nRather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a \nICompositionRoot\n, is that they can easily be reused in automated tests.   \n\n\nLazy Composition Roots\n\n\nLightInject\n is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading.\n\n\nIf an unregistered service is requested, \nLightInject\n will scan the assembly where this service is contained.  \n\n\nCompositionRootAttribute\n\n\nWhen an assembly is being scanned, \nLightInject\n will look for implementations of the \nICompositionRoot\n interface. For large assemblies that contains many type, this might be an expensive operation. The \nCompositionRootAttribute\n is an assembly level attribute that simply helps \nLightInject\n to locate the compostion root.\n\n\n[assembly: CompositionRootType(typeof(SampleCompositionRoot))]\n\n\n\nRegisterFrom\n\n\nAllows explicit execution of a composition root.\n\n\ncontainer.RegisterFrom\nSampleCompositionRoot\n();\n\n\n\nGenerics\n\n\npublic interface IFoo\nT\n {};\npublic class Foo\nT\n : IFoo\nT\n {};\n\n\n\nThe container creates the closed generic type based on the service request.\n\n\ncontainer.Register(typeof(IFoo\n), typeof(Foo\n));\nvar instance = container.GetInstance(typeof(IFoo\nint\n));\nAssert.IsInstanceOfType(instance, typeof(Foo\nint\n));\n\n\n\nConstraints\n\n\nLightInject\n enforces generic constrains  \n\n\nLazy\nT\n\n\nLightInject\n can resolve a service as an instance of \nLazy\nT\n when we want to postpone resolving the underlying service until it is needed.\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar lazyFoo = container.GetInstance\nLazy\nIFoo\n();\nAssert.IsNotNull(lazyFoo.Value);\n\n\n\nFunction Factories\n\n\nFunction factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the \nService Locator\n (anti)pattern.\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo,Foo\n();\nvar func = container.GetInstance\nFunc\nIFoo\n();\nvar foo = func();\nAssert.IsNotNull(foo);\n\n\n\n\n\nNote:\n \nA function factory is effectively a delegate that redirects back to the corresponding \nGetInstance\n method on the service container.\n\n\n\n\nNamed Factories\n\n\nThe container returns a function delegate that represents calling the \nGetInstance\n method with \"SomeFoo\" as the service name argument.\n\n\ncontainer.Register\nIFoo, Foo\n(\"SomeFoo\");\nvar func = container.GetInstance\nFunc\nIFoo\n(\"SomeFoo\");   \nvar foo = func();\nAssert.IsNotNull(foo);\n\n\n\nParameters\n\n\nFunction factories can also take parameters that will be used create the service instance.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));\nvar fooFactory = container.GetInstance\nFunc\nint, IFoo\n();\nvar foo = (Foo)fooFactory(42); \nAssert.AreEqual(foo.Value, 42);\n\n\n\n\n\nNote\n : \nThe service must be explicitly registered in order for the container to resolve it as a parameterized function factory.\n\n\n\n\nIDisposable\n\n\nThe only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable.\n\n\npublic interface IFoo : IDisposable {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar fooFactory = container.GetInstance\nFunc\nIFoo\n();\n\nusing(IFoo foo = fooFactory())\n{\n\n} \n--Instance is disposed here\n\n\n\n\n\nNote:\n \nAlthough this is common practice even in the \nBCL\n, this kind of interfaces are often referred to as \nleaky abstractions\n.\n\n\n\n\nTyped Factories\n\n\nA typed factory is a class that wraps the function factory that is used to create the underlying service instance.\nAs opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory.   \n\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nIFoo\n createFoo;\n\n    public FooFactory(Func\nIFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo()\n    {\n        return createFoo();\n    }\n}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFooFactory, FooFactory\n(new PerContainerLifetime());\nvar fooFactory = container.GetInstance\nIFooFactory\n();\nvar foo = fooFactory.GetFoo();\nAssert.IsNotNull(foo);\n\n\n\n\n\nNote:\n \nRegister typed factories with the \nPerContainerLifetime\n unless a compelling reason exists to choose a different lifetime.\n  \n\n\n\n\nParameters\n\n\nTypes factories can also wrap a parameterized function factory and allows us to pass arguments.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nint, IFoo\n createFoo;\n\n    public FooFactory(Func\nint, IFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));\ncontainer.Register\nIFooFactory, FooFactory\n(new PerContainerLifetime());\nvar typedFooFactory = container.GetInstance\nIFooFactory\n();\nvar foo = typedFooFactory.GetFoo(42);\nAssert.AreEqual(foo.Value, 42);\n\n\n\nIDisposable\n\n\nWorking with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction.\n\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n    void Release(IFoo foo);\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nIFoo\n createFoo;\n\n    public FooFactory(Func\nIFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n\n    public void Release(IFoo foo)\n    {\n        var disposable = foo as IDisposable;\n        if (disposable != null)\n        {\n            disposable.Dispose();\n        }\n    }\n}\n\n\n\nRecursive dependency detection\n\n\nA recursive dependency graph is when a service depends directly or indirectly on itself.\n\n\npublic class FooWithRecursiveDependency : IFoo\n{\n    public FooWithRecursiveDependency(IFoo foo)\n    {\n    }\n}\n\n\n\nThe following code will throw an \nInvalidOperationException\n stating that there are existing recursive dependencies. \n\n\ncontainer.Register(typeof(IFoo), typeof(FooWithRecursiveDependency));\ncontainer.GetInstance\nIFoo\n()\n\n\n\nInternals\n\n\nWhen running under the .Net platform, \nLightInject\n is capable of creating instances of classes that has the \ninternal\n modifier. \n\n\nThe only requirement is that the internal class exposes a public constructor.\n\n\ninternal class InternalFooWithPublicConstructor : IFoo\n{\n    public InternalFooWithPublicConstructor () {}\n}\n\n\n\nLogging\n\n\nSometimes it might be useful to obtain information about what is going on inside the container \nand \nLightInject\n provides a very simple log abstraction that is used to log information and warnings from within the container.\n\n\nvar containerOptions = new ContainerOptions();\ncontainerOptions.LogFactory = (type) =\n logEntry =\n Console.WriteLine(logEntry.Message);", 
            "title": "Home"
        }, 
        {
            "location": "/#installing", 
            "text": "LightInject  provides two distribution models via NuGet", 
            "title": "Installing"
        }, 
        {
            "location": "/#binary", 
            "text": "PM  Install-Package LightInject \n      This adds a reference to the LightInject.dll in the target project.", 
            "title": "Binary"
        }, 
        {
            "location": "/#source", 
            "text": "PM  Install-Package LightInject.Source  \n      This will install a single file (LightInject.cs) into the current project.", 
            "title": "Source"
        }, 
        {
            "location": "/#creating-a-container", 
            "text": "var container = new LightInject.ServiceContainer();  The container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope.", 
            "title": "Creating a container"
        }, 
        {
            "location": "/#default-services", 
            "text": "public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar instance = container.GetInstance IFoo ();\nAssert.IsInstanceOfType(instance, typeof(Foo));", 
            "title": "Default services"
        }, 
        {
            "location": "/#named-services", 
            "text": "public class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}   container.Register IFoo, Foo ();\ncontainer.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instance = container.GetInstance IFoo (\"AnotherFoo\");\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));  If only one named registration exists,  LightInject  is capable of resolving this as the default service.  container.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instance = container.GetInstance IFoo ();\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));", 
            "title": "Named services"
        }, 
        {
            "location": "/#unresolved-services", 
            "text": "LightInject can resolve services that are not registered with the container using the  RegisterFallback  method.  var container = new ServiceContainer();\ncontainer.RegisterFallback((type, s) =  true, request =  new Foo());\nvar foo = container.GetInstance IFoo ();  The first argument to the  RegisterFallback  method makes it possible to possible to decide if the service can be \"late-resolved\".\nThe second argument is a  ServiceRequest  instance that provides the requested service type and service name.", 
            "title": "Unresolved services"
        }, 
        {
            "location": "/#ienumerablet", 
            "text": "When we register multiple services with the same service type,  LightInject  is capable of resolving these services as an   IEnumerable T .  public class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}   container.Register IFoo, Foo ();\ncontainer.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instances = container.GetInstance IEnumerable IFoo ()\nAssert.AreEqual(2, instances.Count());  Alternatively using the  GetAllInstances  method.  var instances = container.GetAllInstances IFoo ();\nAssert.AreEqual(2, instances.Count());  In addition,  LightInject  supports the following  IEnumerable T  sub-types.    Array  ICollection T  IList T  IReadOnlyCollection T  (Net 4.5 and Windows Runtime);  IReadOnlyList T  (Net 4.5 and Windows Runtime)   By default,  LightInject  will resolve all services that are compatible with the requested element type.  container.Register Foo ();\ncontainer.Register DerivedFoo ();\nvar instances = container.GetAllInstances Foo ();\nAssert.AreEqual(2, instances.Count());  This behavior can be overridden using the  EnableVariance  container option.  var container = new ServiceContainer(new ContainerOptions { EnableVariance = false });\ncontainer.Register Foo ();\ncontainer.Register DerivedFoo ();\nvar instances = container.GetAllInstances Foo ();\nAssert.AreEqual(1, instances.Count());", 
            "title": "IEnumerable&lt;T&gt;"
        }, 
        {
            "location": "/#values", 
            "text": "Registers the value as a constant.  container.RegisterInstance string (\"SomeValue\");\nvar value = container.GetInstance string ();\nAssert.AreEqual(\"SomeValue, value);", 
            "title": "Values"
        }, 
        {
            "location": "/#lifetime", 
            "text": "The default behavior in  LightInject  is to treat all objects as transients unless otherwise specified.  container.Register IFoo,Foo ();\nvar firstInstance = container.GetInstance IFoo ();\nvar secondInstance = container.GetInstance IFoo ();\nAssert.AreNotSame(firstInstance, secondInstance);", 
            "title": "Lifetime"
        }, 
        {
            "location": "/#perscopelifetime", 
            "text": "Ensures that only one instance of a given service can exists within a scope.\nThe container will call the  Dispose  method on all disposable objects created within the scope.  container.Register IFoo,Foo (new PerScopeLifetime());\nusing(container.BeginScope())\n{\n\n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreSame(firstInstance, secondInstance);\n}  Note:   An  InvalidOperationException  is thrown if a service registered with the  PerScopeLifetime  is requested outside the scope.", 
            "title": "PerScopeLifetime"
        }, 
        {
            "location": "/#percontainerlifetime", 
            "text": "Ensures that only one instance of a given service can exist within the container.\nThe container will call the Dispose method on all disposable objects when the container itself is disposed.  using(container = new ServiceContainer())\n{\n    container.Register IFoo,Foo (new PerContainerLifetime());   \n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreSame(firstInstance, secondInstance);\n}", 
            "title": "PerContainerLifetime"
        }, 
        {
            "location": "/#perrequestlifetime", 
            "text": "A new instance is created for each request and the container calls  Dispose  when the scope ends.\nThis lifetime is used when the conrete class implements  IDisposable .  container.Register IFoo,Foo (new PerRequestLifeTime());\nusing(container.BeginScope())\n{       \n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreNotSame(firstInstance, secondInstance);\n}   Note:   An  InvalidOperationException  is thrown if a service registered with the  PerRequestLifeTime  is requested outside the scope.", 
            "title": "PerRequestLifeTime"
        }, 
        {
            "location": "/#custom-lifetime", 
            "text": "A custom lifetime is created by implementing the  ILifetime  interface  internal interface ILifetime\n{\n    object GetInstance(Func object  instanceFactory, Scope currentScope);        \n}  The following example shows to create a custom lifetime that ensures only one instance per thread.  public class PerThreadLifetime : ILifetime\n{\n    ThreadLocal object  instances = new ThreadLocal object ();\n\n    public object GetInstance(Func object  instanceFactory, Scope currentScope)\n    {\n        if (instances.value == null)\n        {\n            instances.value = instanceFactory();\n        }\n        return instances.value;\n    }\n}  That is all it takes to create a custom lifetime, but what about disposable services?  public class PerThreadLifetime : ILifetime\n{\n    ThreadLocal object  instances = new ThreadLocal object ();\n\n    public object GetInstance(Func object  instanceFactory, Scope currentScope)\n    {           \n        if (instances.value == null)\n        {               \n            object instance = instanceFactory();                \n            IDisposable disposable = instance as IDisposable;               \n            if (disposable != null)\n            {\n                if (currentScope == null)\n                {\n                    throw new InvalidOperationException(\"Attempt to create an disposable object \n                                                        without a current scope.\")\n                }\n                currentScope.TrackInstance(disposable);\n            }\n\n            instances.value = instance;\n        }\n        return instance.value;\n    }\n}", 
            "title": "Custom lifetime"
        }, 
        {
            "location": "/#important", 
            "text": "A lifetime object controls the lifetime of a single service and can  never  be shared for multiple service registrations.  Wrong  ILifetime lifetime = new PerContainerLifeTime();\ncontainer.Register IFoo,Foo (lifetime);\ncontainer.Register IBar,Bar (lifetime);  Right  container.Register IFoo,Foo (new PerContainerLifeTime());\ncontainer.Register IBar,Bar (new PerContainerLifeTime());  A lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations.", 
            "title": "Important"
        }, 
        {
            "location": "/#async-and-await", 
            "text": "By default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread.  With the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread.  To illustrate this lets consider an example that is going to cause an instance to be resolved on another thread.  We start of by creating an interface that returns a  Task IBar  public interface IAsyncFoo\n{\n    Task IBar  GetBar();\n}  Next we implement this interface in such a way that the  IBar  instance is requested on another thread.  public class AsyncFoo : IAsyncFoo\n{\n    private readonly Lazy IBar  lazyBar;\n\n    public AsyncFoo(Lazy IBar  lazyBar)\n    {\n        this.lazyBar = lazyBar;\n    }\n\n    public async Task IBar  GetBar()\n    {\n        await Task.Delay(10);\n        return lazyBar.Value;  --This code is executed on another thread (continuation).\n    }\n}  The we register the dependency ( IBar ) with the  PerScopeLifetime  that is going to cause the container to ask for the current scope so that the instance can be registered with that scope.  var container = new ServiceContainer();\ncontainer.Register IBar, Bar (new PerScopeLifetime());\ncontainer.Register IAsyncFoo, AsyncFoo ();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance IAsyncFoo ();\n    ExceptionAssert.Throws AggregateException (() =  instance.GetBar().Wait());                \n}  This will throw an exception that states the following:  Attempt to create a scoped instance without a current scope.  The reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread.  To deal with this issue,  LightInject  now supports scopes across the logical  CallContext .    var container = new ServiceContainer();\ncontainer.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider();\ncontainer.Register IBar, Bar (new PerScopeLifetime());\ncontainer.Register IAsyncFoo, AsyncFoo ();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance IAsyncFoo ();\n    var bar = instance.GetBar().Result;\n    Assert.IsInstanceOfType(bar, typeof(IBar));\n}   Note that the  PerLogicalCallContextScopeManagerProvider  is only available when running under .Net 4.5.\nFor more information, please refer to the following  article  by Stephen Cleary.", 
            "title": "Async and Await"
        }, 
        {
            "location": "/#dependencies", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#constructor-injection", 
            "text": "public interface IFoo {}        \npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public Foo(IBar bar) \n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; } \n}\n\npublic class Bar : IBar {}", 
            "title": "Constructor Injection"
        }, 
        {
            "location": "/#implicit-service-registration", 
            "text": "Registers a service without specifying any information about how to resolve the constructor dependencies of the implementing type.  container.Register IFoo, Foo ();\ncontainer.Register IBar, Bar ();\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));   Note: In the case where the implementing type(Foo) has more than one constructor,  LightInject  will choose the constructor with the most parameters.    For fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency.  container.RegisterConstructorDependency IBar ((factory, parameterInfo) =  new Bar());  This tells the container to inject a new  Bar  instance whenever it sees an  IBar  constructor dependency.", 
            "title": "Implicit service registration"
        }, 
        {
            "location": "/#explicit-service-registration", 
            "text": "Registers a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies.  container.Register IBar, Bar ();\ncontainer.Register IFoo (factory =  new Foo(factory.GetInstance IBar ));\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.Bar);", 
            "title": "Explicit service registration"
        }, 
        {
            "location": "/#parameters", 
            "text": "Parameters are used when we want to supply one or more values when the service is resolved.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}   container.Register int, IFoo ((arg, factory) =  new Foo(arg));\nvar foo = (Foo)container.GetInstance int, IFoo (42);\nAssert.AreEqual(42,foo.Value);  We can also do a combination of supplied values and dependencies.  public class Foo : IFoo\n{\n    public Foo(int value, IBar bar)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n    public IBar Bar { get; private set; }\n}   container.Register IBar, Bar ();\ncontainer.Register int, IFoo ((factory, value) =  new Foo(value, factory.GetInstance IBar ()));\nvar foo = (Foo)container.GetInstance int, IFoo (42);\nAssert.AreEqual(42, foo.Value);\nAssert.IsNotNull(foo.Bar);", 
            "title": "Parameters"
        }, 
        {
            "location": "/#property-injection", 
            "text": "public interface IFoo {}\n\npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public IBar Bar { get; set; }\n}\n\npublic class Bar : IBar {}", 
            "title": "Property Injection"
        }, 
        {
            "location": "/#implicit-service-registration_1", 
            "text": "Registers the service without specifying any information about how to resolve the property dependencies.  container.Register IFoo, Foo ();\ncontainer.Register IBar, Bar ();\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.bar);   Note:   LightInject * considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will  NOT*  throw an exception in the case of an unresolved property dependency.              For fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency.  container.RegisterPropertyDependency IBar ((factory, propertyInfo) =  new Bar());  This tells the container to inject a new  Bar  instance whenever it sees an  IBar  property dependency.", 
            "title": "Implicit service registration"
        }, 
        {
            "location": "/#explicit-service-registration_1", 
            "text": "Registers a service by providing explicit information about how to create the service instance and how to resolve the property dependencies.  container.Register IBar, Bar ();\ncontainer.Register IFoo (factory =  new Foo() {Bar = factory.GetInstance IBar ()}) \nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.bar);", 
            "title": "Explicit service registration"
        }, 
        {
            "location": "/#property-injection-on-existing-instances", 
            "text": "In the cases where we don't control the creation of the service instance,  LightInject  can inject property dependencies into an existing instance.  container.Register IBar, Bar ();\nvar foo = new Foo();\ncontainer.InjectProperties(foo);\nAssert.IsNotNull(foo);", 
            "title": "Property injection on existing instances."
        }, 
        {
            "location": "/#initializers", 
            "text": "Use the  Initialize  method to perform service instance initialization/post-processing.    container.Register IFoo, FooWithPropertyDependency ();\ncontainer.Initialize(registration =  registration.ServiceType == typeof(IFoo), \n    (factory, instance) =  ((FooWithPropertyDependency)instance).Bar = new Bar());\nvar foo = (FooWithProperyDependency)container.GetInstance IFoo ();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));", 
            "title": "Initializers"
        }, 
        {
            "location": "/#assembly-scanning", 
            "text": "LightInject is capable of registering services by looking at the types of a given assembly.  container.RegisterAssembly(typeof(IFoo).Assembly)  To filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type.  container.RegisterAssembly(typeof(IFoo).Assembly, (serviceType, implementingType) =  serviceType.NameSpace == \"SomeNamespace\");  It is also possible to scan a set assembly files based on a search pattern.  container.RegisterAssembly(\"SomeAssemblyName*.dll\");", 
            "title": "Assembly Scanning"
        }, 
        {
            "location": "/#composition-root", 
            "text": "When  LightInject  scans an assembly it will look for an implementation of the  ICompositionRoot  interface.     public class SampleCompositionRoot : ICompositionRoot\n{               \n    public void Compose(IServiceRegistry serviceRegistry)\n    {     \n        serviceRegistry.Register(typeof(IFoo),typeof(Foo));\n    }\n}  If one or more implementations of the  ICompositionRoot  interface is found, they will be created and executed.   Note:   Any other services contained within the target assembly that is not registered in the composition root, will  NOT  be registered.   Rather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a  ICompositionRoot , is that they can easily be reused in automated tests.", 
            "title": "Composition Root"
        }, 
        {
            "location": "/#lazy-composition-roots", 
            "text": "LightInject  is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading.  If an unregistered service is requested,  LightInject  will scan the assembly where this service is contained.", 
            "title": "Lazy Composition Roots"
        }, 
        {
            "location": "/#compositionrootattribute", 
            "text": "When an assembly is being scanned,  LightInject  will look for implementations of the  ICompositionRoot  interface. For large assemblies that contains many type, this might be an expensive operation. The  CompositionRootAttribute  is an assembly level attribute that simply helps  LightInject  to locate the compostion root.  [assembly: CompositionRootType(typeof(SampleCompositionRoot))]", 
            "title": "CompositionRootAttribute"
        }, 
        {
            "location": "/#registerfrom", 
            "text": "Allows explicit execution of a composition root.  container.RegisterFrom SampleCompositionRoot ();", 
            "title": "RegisterFrom"
        }, 
        {
            "location": "/#generics", 
            "text": "public interface IFoo T  {};\npublic class Foo T  : IFoo T  {};  The container creates the closed generic type based on the service request.  container.Register(typeof(IFoo ), typeof(Foo ));\nvar instance = container.GetInstance(typeof(IFoo int ));\nAssert.IsInstanceOfType(instance, typeof(Foo int ));", 
            "title": "Generics"
        }, 
        {
            "location": "/#constraints", 
            "text": "LightInject  enforces generic constrains", 
            "title": "Constraints"
        }, 
        {
            "location": "/#lazyt", 
            "text": "LightInject  can resolve a service as an instance of  Lazy T  when we want to postpone resolving the underlying service until it is needed.  public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar lazyFoo = container.GetInstance Lazy IFoo ();\nAssert.IsNotNull(lazyFoo.Value);", 
            "title": "Lazy&lt;T&gt;"
        }, 
        {
            "location": "/#function-factories", 
            "text": "Function factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the  Service Locator  (anti)pattern.  public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo,Foo ();\nvar func = container.GetInstance Func IFoo ();\nvar foo = func();\nAssert.IsNotNull(foo);   Note:   A function factory is effectively a delegate that redirects back to the corresponding  GetInstance  method on the service container.", 
            "title": "Function Factories"
        }, 
        {
            "location": "/#named-factories", 
            "text": "The container returns a function delegate that represents calling the  GetInstance  method with \"SomeFoo\" as the service name argument.  container.Register IFoo, Foo (\"SomeFoo\");\nvar func = container.GetInstance Func IFoo (\"SomeFoo\");   \nvar foo = func();\nAssert.IsNotNull(foo);", 
            "title": "Named Factories"
        }, 
        {
            "location": "/#parameters_1", 
            "text": "Function factories can also take parameters that will be used create the service instance.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}   container.Register int, IFoo ((factory, value) =  new Foo(value));\nvar fooFactory = container.GetInstance Func int, IFoo ();\nvar foo = (Foo)fooFactory(42); \nAssert.AreEqual(foo.Value, 42);   Note  :  The service must be explicitly registered in order for the container to resolve it as a parameterized function factory.", 
            "title": "Parameters"
        }, 
        {
            "location": "/#idisposable", 
            "text": "The only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable.  public interface IFoo : IDisposable {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar fooFactory = container.GetInstance Func IFoo ();\n\nusing(IFoo foo = fooFactory())\n{\n\n}  --Instance is disposed here   Note:   Although this is common practice even in the  BCL , this kind of interfaces are often referred to as  leaky abstractions .", 
            "title": "IDisposable"
        }, 
        {
            "location": "/#typed-factories", 
            "text": "A typed factory is a class that wraps the function factory that is used to create the underlying service instance.\nAs opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory.     public interface IFooFactory\n{\n    IFoo GetFoo();\n}   public class FooFactory : IFooFactory\n{\n    private Func IFoo  createFoo;\n\n    public FooFactory(Func IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo()\n    {\n        return createFoo();\n    }\n}   container.Register IFoo, Foo ();\ncontainer.Register IFooFactory, FooFactory (new PerContainerLifetime());\nvar fooFactory = container.GetInstance IFooFactory ();\nvar foo = fooFactory.GetFoo();\nAssert.IsNotNull(foo);   Note:   Register typed factories with the  PerContainerLifetime  unless a compelling reason exists to choose a different lifetime.", 
            "title": "Typed Factories"
        }, 
        {
            "location": "/#parameters_2", 
            "text": "Types factories can also wrap a parameterized function factory and allows us to pass arguments.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}   public class FooFactory : IFooFactory\n{\n    private Func int, IFoo  createFoo;\n\n    public FooFactory(Func int, IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n}   container.Register int, IFoo ((factory, value) =  new Foo(value));\ncontainer.Register IFooFactory, FooFactory (new PerContainerLifetime());\nvar typedFooFactory = container.GetInstance IFooFactory ();\nvar foo = typedFooFactory.GetFoo(42);\nAssert.AreEqual(foo.Value, 42);", 
            "title": "Parameters"
        }, 
        {
            "location": "/#idisposable_1", 
            "text": "Working with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction.  public interface IFooFactory\n{\n    IFoo GetFoo(int value);\n    void Release(IFoo foo);\n}   public class FooFactory : IFooFactory\n{\n    private Func IFoo  createFoo;\n\n    public FooFactory(Func IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n\n    public void Release(IFoo foo)\n    {\n        var disposable = foo as IDisposable;\n        if (disposable != null)\n        {\n            disposable.Dispose();\n        }\n    }\n}", 
            "title": "IDisposable"
        }, 
        {
            "location": "/#recursive-dependency-detection", 
            "text": "A recursive dependency graph is when a service depends directly or indirectly on itself.  public class FooWithRecursiveDependency : IFoo\n{\n    public FooWithRecursiveDependency(IFoo foo)\n    {\n    }\n}  The following code will throw an  InvalidOperationException  stating that there are existing recursive dependencies.   container.Register(typeof(IFoo), typeof(FooWithRecursiveDependency));\ncontainer.GetInstance IFoo ()", 
            "title": "Recursive dependency detection"
        }, 
        {
            "location": "/#internals", 
            "text": "When running under the .Net platform,  LightInject  is capable of creating instances of classes that has the  internal  modifier.   The only requirement is that the internal class exposes a public constructor.  internal class InternalFooWithPublicConstructor : IFoo\n{\n    public InternalFooWithPublicConstructor () {}\n}", 
            "title": "Internals"
        }, 
        {
            "location": "/#logging", 
            "text": "Sometimes it might be useful to obtain information about what is going on inside the container \nand  LightInject  provides a very simple log abstraction that is used to log information and warnings from within the container.  var containerOptions = new ContainerOptions();\ncontainerOptions.LogFactory = (type) =  logEntry =  Console.WriteLine(logEntry.Message);", 
            "title": "Logging"
        }, 
        {
            "location": "/designpatterns/", 
            "text": "Design Patterns\n\n\nLightInject has built-in support for the Decorator pattern and the Composite pattern.\n\n\nDecorator Pattern\n\n\nA decorator is a class that implements the same interface as the type it is decorating and takes the target instance as a constructor argument.\n\n\npublic class FooDecorator : IFoo\n{     \n    public FooDecorator(IFoo foo)\n    {     \n    }\n}\n\n\n\nDecorators are applied using the \nDecorate\n method.   \n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Decorate(typeof(IFoo), typeof(FooDecorator));\n\nvar instance = container.GetInstance\nIFoo\n();\n\nAssert.IsInstanceOfType(instance, typeof(FooDecorator));\n\n\n\nDecorators can be nested and they are applied in the same sequence as they are registered.\n\n\ncontainer.Register\nIFoo, Foo\n();            \ncontainer.Decorate(typeof(IFoo), typeof(FooDecorator));\ncontainer.Decorate(typeof(IFoo), typeof(AnotherFooDecorator));\n\nvar instance = container.GetInstance\nIFoo\n();\n\nAssert.IsInstanceOfType(instance, typeof(AnotherFooDecorator));\n\n\n\nIf we have multiple services implementing the same interface, we can apply the decorator to implementations matching the given predicate.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\ncontainer.Decorate(typeof(IFoo), typeof(FooDecorator), service =\n service.ServiceName == \"AnotherFoo\");\n\nvar instance = container.GetInstance\nIFoo\n();\nvar decoratedInstance = container.GetInstance\nIFoo\n(\"AnotherFoo\");\n\nAssert.IsInstanceOfType(instance, typeof(Foo));\nAssert.IsInstanceOfType(decoratedInstance, typeof(FooDecorator));\n\n\n\nDecorators can have their own dependencies in addition to the target instance it is decorating.\n\n\npublic class FooDecoratorWithDependency : IFoo\n{        \n    public FooDecoratorWithDependency(IFoo foo, IBar bar)\n    {\n        Foo = foo;\n        Bar = bar;\n    }\n\n    public IFoo Foo { get; private set; }\n\n    public IBar Bar { get; private set; }\n}\n\n\n\nThe dependencies of the decorator can be implicitly resolved.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIBar, Bar\n();\ncontainer.Decorate(typeof(IFoo), typeof(FooDecoratorWithDependency));\n\nvar instance = (FooDecoratorWithDependency)container.GetInstance\nIFoo\n();\n\nAssert.IsInstanceOfType(instance.Foo, typeof(IFoo));\nAssert.IsInstanceOfType(instance.Bar, typeof(IBar));\n\n\n\nBy using a function factory, we can explicitly specify the depenendecies of the decorator.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIBar, Bar\n();\ncontainer.Decorate\nIFoo\n((serviceFactory, target) \n    =\n new FooDecoratorWithDependency(target, serviceFactory.GetInstance\nIBar\n()));\n\nvar instance = (FooDecoratorWithDependency)container.GetInstance\nIFoo\n();\n\nAssert.IsInstanceOfType(instance.Foo, typeof(IFoo));\nAssert.IsInstanceOfType(instance.Bar, typeof(IBar));\n\n\n\nNote:\n \nThe target instance is available through the function delegate so that we can pass it to the constructor of the decorator.\n\n\nDecorators can also be applied to open generic types.\n\n\ncontainer.Register(typeof(IFoo\n), typeof(Foo\n));\ncontainer.Decorate(typeof(IFoo\n), typeof(FooDecorator\n));\n\nvar instance = container.GetInstance\nIFoo\nint\n();\n\nAssert.IsInstanceOfType(instance, typeof(FooDecorator\nint\n));\n\n\n\nLazy Decorators\n\n\nA lazy decorator is a decorator that creates its target only when and if one of its methods are invoked.\n\n\npublic class LazyFooDecorator : IFoo\n{\n    private Lazy\nIFoo\n lazyFoo;\n    public LazyFooDecorator(Lazy\nIFoo\n lazyFoo)\n    {\n        this.lazyFoo = lazyFoo;\n    }\n\n    public void Execute()\n    {\n        lazyFoo.Value.Execute;\n    }\n}\n\n\n\nThis decorator then postpones the creation of the target \nIFoo\n instance until the Execute method is invoked.\n\n\nSince \nLightInject\n has native support for \nLazy\nT\n this becomes very easy to configure.\n\n\ncontainer.Register(typeof(IFoo), typeof(Foo));\ncontainer.Decorate(typeof(IFoo), typeof(LazyFooDecorator));\n\nvar instance = container.GetInstance\nIFoo\n();\n\nAssert.IsInstanceOfType(instance, typeof(LazyFooDecorator));\n\n\n\nComposite Pattern\n\n\nThe \ncomposite pattern\n is a simple pattern that lets a class implement an interface and then delegates invocation of methods to a set other classes implementing the same interface. \n\n\npublic class FooWithEnumerableIFooDependency : IFoo\n{\n    public IEnumerable\nIFoo\n FooList { get; private set; }\n\n    public FooWithEnumerableIFooDependency(IEnumerable\nIFoo\n fooList)\n    {\n        FooList = fooList;\n    }\n}\n\n\n\nWhile this looks like a recursive dependency, \nLightInject\n detects this and removes the  \nFooWithEnumerableIFooDependency\n from the IEnumerable\nIFoo\n beeing injected.    \n\n\ncontainer.Register(typeof(IFoo), typeof(Foo), \"Foo\");\ncontainer.Register(typeof(IFoo), typeof(AnotherFoo), \"AnotherFoo\");\ncontainer.Register(typeof(IFoo), typeof(FooWithEnumerableIFooDependency));            \nvar instance = (FooWithEnumerableIFooDependency)container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(instance.FooList.First(), typeof(Foo));\nAssert.IsInstanceOfType(instance.FooList.Last(), typeof(AnotherFoo));", 
            "title": "Patterns"
        }, 
        {
            "location": "/designpatterns/#design-patterns", 
            "text": "LightInject has built-in support for the Decorator pattern and the Composite pattern.", 
            "title": "Design Patterns"
        }, 
        {
            "location": "/designpatterns/#decorator-pattern", 
            "text": "A decorator is a class that implements the same interface as the type it is decorating and takes the target instance as a constructor argument.  public class FooDecorator : IFoo\n{     \n    public FooDecorator(IFoo foo)\n    {     \n    }\n}  Decorators are applied using the  Decorate  method.     container.Register IFoo, Foo ();\ncontainer.Decorate(typeof(IFoo), typeof(FooDecorator));\n\nvar instance = container.GetInstance IFoo ();\n\nAssert.IsInstanceOfType(instance, typeof(FooDecorator));  Decorators can be nested and they are applied in the same sequence as they are registered.  container.Register IFoo, Foo ();            \ncontainer.Decorate(typeof(IFoo), typeof(FooDecorator));\ncontainer.Decorate(typeof(IFoo), typeof(AnotherFooDecorator));\n\nvar instance = container.GetInstance IFoo ();\n\nAssert.IsInstanceOfType(instance, typeof(AnotherFooDecorator));  If we have multiple services implementing the same interface, we can apply the decorator to implementations matching the given predicate.  container.Register IFoo, Foo ();\ncontainer.Register IFoo, AnotherFoo (\"AnotherFoo\");\ncontainer.Decorate(typeof(IFoo), typeof(FooDecorator), service =  service.ServiceName == \"AnotherFoo\");\n\nvar instance = container.GetInstance IFoo ();\nvar decoratedInstance = container.GetInstance IFoo (\"AnotherFoo\");\n\nAssert.IsInstanceOfType(instance, typeof(Foo));\nAssert.IsInstanceOfType(decoratedInstance, typeof(FooDecorator));  Decorators can have their own dependencies in addition to the target instance it is decorating.  public class FooDecoratorWithDependency : IFoo\n{        \n    public FooDecoratorWithDependency(IFoo foo, IBar bar)\n    {\n        Foo = foo;\n        Bar = bar;\n    }\n\n    public IFoo Foo { get; private set; }\n\n    public IBar Bar { get; private set; }\n}  The dependencies of the decorator can be implicitly resolved.  container.Register IFoo, Foo ();\ncontainer.Register IBar, Bar ();\ncontainer.Decorate(typeof(IFoo), typeof(FooDecoratorWithDependency));\n\nvar instance = (FooDecoratorWithDependency)container.GetInstance IFoo ();\n\nAssert.IsInstanceOfType(instance.Foo, typeof(IFoo));\nAssert.IsInstanceOfType(instance.Bar, typeof(IBar));  By using a function factory, we can explicitly specify the depenendecies of the decorator.  container.Register IFoo, Foo ();\ncontainer.Register IBar, Bar ();\ncontainer.Decorate IFoo ((serviceFactory, target) \n    =  new FooDecoratorWithDependency(target, serviceFactory.GetInstance IBar ()));\n\nvar instance = (FooDecoratorWithDependency)container.GetInstance IFoo ();\n\nAssert.IsInstanceOfType(instance.Foo, typeof(IFoo));\nAssert.IsInstanceOfType(instance.Bar, typeof(IBar));  Note:   The target instance is available through the function delegate so that we can pass it to the constructor of the decorator.  Decorators can also be applied to open generic types.  container.Register(typeof(IFoo ), typeof(Foo ));\ncontainer.Decorate(typeof(IFoo ), typeof(FooDecorator ));\n\nvar instance = container.GetInstance IFoo int ();\n\nAssert.IsInstanceOfType(instance, typeof(FooDecorator int ));", 
            "title": "Decorator Pattern"
        }, 
        {
            "location": "/designpatterns/#lazy-decorators", 
            "text": "A lazy decorator is a decorator that creates its target only when and if one of its methods are invoked.  public class LazyFooDecorator : IFoo\n{\n    private Lazy IFoo  lazyFoo;\n    public LazyFooDecorator(Lazy IFoo  lazyFoo)\n    {\n        this.lazyFoo = lazyFoo;\n    }\n\n    public void Execute()\n    {\n        lazyFoo.Value.Execute;\n    }\n}  This decorator then postpones the creation of the target  IFoo  instance until the Execute method is invoked.  Since  LightInject  has native support for  Lazy T  this becomes very easy to configure.  container.Register(typeof(IFoo), typeof(Foo));\ncontainer.Decorate(typeof(IFoo), typeof(LazyFooDecorator));\n\nvar instance = container.GetInstance IFoo ();\n\nAssert.IsInstanceOfType(instance, typeof(LazyFooDecorator));", 
            "title": "Lazy Decorators"
        }, 
        {
            "location": "/designpatterns/#composite-pattern", 
            "text": "The  composite pattern  is a simple pattern that lets a class implement an interface and then delegates invocation of methods to a set other classes implementing the same interface.   public class FooWithEnumerableIFooDependency : IFoo\n{\n    public IEnumerable IFoo  FooList { get; private set; }\n\n    public FooWithEnumerableIFooDependency(IEnumerable IFoo  fooList)\n    {\n        FooList = fooList;\n    }\n}  While this looks like a recursive dependency,  LightInject  detects this and removes the   FooWithEnumerableIFooDependency  from the IEnumerable IFoo  beeing injected.      container.Register(typeof(IFoo), typeof(Foo), \"Foo\");\ncontainer.Register(typeof(IFoo), typeof(AnotherFoo), \"AnotherFoo\");\ncontainer.Register(typeof(IFoo), typeof(FooWithEnumerableIFooDependency));            \nvar instance = (FooWithEnumerableIFooDependency)container.GetInstance IFoo ();\nAssert.IsInstanceOfType(instance.FooList.First(), typeof(Foo));\nAssert.IsInstanceOfType(instance.FooList.Last(), typeof(AnotherFoo));", 
            "title": "Composite Pattern"
        }, 
        {
            "location": "/interception/", 
            "text": "Interception\n\n\nLightInject\n supports \nAspect Oriented Programming\n through proxy-based method interceptors. \n\n\nInstalling\n\n\nLightInject.Interception\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Interception \n\n   \n\n\n\n\n\nThis adds a reference to the LightInject.Interception.dll in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Interception.Source \n\n   \n\n\n\n\n\nThis will install a single file (LightInject.Interception.cs) into the current project.\n\n\nInterceptors\n\n\nAn interceptor sits between the call site and the target instance and intercepts method calls.\n\n\npublic class SampleInterceptor : IInterceptor\n{\n    public object Invoke(IInvocationInfo invocationInfo)\n    {\n        // Perform logic before invoking the target method\n        var returnValue = invocationInfo.Proceed();\n        // Perform logic after invoking the target method\n        return returnValue;           \n    }        \n}\n\n\n\n\nThe \nIInvocationInfo\n instance passed into the \nInvoke\n method contains information about the method being intercepted.\n\n\nThe \nProceed\n method calls down the chain of interceptors and ultimately the actual target instance.   \n\n\nAsynchronous Interceptors\n\n\nWhen intercepting asynchronous methods we need to be able to await the target method.\nThis can be done by inheriting from the abstract \nAsyncInterceptor\n class that does the heavy lifting with invoking the asynchronous wrapper methods.\nThe \nAsyncInterceptor\n class is a decorator that wraps around another \nIInterceptor\n. \n\n\npublic class SampleAsyncInterceptor : AsyncInterceptor\n{    \n    public SampleAsyncInterceptor(IInterceptor targetInterceptor) : base(targetInterceptor)\n    {\n    }\n\n    protected override async Task InvokeAsync(IInvocationInfo invocationInfo)\n    {\n        InterceptedTaskMethod = true;\n        // Before method invocation\n        await base.InvokeAsync(invocationInfo);\n        // After method invocation\n    }\n\n    protected override async Task\nT\n InvokeAsync\nT\n(IInvocationInfo invocationInfo)\n    {\n        InterceptedTaskOfTMethod = true;\n        // Before method invocation\n        var value = await base.InvokeAsync\nT\n(invocationInfo);\n        // After method invocation           \n        return value;\n    }\n}\n\n\n\n\n\n\nNote: Do not call invocationInfo.Proceed() directly when inheriting from the \nAsyncInterceptor\n class. \n\n\n\n\nWe can now create a new instance of the \nSampleAsyncInterceptor\n class like this:\n\n\nvar asyncInterceptor = new SampleAsyncInterceptor(new SampleInterceptor());\n\n\n\n\nAnother option is to register our \nIInterceptor\n with the container and use the \nDecorate\n method \nto apply the \nSampleAsyncInterceptor\n as a decorator.\n\n\ncontainer.Register\nIInterceptor, SampleInterceptor\n();\ncontainer.Decorate\nIInterceptor, SampleAsyncInterceptor\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), factory =\n factory.GetInstance\nIInterceptor\n()); \n\n\n\n\n\n\nNote: Only synchronous methods are passed down to the decorated \nIInterceptor\n \n\n\n\n\nSingle Interceptor\n\n\nThis example shows how to configure the service container with a single interceptor to handle all method calls.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), sf =\n new SampleInterceptor());\n\nvar instance = container.GetInstance\nIFoo\n();\n\n\n\nThe instance returned is a proxy object that forwards method calls to the \nSampleInterceptor\n class.\n\n\nThe first parameter of the \nIntercept\n method is a selector function used to select the services that should have this interceptor applied.       \n\nThe second parameter is a function delegate that used to create an \nIInterceptor\n instance. \n\n\nNote:\n \nProxy types are lazy in the sense that they will not create the target instance or any interceptors until the first method call is made.\n \n\n\nDependencies\n\n\nInterceptors might also have dependencies and by resolving the interceptor through the container, those dependencies can be injected into the interceptor itself. \n\n\npublic class SampleInterceptor : IInterceptor\n{\n    private IBar bar;\n\n    public SampleInterceptor(IBar bar) \n    {\n        this.bar = bar;    \n    }\n\n    public object Invoke(IInvocationInfo invocationInfo)\n\n        // Perform logic using the injected dependency before invoking the target method             \n        return invovationInfo.Proceed();                      \n        // Perform logic using the injected dependency after invoking the target method\n    }        \n}\n\n\n\nThe following example shows how to configure the container so that the \nSampleInterceptor\n instance is resolved through the container.\n\n\ncontainer.Register\nIFoo, Foo\n()\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nIInterceptor, SampleInterceptor\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), sf =\n sf.GetInstance\nIInterceptor\n());\n\n\n\nNote:\n \nWhen injecting depndencies into an interceptor we must make sure that the injected dependency is NOT intercepted by the same interceptor as this would cause a \nStackOverFlowException\n.\n  \n\n\nMultiple Interceptors\n\n\nInterceptors can be set up to handle a lot of cross cutting concerns such as logging, caching, null check and so on.\nAccording to the \nSingle Responsibility Principle\n, we can separate the combined logic into a set of interceptor that each only does \"one\" thing.\n\n\nWe can do this by using another overload of the \nIntercept\n method that allows us to set up a \nProxyDefinition\n instance that gives us more control over the proxy type that is being created.\n\n\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), (sf,pd) =\n  DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(new FirstInterceptor());\n    proxyDefinition.Implement(new SecondInterceptor());\n}\n\n\n\nNote:\n \nThe interceptors are invoked in the same order as they are registered with the \nImplement\n method.\n\n\nMethod Selectors\n\n\nMethod selectors are used to select the methods that should be intercepted by an interceptor.\n\n\nThe following example shows how to set up the container so that only calls method \nA\n is passed to the interceptor.\n\n\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), (sf, pd) =\n  DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =\n new SampleInterceptor(), m =\n m.Name == \"SomeMethodName\");       \n}\n\n\n\nMethods that does not match the method selector predicate will NOT be intercepted and method calls will be passed directly down to the target instance.  \n\n\nIf we omit the method selector, \nLightInject\n will intercept all methods from the target type and any additional interface, except methods that are inherited from \nSystem.Object\n.    \n\n\n\n\nEquals(Object)\n\n\nGetHashCode\n\n\nGetType\n\n\nToString\n\n\n\n\nIf we choose to use a method selector, these methods will also be intercepted if they match the predicate in the method selector.\n\n\nproxyDefinition.Implement(() =\n new SampleInterceptor(), m =\n m.IsDeclaredBy\nobject\n());\n\n\n\nWe can also use a method selector with the \nIntercept\n method that allows easy interception of any method without implementing an \nIInterceptor\n.\n\n\ncontainer.Intercept(m =\n m.Name == \"SomeMethodName\", invocationInfo =\n invocationInfo.Proceed());\n\n\n\nExtension Methods\n\n\nLightInject provides a set of extension method that simplifies method selector predicates.\n\n\n\n\nIsPropertySetter - Returns \ntrue\n if the method represents a property setter, otherwise \nfalse\n. \n\n\nIsPropertyGetter - Returns \ntrue\n if the method represents a property getter, otherwise \nfalse\n.\n\n\nGetProperty - Returns the property for which the target method either represents the property getter or the property setter.\n\n\n\n\nChaining Interceptors\n\n\nAs already seen in the example with multiple interceptors,  we can chain interceptors together. We can also combine this with method selectors that will affect the call sequence from the call site down to the actual target instance.\n\n\nConsider an interface with three methods.\n\n\npublic interface IFoo \n{\n    void A();\n    void B();\n    void C();\n}\n\n\n\nThe following example shows how we can control the call sequence for each method.\n\n\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), (sf, pd) =\n  DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =\n new FirstInterceptor(), m =\n m.Name == \"A\");\n    proxyDefinition.Implement(() =\n new SecondInterceptor(), m =\n m.Name == \"B\");   \n    proxyDefinition.Implement(() =\n new ThirdInterceptor(), m =\n m.Name == \"A\" || m.Name == \"B\" || m.Name == \"C\");\n}\n\n\n\nMethod A call sequence\n\n\nFirstInterceptor -\n ThirdInterceptor -\n Target \n\n\nMethod B call sequence\n\n\nSecondInterceptor -\n ThirdInterceptor -\n Target\n\n\nMethod C call sequence\n\n\nThirdInterceptor -\n Target\n\n\nImplementing additional interfaces\n\n\nAnother powerful feature of proxy objects is the ability to implement additional interfaces that is not implemented by the target type.\n\n\nThe \nIntercept\n method has an overload that lets us specify a set of interfaces to be implemented by the proxy type.\n\n\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), new []{ typeof(IBar) }, (sf, pd) =\n  DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =\n new BarInterceptor(), m =\n m.IsDeclaredBy\nIBar\n());        \n}\n\n\n\nWhen implementing additional interfaces we must make sure that all methods are intercepted by either one or a combined set of interceptors. This is because we are now dealing with methods that does not exist in the target type and we must do all implementation through interceptors.  \n\n\nIProxy\n\n\n/// \nsummary\n\n/// Implemented by all proxy types.\n/// \n/summary\n\npublic interface IProxy\n{\n    /// \nsummary\n\n    /// Gets the proxy target.\n    /// \n/summary\n\n    object Target { get; }\n}\n\n\n\nWe can get to the underlying target instance through the \nIProxy\n interface\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), sf =\n new SampleInterceptor());\n\nvar instance = container.GetInstance\nIFoo\n();\nvar actualTarget = ((IProxy)instance).Target;\n\n\n\nThis\n\n\nOne of the things to be aware of when working with proxy based interception is that it all relies on method calls being made through the proxy.\nMethod calls that are made directly to the target instance will NOT be intercepted. \n\n\npublic interface IFoo\n{\n    void A();\n}\n\npublic class Foo : IFoo\n{\n    public void A() {}\n\n    private void B()\n    {\n        //Calls the target (this) directly and interceptors are not invoked.\n        this.A();\n    }\n}\n\n\n\nAnother scenario is when the proxy instance itself is leaking its target.\n\n\npublic interface IFoo\n{\n    IFoo A();\n}\n\npublic class Foo\n{\n    public IFoo A()\n    {\n        return this;\n    }\n}\n\n\n\nLightInject\n will take care of this scenario and detect that we are about to return \nthis\n from a method and replace the return value with the proxy instance instead. \n\n\nOther scenarios such as event handlers or passing \"this\" to another method is NOT taken care of by \nLightInject\n as it is not possible without modifying the code in the target type itself. \n\n\nClass Proxies\n\n\nStarting from version 1.0.0.4, \nLightInject.Interception\n can be used to intercept classes with virtual members.\n\n\npublic class Foo\n{\n    public virtual void A()\n    {\n    }\n}\n\n\n\nAny member that is marked as virtual can be intercepted.    \n\n\nvar container = new ServiceContainer();\ncontainer.Register\nFoo\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(Foo), factory =\n new SampleInterceptor());\n\n\n\nClass proxies are implemented internally by subclassing the target type and overriding virtual members to support interception.", 
            "title": "Interception"
        }, 
        {
            "location": "/interception/#interception", 
            "text": "LightInject  supports  Aspect Oriented Programming  through proxy-based method interceptors.", 
            "title": "Interception"
        }, 
        {
            "location": "/interception/#installing", 
            "text": "LightInject.Interception  provides two distribution models via NuGet", 
            "title": "Installing"
        }, 
        {
            "location": "/interception/#binary", 
            "text": "PM  Install-Package LightInject.Interception  \n      This adds a reference to the LightInject.Interception.dll in the target project.", 
            "title": "Binary"
        }, 
        {
            "location": "/interception/#source", 
            "text": "PM  Install-Package LightInject.Interception.Source  \n      This will install a single file (LightInject.Interception.cs) into the current project.", 
            "title": "Source"
        }, 
        {
            "location": "/interception/#interceptors", 
            "text": "An interceptor sits between the call site and the target instance and intercepts method calls.  public class SampleInterceptor : IInterceptor\n{\n    public object Invoke(IInvocationInfo invocationInfo)\n    {\n        // Perform logic before invoking the target method\n        var returnValue = invocationInfo.Proceed();\n        // Perform logic after invoking the target method\n        return returnValue;           \n    }        \n}  The  IInvocationInfo  instance passed into the  Invoke  method contains information about the method being intercepted.  The  Proceed  method calls down the chain of interceptors and ultimately the actual target instance.", 
            "title": "Interceptors"
        }, 
        {
            "location": "/interception/#asynchronous-interceptors", 
            "text": "When intercepting asynchronous methods we need to be able to await the target method.\nThis can be done by inheriting from the abstract  AsyncInterceptor  class that does the heavy lifting with invoking the asynchronous wrapper methods.\nThe  AsyncInterceptor  class is a decorator that wraps around another  IInterceptor .   public class SampleAsyncInterceptor : AsyncInterceptor\n{    \n    public SampleAsyncInterceptor(IInterceptor targetInterceptor) : base(targetInterceptor)\n    {\n    }\n\n    protected override async Task InvokeAsync(IInvocationInfo invocationInfo)\n    {\n        InterceptedTaskMethod = true;\n        // Before method invocation\n        await base.InvokeAsync(invocationInfo);\n        // After method invocation\n    }\n\n    protected override async Task T  InvokeAsync T (IInvocationInfo invocationInfo)\n    {\n        InterceptedTaskOfTMethod = true;\n        // Before method invocation\n        var value = await base.InvokeAsync T (invocationInfo);\n        // After method invocation           \n        return value;\n    }\n}   Note: Do not call invocationInfo.Proceed() directly when inheriting from the  AsyncInterceptor  class.    We can now create a new instance of the  SampleAsyncInterceptor  class like this:  var asyncInterceptor = new SampleAsyncInterceptor(new SampleInterceptor());  Another option is to register our  IInterceptor  with the container and use the  Decorate  method \nto apply the  SampleAsyncInterceptor  as a decorator.  container.Register IInterceptor, SampleInterceptor ();\ncontainer.Decorate IInterceptor, SampleAsyncInterceptor ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(IFoo), factory =  factory.GetInstance IInterceptor ());    Note: Only synchronous methods are passed down to the decorated  IInterceptor", 
            "title": "Asynchronous Interceptors"
        }, 
        {
            "location": "/interception/#single-interceptor", 
            "text": "This example shows how to configure the service container with a single interceptor to handle all method calls.  container.Register IFoo, Foo ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(IFoo), sf =  new SampleInterceptor());\n\nvar instance = container.GetInstance IFoo ();  The instance returned is a proxy object that forwards method calls to the  SampleInterceptor  class.  The first parameter of the  Intercept  method is a selector function used to select the services that should have this interceptor applied.        \nThe second parameter is a function delegate that used to create an  IInterceptor  instance.   Note:   Proxy types are lazy in the sense that they will not create the target instance or any interceptors until the first method call is made.", 
            "title": "Single Interceptor"
        }, 
        {
            "location": "/interception/#dependencies", 
            "text": "Interceptors might also have dependencies and by resolving the interceptor through the container, those dependencies can be injected into the interceptor itself.   public class SampleInterceptor : IInterceptor\n{\n    private IBar bar;\n\n    public SampleInterceptor(IBar bar) \n    {\n        this.bar = bar;    \n    }\n\n    public object Invoke(IInvocationInfo invocationInfo)\n\n        // Perform logic using the injected dependency before invoking the target method             \n        return invovationInfo.Proceed();                      \n        // Perform logic using the injected dependency after invoking the target method\n    }        \n}  The following example shows how to configure the container so that the  SampleInterceptor  instance is resolved through the container.  container.Register IFoo, Foo ()\ncontainer.Register IBar, Bar ();\ncontainer.Register IInterceptor, SampleInterceptor ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(IFoo), sf =  sf.GetInstance IInterceptor ());  Note:   When injecting depndencies into an interceptor we must make sure that the injected dependency is NOT intercepted by the same interceptor as this would cause a  StackOverFlowException .", 
            "title": "Dependencies"
        }, 
        {
            "location": "/interception/#multiple-interceptors", 
            "text": "Interceptors can be set up to handle a lot of cross cutting concerns such as logging, caching, null check and so on.\nAccording to the  Single Responsibility Principle , we can separate the combined logic into a set of interceptor that each only does \"one\" thing.  We can do this by using another overload of the  Intercept  method that allows us to set up a  ProxyDefinition  instance that gives us more control over the proxy type that is being created.  container.Intercept(sr =  sr.ServiceType == typeof(IFoo), (sf,pd) =   DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(new FirstInterceptor());\n    proxyDefinition.Implement(new SecondInterceptor());\n}  Note:   The interceptors are invoked in the same order as they are registered with the  Implement  method.", 
            "title": "Multiple Interceptors"
        }, 
        {
            "location": "/interception/#method-selectors", 
            "text": "Method selectors are used to select the methods that should be intercepted by an interceptor.  The following example shows how to set up the container so that only calls method  A  is passed to the interceptor.  container.Intercept(sr =  sr.ServiceType == typeof(IFoo), (sf, pd) =   DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =  new SampleInterceptor(), m =  m.Name == \"SomeMethodName\");       \n}  Methods that does not match the method selector predicate will NOT be intercepted and method calls will be passed directly down to the target instance.    If we omit the method selector,  LightInject  will intercept all methods from the target type and any additional interface, except methods that are inherited from  System.Object .       Equals(Object)  GetHashCode  GetType  ToString   If we choose to use a method selector, these methods will also be intercepted if they match the predicate in the method selector.  proxyDefinition.Implement(() =  new SampleInterceptor(), m =  m.IsDeclaredBy object ());  We can also use a method selector with the  Intercept  method that allows easy interception of any method without implementing an  IInterceptor .  container.Intercept(m =  m.Name == \"SomeMethodName\", invocationInfo =  invocationInfo.Proceed());", 
            "title": "Method Selectors"
        }, 
        {
            "location": "/interception/#extension-methods", 
            "text": "LightInject provides a set of extension method that simplifies method selector predicates.   IsPropertySetter - Returns  true  if the method represents a property setter, otherwise  false .   IsPropertyGetter - Returns  true  if the method represents a property getter, otherwise  false .  GetProperty - Returns the property for which the target method either represents the property getter or the property setter.", 
            "title": "Extension Methods"
        }, 
        {
            "location": "/interception/#chaining-interceptors", 
            "text": "As already seen in the example with multiple interceptors,  we can chain interceptors together. We can also combine this with method selectors that will affect the call sequence from the call site down to the actual target instance.  Consider an interface with three methods.  public interface IFoo \n{\n    void A();\n    void B();\n    void C();\n}  The following example shows how we can control the call sequence for each method.  container.Intercept(sr =  sr.ServiceType == typeof(IFoo), (sf, pd) =   DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =  new FirstInterceptor(), m =  m.Name == \"A\");\n    proxyDefinition.Implement(() =  new SecondInterceptor(), m =  m.Name == \"B\");   \n    proxyDefinition.Implement(() =  new ThirdInterceptor(), m =  m.Name == \"A\" || m.Name == \"B\" || m.Name == \"C\");\n}  Method A call sequence  FirstInterceptor -  ThirdInterceptor -  Target   Method B call sequence  SecondInterceptor -  ThirdInterceptor -  Target  Method C call sequence  ThirdInterceptor -  Target", 
            "title": "Chaining Interceptors"
        }, 
        {
            "location": "/interception/#implementing-additional-interfaces", 
            "text": "Another powerful feature of proxy objects is the ability to implement additional interfaces that is not implemented by the target type.  The  Intercept  method has an overload that lets us specify a set of interfaces to be implemented by the proxy type.  container.Intercept(sr =  sr.ServiceType == typeof(IFoo), new []{ typeof(IBar) }, (sf, pd) =   DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =  new BarInterceptor(), m =  m.IsDeclaredBy IBar ());        \n}  When implementing additional interfaces we must make sure that all methods are intercepted by either one or a combined set of interceptors. This is because we are now dealing with methods that does not exist in the target type and we must do all implementation through interceptors.", 
            "title": "Implementing additional interfaces"
        }, 
        {
            "location": "/interception/#iproxy", 
            "text": "///  summary \n/// Implemented by all proxy types.\n///  /summary \npublic interface IProxy\n{\n    ///  summary \n    /// Gets the proxy target.\n    ///  /summary \n    object Target { get; }\n}  We can get to the underlying target instance through the  IProxy  interface  container.Register IFoo, Foo ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(IFoo), sf =  new SampleInterceptor());\n\nvar instance = container.GetInstance IFoo ();\nvar actualTarget = ((IProxy)instance).Target;", 
            "title": "IProxy"
        }, 
        {
            "location": "/interception/#this", 
            "text": "One of the things to be aware of when working with proxy based interception is that it all relies on method calls being made through the proxy.\nMethod calls that are made directly to the target instance will NOT be intercepted.   public interface IFoo\n{\n    void A();\n}\n\npublic class Foo : IFoo\n{\n    public void A() {}\n\n    private void B()\n    {\n        //Calls the target (this) directly and interceptors are not invoked.\n        this.A();\n    }\n}  Another scenario is when the proxy instance itself is leaking its target.  public interface IFoo\n{\n    IFoo A();\n}\n\npublic class Foo\n{\n    public IFoo A()\n    {\n        return this;\n    }\n}  LightInject  will take care of this scenario and detect that we are about to return  this  from a method and replace the return value with the proxy instance instead.   Other scenarios such as event handlers or passing \"this\" to another method is NOT taken care of by  LightInject  as it is not possible without modifying the code in the target type itself.", 
            "title": "This"
        }, 
        {
            "location": "/interception/#class-proxies", 
            "text": "Starting from version 1.0.0.4,  LightInject.Interception  can be used to intercept classes with virtual members.  public class Foo\n{\n    public virtual void A()\n    {\n    }\n}  Any member that is marked as virtual can be intercepted.      var container = new ServiceContainer();\ncontainer.Register Foo ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(Foo), factory =  new SampleInterceptor());  Class proxies are implemented internally by subclassing the target type and overriding virtual members to support interception.", 
            "title": "Class Proxies"
        }, 
        {
            "location": "/autofactory/", 
            "text": "AutoFactory\n\n\n\n\n\n\n\n\nLightInject.AutoFactory\n enables automatic implementation of factory interfaces.\n\n\nInstalling\n\n\nLightInject.AutoFactory\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.AutoFactory \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.AutoFactory.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.AutoFactory.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.AutoFactory.cs\n in the target project.\n\n\nFactory\n\n\nThe following interface represents a factory class used to resolve \nIFoo\n instances. \n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}\n\n\n\nInstead of having to manually implement the \nIFooFactory\n interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented.  You can enable this functionality by calling \nEnableAutoFactories\n on the container.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.EnableAutoFactories();\ncontainer.RegisterAutoFactory\nIFooFactory\n(); \nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo();\n\n\n\nParameters\n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo \n{\n    public Foo(int value) {}        \n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}\n\n\n\nRuntime arguments can now be passed to the factory method.\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));  \ncontainer.EnableAutoFactories();\ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo(42);\n\n\n\nNamed Services\n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic class AnotherFoo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n    IFoo GetAnotherFoo();\n}\n\n\n\nThe name of the factory method is used to identify named services.\n\n\ncontainer.Register\nIFoo, Foo\n();    \ncontainer.Register\nIFoo, Foo\n(\"AnotherFoo\");    \ncontainer.EnableAutoFactories();\ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo();\nvar anotherFoo = factory.GetAnotherFoo();\n\n\n\nOpen Generics\n\n\npublic interface IFoo\nT\n {}\n\npublic class Foo\nT\n : IFoo\nT\n {}\n\npublic interface IFooFactory\n{\n    IFoo\nT\n GetFoo\nT\n();    \n}\n\n\n\nThe generic type arguments from the factory method are used to create the service instance.\n\n\ncontainer.Register(typeof(IFoo\n), typeof(Foo\n));\ncontainer.EnableAutoFactories();\ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo\nint\n();", 
            "title": "AutoFactory"
        }, 
        {
            "location": "/autofactory/#autofactory", 
            "text": "LightInject.AutoFactory  enables automatic implementation of factory interfaces.", 
            "title": "AutoFactory"
        }, 
        {
            "location": "/autofactory/#installing", 
            "text": "LightInject.AutoFactory  provides two distribution models via NuGet", 
            "title": "Installing"
        }, 
        {
            "location": "/autofactory/#binary", 
            "text": "PM  Install-Package LightInject.AutoFactory  \n      This adds a reference to the  LightInject.AutoFactory.dll  in the target project.", 
            "title": "Binary"
        }, 
        {
            "location": "/autofactory/#source", 
            "text": "PM  Install-Package LightInject.AutoFactory.Source  \n      This will install a single file,  LightInject.AutoFactory.cs  in the target project.", 
            "title": "Source"
        }, 
        {
            "location": "/autofactory/#factory", 
            "text": "The following interface represents a factory class used to resolve  IFoo  instances.   public interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}  Instead of having to manually implement the  IFooFactory  interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented.  You can enable this functionality by calling  EnableAutoFactories  on the container.  container.Register IFoo, Foo ();\ncontainer.EnableAutoFactories();\ncontainer.RegisterAutoFactory IFooFactory (); \nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo();", 
            "title": "Factory"
        }, 
        {
            "location": "/autofactory/#parameters", 
            "text": "public interface IFoo {}\n\npublic class Foo : IFoo \n{\n    public Foo(int value) {}        \n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}  Runtime arguments can now be passed to the factory method.  container.Register int, IFoo ((factory, value) =  new Foo(value));  \ncontainer.EnableAutoFactories();\ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo(42);", 
            "title": "Parameters"
        }, 
        {
            "location": "/autofactory/#named-services", 
            "text": "public interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic class AnotherFoo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n    IFoo GetAnotherFoo();\n}  The name of the factory method is used to identify named services.  container.Register IFoo, Foo ();    \ncontainer.Register IFoo, Foo (\"AnotherFoo\");    \ncontainer.EnableAutoFactories();\ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo();\nvar anotherFoo = factory.GetAnotherFoo();", 
            "title": "Named Services"
        }, 
        {
            "location": "/autofactory/#open-generics", 
            "text": "public interface IFoo T  {}\n\npublic class Foo T  : IFoo T  {}\n\npublic interface IFooFactory\n{\n    IFoo T  GetFoo T ();    \n}  The generic type arguments from the factory method are used to create the service instance.  container.Register(typeof(IFoo ), typeof(Foo ));\ncontainer.EnableAutoFactories();\ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo int ();", 
            "title": "Open Generics"
        }, 
        {
            "location": "/annotation/", 
            "text": "Annotation\n\n\nLightInject\n supports annotation of properties and constructor parameters through an extension LightInject. \n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Annotation \n\n   \n\n\n\n\n\nBy using the \nInjectAttribute\n we can be more explicit about the services that gets injected into properties and constructor dependencies.\n\n\nNote:\n \nAs opposed to all other types within \nLightInject\n, the \nInjectAttribute\n is marked with the public access modifier so that is can be used outside the assembly that contains the service container. This creates a dependency from our services to the assembly containing the attribute, but we still don't need to reference any of the specific types in \nLightInject\n making this an affordable sacrifice when it comes to services referencing container specific types.\n  \n\n\nProperty Injection\n\n\nTo enable annotated property injection, we must execute the following line before we start requesting services from the container.\n\n\ncontainer.EnableAnnotatedPropertyInjection();\n\n\n\nThe container now only try to inject dependencies for properties that is annotated with the \nInjectAttribute\n.\nThe container will throw an \nInvalidOperationException\n if the annotated property dependency is unable to be resolved.\n\n\npublic class FooWithAnnotatedProperyDependency : IFoo\n{\n    [Inject]\n    public IBar Bar { get; set; }\n}\n\n\n\nGiven that we have a registration for the \nIBar\n dependency, it will be injected into the \nBar\n property.\n\n\ncontainer.Register\nIFoo, FooWithAnnotatedProperyDependency\n();\ncontainer.Register\nIBar, Bar\n();\nvar instance = (FooWithAnnotatedProperyDependency)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(instance.Bar);\n\n\n\nIf we have multiple registrations of the same interface, we can also use the \nInjectAttribute\n to specify the service to be injected. \n\n\npublic class FooWithNamedAnnotatedProperyDependency : IFoo\n{\n    [Inject(\"AnotherBar\")]\n    public IBar Bar { get; set; }\n}\n\n\n\nThe container will inject the service that matches the specified service name.\n\n\ncontainer.Register\nIFoo, FooWithNamedAnnotatedProperyDependency\n();\ncontainer.Register\nIBar, Bar\n(\"SomeBar\");\ncontainer.Register\nIBar, AnotherBar\n(\"AnotherBar\"); \nvar instance = (FooWithNamedAnnotatedProperyDependency)container.GetInstance\nIFoo\n();   \nAssert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));\n\n\n\nConstructor Injection\n\n\nTo enable annotated constructor injection, we must execute the following line before we start requesting services from the container.\n\n\ncontainer.EnableAnnotatedConstructorInjection();\n\n\n\nLightInject\n does consider all constructor parameters to be required dependencies and will try to satisfy all dependencies regardless of being annotated with the \nInjectAttribute\n. We can however use the \nInjectAttribute \n to specify the named service to be injected.\n\n\npublic class FooWithNamedAnnotatedDependency : IFoo\n{\n    public FooWithNamedAnnotatedDependency([Inject(ServiceName=\"AnotherBar\")]IBar bar)\n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; }\n}\n\n\n\nThe container will inject the service that matches the specified service name.\n\n\ncontainer.Register\nIFoo, FooWithNamedAnnotatedDependency\n();\ncontainer.Register\nIBar, Bar\n(\"SomeBar\");\ncontainer.Register\nIBar, AnotherBar\n(\"AnotherBar\"); \nvar instance = (FooWithNamedAnnotatedDependency)container.GetInstance\nIFoo\n();  \nAssert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));", 
            "title": "Annotation"
        }, 
        {
            "location": "/annotation/#annotation", 
            "text": "LightInject  supports annotation of properties and constructor parameters through an extension LightInject.   \n    \n          PM  Install-Package LightInject.Annotation  \n      By using the  InjectAttribute  we can be more explicit about the services that gets injected into properties and constructor dependencies.  Note:   As opposed to all other types within  LightInject , the  InjectAttribute  is marked with the public access modifier so that is can be used outside the assembly that contains the service container. This creates a dependency from our services to the assembly containing the attribute, but we still don't need to reference any of the specific types in  LightInject  making this an affordable sacrifice when it comes to services referencing container specific types.", 
            "title": "Annotation"
        }, 
        {
            "location": "/annotation/#property-injection", 
            "text": "To enable annotated property injection, we must execute the following line before we start requesting services from the container.  container.EnableAnnotatedPropertyInjection();  The container now only try to inject dependencies for properties that is annotated with the  InjectAttribute .\nThe container will throw an  InvalidOperationException  if the annotated property dependency is unable to be resolved.  public class FooWithAnnotatedProperyDependency : IFoo\n{\n    [Inject]\n    public IBar Bar { get; set; }\n}  Given that we have a registration for the  IBar  dependency, it will be injected into the  Bar  property.  container.Register IFoo, FooWithAnnotatedProperyDependency ();\ncontainer.Register IBar, Bar ();\nvar instance = (FooWithAnnotatedProperyDependency)container.GetInstance IFoo ();\nAssert.IsNotNull(instance.Bar);  If we have multiple registrations of the same interface, we can also use the  InjectAttribute  to specify the service to be injected.   public class FooWithNamedAnnotatedProperyDependency : IFoo\n{\n    [Inject(\"AnotherBar\")]\n    public IBar Bar { get; set; }\n}  The container will inject the service that matches the specified service name.  container.Register IFoo, FooWithNamedAnnotatedProperyDependency ();\ncontainer.Register IBar, Bar (\"SomeBar\");\ncontainer.Register IBar, AnotherBar (\"AnotherBar\"); \nvar instance = (FooWithNamedAnnotatedProperyDependency)container.GetInstance IFoo ();   \nAssert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));", 
            "title": "Property Injection"
        }, 
        {
            "location": "/annotation/#constructor-injection", 
            "text": "To enable annotated constructor injection, we must execute the following line before we start requesting services from the container.  container.EnableAnnotatedConstructorInjection();  LightInject  does consider all constructor parameters to be required dependencies and will try to satisfy all dependencies regardless of being annotated with the  InjectAttribute . We can however use the  InjectAttribute   to specify the named service to be injected.  public class FooWithNamedAnnotatedDependency : IFoo\n{\n    public FooWithNamedAnnotatedDependency([Inject(ServiceName=\"AnotherBar\")]IBar bar)\n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; }\n}  The container will inject the service that matches the specified service name.  container.Register IFoo, FooWithNamedAnnotatedDependency ();\ncontainer.Register IBar, Bar (\"SomeBar\");\ncontainer.Register IBar, AnotherBar (\"AnotherBar\"); \nvar instance = (FooWithNamedAnnotatedDependency)container.GetInstance IFoo ();  \nAssert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));", 
            "title": "Constructor Injection"
        }, 
        {
            "location": "/xunit/", 
            "text": "LightInject.xUnit\n\n\nLightInject.xUnit\n provides an integration that enables dependency injection in \nxUnit\n test methods.\n\n\nInstalling\n\n\nLightInject.xUnit\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.xUnit \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.Xunit.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.xUnit.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.Xunit.cs\n in the target project.\n\n\nInjecting services\n\n\nServices from \nLightInject\n are injected into methods that are decorated with the \nInjectData\n attribute. \n\n\n[Theory, InjectData]                \npublic void TestMethod(IFoo foo)\n{\n    Assert.NotNull(foo);\n}\n\n\n\nConfiguration\n\n\nLightInject\n will look for an \nICompositionRoot\n implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root.   \n\n\nIf such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature.\n\n\npublic static void Configure(IServiceContainer container)\n{\n    container.Register\nIFoo, Foo\n();            \n}\n\n\n\nThis method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.  \n\n\nScoping (xUnit \n= 1.9.2)\n\n\nServices registered with the \nPerScopeLifetime\n or \nPerRequestLifetime\n needs to be resolved within an active \nScope\n to ensure that any services that implements \nIDisposable\n are properly disposed.  \n\n\nBy decorating the test method with the \nScopedTheory\n attribute, a new \nScope\n will be started when the test method starts and it will end when the test method ends.   \n\n\n[ScopedTheory, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}\n\n\n\nScoping (xUnit \n= 2.0.0)\n\n\nServices registered with the \nPerScopeLifetime\n or \nPerRequestLifetime\n needs to be resolved within an active \nScope\n to ensure that any services that implements \nIDisposable\n are properly disposed.  \n\n\nBy decorating the test method with the \nScoped\n attribute, a new \nScope\n will be started when the test method starts and it will end when the test method ends.   \n\n\n[Theory, Scoped, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "xUnit"
        }, 
        {
            "location": "/xunit/#lightinjectxunit", 
            "text": "LightInject.xUnit  provides an integration that enables dependency injection in  xUnit  test methods.", 
            "title": "LightInject.xUnit"
        }, 
        {
            "location": "/xunit/#installing", 
            "text": "LightInject.xUnit  provides two distribution models via NuGet", 
            "title": "Installing"
        }, 
        {
            "location": "/xunit/#binary", 
            "text": "PM  Install-Package LightInject.xUnit  \n      This adds a reference to the  LightInject.Xunit.dll  in the target project.", 
            "title": "Binary"
        }, 
        {
            "location": "/xunit/#source", 
            "text": "PM  Install-Package LightInject.xUnit.Source  \n      This will install a single file,  LightInject.Xunit.cs  in the target project.", 
            "title": "Source"
        }, 
        {
            "location": "/xunit/#injecting-services", 
            "text": "Services from  LightInject  are injected into methods that are decorated with the  InjectData  attribute.   [Theory, InjectData]                \npublic void TestMethod(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Injecting services"
        }, 
        {
            "location": "/xunit/#configuration", 
            "text": "LightInject  will look for an  ICompositionRoot  implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root.     If such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature.  public static void Configure(IServiceContainer container)\n{\n    container.Register IFoo, Foo ();            \n}  This method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.", 
            "title": "Configuration"
        }, 
        {
            "location": "/xunit/#scoping-xunit-192", 
            "text": "Services registered with the  PerScopeLifetime  or  PerRequestLifetime  needs to be resolved within an active  Scope  to ensure that any services that implements  IDisposable  are properly disposed.    By decorating the test method with the  ScopedTheory  attribute, a new  Scope  will be started when the test method starts and it will end when the test method ends.     [ScopedTheory, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Scoping (xUnit &lt;= 1.9.2)"
        }, 
        {
            "location": "/xunit/#scoping-xunit-200", 
            "text": "Services registered with the  PerScopeLifetime  or  PerRequestLifetime  needs to be resolved within an active  Scope  to ensure that any services that implements  IDisposable  are properly disposed.    By decorating the test method with the  Scoped  attribute, a new  Scope  will be started when the test method starts and it will end when the test method ends.     [Theory, Scoped, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Scoping (xUnit &gt;= 2.0.0)"
        }, 
        {
            "location": "/web/", 
            "text": "Web\n\n\n\n\n\n\n\n\nEnables \nLightInject\n to be used in a web application and provides support for \nPerWebRequest\n scoped service instances.\n\n\nInstalling\n\n\nLightInject.Web\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Web \n\n   \n\n\n\n\n\nThis adds a reference to the LightInject.Web.dll in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Web.Source \n\n   \n\n\n\n\n\nThis will install a single file (LightInject.Web.cs) into the current project.\n\n\nThe following example shows how to enable \nLightInject\n in the \nApplication_Start\n event.\n\n\nprotected void Application_Start()\n{\n    var container = new ServiceContainer();\n    container.EnablePerWebRequestScope();                   \n    container.Register\nIFoo, Foo\n(new PerScopeLifetime());      \n}\n\n\n\nA service    registered with \nPerScopeLifetime\n is scoped per web request and is disposed at the end of the request if it implements \nIDisposable\n.", 
            "title": "Web"
        }, 
        {
            "location": "/web/#web", 
            "text": "Enables  LightInject  to be used in a web application and provides support for  PerWebRequest  scoped service instances.", 
            "title": "Web"
        }, 
        {
            "location": "/web/#installing", 
            "text": "LightInject.Web  provides two distribution models via NuGet", 
            "title": "Installing"
        }, 
        {
            "location": "/web/#binary", 
            "text": "PM  Install-Package LightInject.Web  \n      This adds a reference to the LightInject.Web.dll in the target project.", 
            "title": "Binary"
        }, 
        {
            "location": "/web/#source", 
            "text": "PM  Install-Package LightInject.Web.Source  \n      This will install a single file (LightInject.Web.cs) into the current project.  The following example shows how to enable  LightInject  in the  Application_Start  event.  protected void Application_Start()\n{\n    var container = new ServiceContainer();\n    container.EnablePerWebRequestScope();                   \n    container.Register IFoo, Foo (new PerScopeLifetime());      \n}  A service    registered with  PerScopeLifetime  is scoped per web request and is disposed at the end of the request if it implements  IDisposable .", 
            "title": "Source"
        }, 
        {
            "location": "/mvc/", 
            "text": "MVC\n\n\n\n\n\n\n\n\nLightInject.Mvc\n provides an integration that enables dependency injection in ASP.NET MVC applications. \n\n\nInstalling\n\n\nLightInject.Mvc\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Mvc \n\n   \n\n\n\n\n\nThis adds a reference to the LightInject.Mvc.dll in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Mvc.Source \n\n   \n\n\n\n\n\nThis will install a single file (LightInject.Mvc.cs) into the current project.\n\n\nInitializing\n\n\nprotected void Application_Start()\n{\n    var container = new ServiceContainer();\n    container.RegisterControllers();        \n    //register other services\n\n    container.EnableMvc()              \n}\n\n\n\nServices\n\n\nAll services that implements IDisposable,  must be registered with the \nPerScopeLifetime\n to ensure that they are properly disposed when the web request ends.\n\n\ncontainer.Register\nIFoo, Foo\n(new PerScopeLifetime());\n\n\n\nControllers are also disposable services and \nLightInject\n provides the \nRegisterControllers\n method that registers all controllers from a given assembly with the \nPerRequestLifetime\n. \n\n\ncontainer.RegisterControllers(typeof(MyMvcApplication).Assembly);\n\n\n\nFilterAttribute\n\n\nAlthough filter attributes are instantiated by the MFC infrastructure, \nLightInject\n is still able to inject dependencies into properties.\n\n\npublic class FooFilterAttribute : ActionFilterAttribute\n{\n    public IFoo Foo { get; set; }\n}", 
            "title": "Mvc"
        }, 
        {
            "location": "/mvc/#mvc", 
            "text": "LightInject.Mvc  provides an integration that enables dependency injection in ASP.NET MVC applications.", 
            "title": "MVC"
        }, 
        {
            "location": "/mvc/#installing", 
            "text": "LightInject.Mvc  provides two distribution models via NuGet", 
            "title": "Installing"
        }, 
        {
            "location": "/mvc/#binary", 
            "text": "PM  Install-Package LightInject.Mvc  \n      This adds a reference to the LightInject.Mvc.dll in the target project.", 
            "title": "Binary"
        }, 
        {
            "location": "/mvc/#source", 
            "text": "PM  Install-Package LightInject.Mvc.Source  \n      This will install a single file (LightInject.Mvc.cs) into the current project.", 
            "title": "Source"
        }, 
        {
            "location": "/mvc/#initializing", 
            "text": "protected void Application_Start()\n{\n    var container = new ServiceContainer();\n    container.RegisterControllers();        \n    //register other services\n\n    container.EnableMvc()              \n}", 
            "title": "Initializing"
        }, 
        {
            "location": "/mvc/#services", 
            "text": "All services that implements IDisposable,  must be registered with the  PerScopeLifetime  to ensure that they are properly disposed when the web request ends.  container.Register IFoo, Foo (new PerScopeLifetime());  Controllers are also disposable services and  LightInject  provides the  RegisterControllers  method that registers all controllers from a given assembly with the  PerRequestLifetime .   container.RegisterControllers(typeof(MyMvcApplication).Assembly);", 
            "title": "Services"
        }, 
        {
            "location": "/mvc/#filterattribute", 
            "text": "Although filter attributes are instantiated by the MFC infrastructure,  LightInject  is still able to inject dependencies into properties.  public class FooFilterAttribute : ActionFilterAttribute\n{\n    public IFoo Foo { get; set; }\n}", 
            "title": "FilterAttribute"
        }, 
        {
            "location": "/wcf/", 
            "text": "WCF\n\n\n\n\n\n\n\n\nLightInject.Wcf\n provides an integration that enables dependency injection in WCF applications. \n\n\nInstalling\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Wcf \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.Wcf.dll\n in the target project.\n\n\nGetting started\n\n\nLightInject.Wcf\n aims to provide a zero config approach to developing \nWCF\n services in addition to support both constructor and property injection for \nWCF\n service implementations. \n\n\nThe easiest way to create a new WCF application is to start with a new empty web application and then install the \nLightInject.Wcf\n package.\n\n\nOur first service might look something like this:\n\n\n[ServiceContract]\npublic interface IService\n{\n    [OperationContract]\n    int GetValue(int value);\n}\n\npublic class Service : IService\n{\n    public int GetValue(int value)\n    {\n        return value;\n    }\n}\n\n\n\nThe only thing we need to do is to create an ICompositionRoot implementation that registers our services and potentially its dependencies.\n\n\npublic class CompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.Register\nIService, Service\n();\n    }\n}\n\n\n\nThat's it. No XML config, no .svc files, just press F5 to run the application.\n\n\nGiven that our service is defined in the \nSampleWcfApplication\n namespace, the service will be available at \n\n\nhttp://localhost:xxxxx/SampleWcfApplication.IService.svc\n\n\n\nNamed Services\n\n\nIf we want to identify our service by something else than the full type name of the service interface, we need to register the service using a name. \n\n\npublic class CompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.Register\nIService, Service\n(\"MyService\");\n    }\n}\n\n\n\nNow we need one additional class to bootstrap the container so that the service is registered with the correct name before the service is invoked.\n\n\n[assembly: System.Web.PreApplicationStartMethod(typeof(SampleWcfApplication.Startup), \"Initialize\")]\nnamespace SampleWcfApplication\n{\n    using LightInject;\n    using LightInject.Wcf;\n\n    public class Startup\n    {\n        public static void Initialize()\n        {\n            var container = new ServiceContainer();\n            container.RegisterFrom\nCompositionRoot\n();\n            LightInjectServiceHostFactory.Container = container;\n        }\n    }\n}\n\n\n\nBehaviors\n\n\nWhile it still is possible to configure endpoint and service behaviors using XML, \nLightInject.Wcf\n allows for \nIEndpointBehavior\n and \nIServiceBehavior\n implementations to be registered with the container so that they can be applied to the service.\n\n\npublic class SampleServiceBehavior : IServiceBehavior\n{\n    public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)\n    {            \n    }\n\n    public void AddBindingParameters(\n        ServiceDescription serviceDescription,\n        ServiceHostBase serviceHostBase,\n        Collection\nServiceEndpoint\n endpoints,\n        BindingParameterCollection bindingParameters)\n    {            \n    }\n\n    public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)\n    {           \n    }\n}\n\npublic class SampleEndpointBehavior : IEndpointBehavior\n{\n    public void Validate(ServiceEndpoint endpoint)\n    {            \n    }\n\n    public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters)\n    {\n    }\n\n    public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher)\n    {\n    }\n\n    public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime)\n    {\n    }\n}\n\n\n\nIn order to configure these endpoints we can simply register them with the container.\n\n\npublic class CompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.Register\nIService, Service\n();\n        serviceRegistry.Register\nIServiceBehavior, SampleServiceBehavior\n();\n        serviceRegistry.Register\nIEndpointBehavior, SampleEndpointBehavior\n();\n    }\n}", 
            "title": "WCF"
        }, 
        {
            "location": "/wcf/#wcf", 
            "text": "LightInject.Wcf  provides an integration that enables dependency injection in WCF applications.", 
            "title": "WCF"
        }, 
        {
            "location": "/wcf/#installing", 
            "text": "PM  Install-Package LightInject.Wcf  \n      This adds a reference to the  LightInject.Wcf.dll  in the target project.", 
            "title": "Installing"
        }, 
        {
            "location": "/wcf/#getting-started", 
            "text": "LightInject.Wcf  aims to provide a zero config approach to developing  WCF  services in addition to support both constructor and property injection for  WCF  service implementations.   The easiest way to create a new WCF application is to start with a new empty web application and then install the  LightInject.Wcf  package.  Our first service might look something like this:  [ServiceContract]\npublic interface IService\n{\n    [OperationContract]\n    int GetValue(int value);\n}\n\npublic class Service : IService\n{\n    public int GetValue(int value)\n    {\n        return value;\n    }\n}  The only thing we need to do is to create an ICompositionRoot implementation that registers our services and potentially its dependencies.  public class CompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.Register IService, Service ();\n    }\n}  That's it. No XML config, no .svc files, just press F5 to run the application.  Given that our service is defined in the  SampleWcfApplication  namespace, the service will be available at   http://localhost:xxxxx/SampleWcfApplication.IService.svc", 
            "title": "Getting started"
        }, 
        {
            "location": "/wcf/#named-services", 
            "text": "If we want to identify our service by something else than the full type name of the service interface, we need to register the service using a name.   public class CompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.Register IService, Service (\"MyService\");\n    }\n}  Now we need one additional class to bootstrap the container so that the service is registered with the correct name before the service is invoked.  [assembly: System.Web.PreApplicationStartMethod(typeof(SampleWcfApplication.Startup), \"Initialize\")]\nnamespace SampleWcfApplication\n{\n    using LightInject;\n    using LightInject.Wcf;\n\n    public class Startup\n    {\n        public static void Initialize()\n        {\n            var container = new ServiceContainer();\n            container.RegisterFrom CompositionRoot ();\n            LightInjectServiceHostFactory.Container = container;\n        }\n    }\n}", 
            "title": "Named Services"
        }, 
        {
            "location": "/wcf/#behaviors", 
            "text": "While it still is possible to configure endpoint and service behaviors using XML,  LightInject.Wcf  allows for  IEndpointBehavior  and  IServiceBehavior  implementations to be registered with the container so that they can be applied to the service.  public class SampleServiceBehavior : IServiceBehavior\n{\n    public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)\n    {            \n    }\n\n    public void AddBindingParameters(\n        ServiceDescription serviceDescription,\n        ServiceHostBase serviceHostBase,\n        Collection ServiceEndpoint  endpoints,\n        BindingParameterCollection bindingParameters)\n    {            \n    }\n\n    public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)\n    {           \n    }\n}\n\npublic class SampleEndpointBehavior : IEndpointBehavior\n{\n    public void Validate(ServiceEndpoint endpoint)\n    {            \n    }\n\n    public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters)\n    {\n    }\n\n    public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher)\n    {\n    }\n\n    public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime)\n    {\n    }\n}  In order to configure these endpoints we can simply register them with the container.  public class CompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.Register IService, Service ();\n        serviceRegistry.Register IServiceBehavior, SampleServiceBehavior ();\n        serviceRegistry.Register IEndpointBehavior, SampleEndpointBehavior ();\n    }\n}", 
            "title": "Behaviors"
        }, 
        {
            "location": "/webapi/", 
            "text": "Web API\n\n\n\n\n\n\n\n\nLightInject.WebApi\n provides an integration that enables dependency injection in Web API applications.\n\n\nInstalling\n\n\nLightInject.WebApi\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.WebApi \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.WebApi.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.WebApi.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.WebApi.cs\n in the target project.\n\n\nInitializing\n\n\nprotected void Application_Start()\n{\n    var container = new ServiceContainer();\n    container.RegisterApiControllers();        \n    //register other services\n    container.EnablePerWebRequestScope();\n    container.EnableWebApi(GlobalConfiguration.Configuration)              \n}\n\n\n\n\n\n\nNote:\n EnablePerWebRequestScope is only required for hosting within ASP.Net \n\n\n\n\nFilterAttribute\n\n\nAlthough filter attributes are instantiated by the MFC infrastructure, \nLightInject\n is still able to inject dependencies into properties.\n\n\npublic class FooFilterAttribute : ActionFilterAttribute\n{\n    public IFoo Foo { get; set; }\n}\n\n\n\nOwin Selfhosting\n\n\nThis example shows how to do Web API self hosting using OWIN.\n\n\nStep 1\n\n\nCreate a standard console application and run the following command from the package manager console.\n\n\n\n   \n\n         \nPM\n Install-Package Microsoft.AspNet.WebApi.OwinSelfHost \n\n   \n\n\n\n\n\nStep 2\n\n\nAdd a OWIN startup class.\n\n\npublic class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {                        \n        // Configure Web API for self-host. \n        var config = new HttpConfiguration();          \n        config.Routes.MapHttpRoute(\n            name: \nDefaultApi\n,\n            routeTemplate: \napi/{controller}/{id}\n,\n            defaults: new { id = RouteParameter.Optional });\n\n        app.UseWebApi(config); \n    }\n}\n ```\n\n### Step 3 ###\n\nAdd a controller\n```csharp\npublic class ValuesController : ApiController\n{        \n    public IEnumerable\nstring\n Get()\n    {\n        return new string[] { \nvalue1\n, \nvalue2\n };\n    }        \n} \n\n\n\n\nStep 4\n\n\nModify the \nMain\n method to start the OWIN host.\n\n\nclass Program\n{\n    static void Main(string[] args)\n    {            \n        // Start OWIN host \n        using (WebApp.Start\nStartup\n(\nhttp://localhost:9000/\n))\n        {\n            Console.ReadLine(); \n        }\n\n        Console.ReadLine(); \n    }\n}  \n\n\n\n\nPress \nF5\n to run the application and browse to \nhttp://localhost:9000/api/values\n.\n\n\nStep 5\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.WebApi \n\n   \n\n\n\n\n\nModify the \nStartup\n class to enable LightInject to be used as the dependency resolver.\n\n\npublic class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {                        \n        // Configure Web API for self-host. \n        var config = new HttpConfiguration();\n        var container = new ServiceContainer();\n        container.RegisterApiControllers();\n        container.EnableWebApi(config);\n        config.Routes.MapHttpRoute(\n            name: \nDefaultApi\n,\n            routeTemplate: \napi/{controller}/{id}\n,\n            defaults: new { id = RouteParameter.Optional });\n\n        app.UseWebApi(config); \n    }\n}   \n\n\n\n\n\n\nNote: LightInject.Web can be uninstalled as it is not used in the self host scenario. \n\n\n\n\nScoping\n\n\nScopes are handled by Web API itself and services registered with the PerScopeLifetime or PerRequestLifetime are disposed when the web request ends.\n\n\nHttpRequestMessage\n\n\nThe current \nHttpRequestMessage\n is available to us in the controllers as it is exposed through the \nRequest\n property.\nTo make the \nHttpRequestMessage\n available to other services we need to make some minor changes\n\n\n\n\nThe following code will be included as part of the next version of LightInject.WebApi.\n\n\n\n\nThe first thing we need is a handler that can keep track of the current \nHttpRequestMessage\n.\n\n\ninternal class HttpRequestMessageHandler : DelegatingHandler\n{\n    private LogicalThreadStorage\nHttpRequestMessageStorage\n messageStorage =\n        new LogicalThreadStorage\nHttpRequestMessageStorage\n(() =\n new HttpRequestMessageStorage());\n\n    protected override Task\nHttpResponseMessage\n SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n    {\n        messageStorage.Value.Message = request;            \n        return base.SendAsync(request, cancellationToken);\n    }\n\n    public HttpRequestMessage GetCurrentMessage()\n    {\n        return messageStorage.Value.Message;\n    }\n}\n\n\n\n\nThe \nHttpRequestMessageStorage\n class is simply a \"holder\" class for the actual \nHttpRequestMessage\n.\n\n\npublic class HttpRequestMessageStorage\n{\n    public HttpRequestMessage Message { get; set; }\n}\n\n\n\n\nNext we modify the Startup class to support injection of a \nFunc\nHttpRequestMessage\n.\n\n\npublic class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {                                                \n        // Configure Web API for self-host. \n        var config = new HttpConfiguration();\n        var container = new ServiceContainer();\n        container.RegisterApiControllers();\n        container.EnableWebApi(config);\n        container.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider();\n        var handler = new HttpRequestMessageHandler();\n        config.MessageHandlers.Insert(0, handler);\n        container.Register\nFunc\nHttpRequestMessage\n(factory =\n () =\n handler.GetCurrentMessage());\n\n        config.Routes.MapHttpRoute(\n            name: \nDefaultApi\n,\n            routeTemplate: \napi/{controller}/{id}\n,\n            defaults: new { id = RouteParameter.Optional });\n\n        app.UseWebApi(config); \n    }\n}\n\n\n\n\nNow, if we need access to the current \nHttpRequestMessage\n, we can just inject a function delegate.\n\n\npublic class Foo\n{\n    public Foo(Func\nHttpRequestMessage\n getCurrentRequestMessage)\n    {\n        var currentMessage = getCurrentRequestMessage();\n    }\n\n}", 
            "title": "Web Api"
        }, 
        {
            "location": "/webapi/#web-api", 
            "text": "LightInject.WebApi  provides an integration that enables dependency injection in Web API applications.", 
            "title": "Web API"
        }, 
        {
            "location": "/webapi/#installing", 
            "text": "LightInject.WebApi  provides two distribution models via NuGet", 
            "title": "Installing"
        }, 
        {
            "location": "/webapi/#binary", 
            "text": "PM  Install-Package LightInject.WebApi  \n      This adds a reference to the  LightInject.WebApi.dll  in the target project.", 
            "title": "Binary"
        }, 
        {
            "location": "/webapi/#source", 
            "text": "PM  Install-Package LightInject.WebApi.Source  \n      This will install a single file,  LightInject.WebApi.cs  in the target project.", 
            "title": "Source"
        }, 
        {
            "location": "/webapi/#initializing", 
            "text": "protected void Application_Start()\n{\n    var container = new ServiceContainer();\n    container.RegisterApiControllers();        \n    //register other services\n    container.EnablePerWebRequestScope();\n    container.EnableWebApi(GlobalConfiguration.Configuration)              \n}   Note:  EnablePerWebRequestScope is only required for hosting within ASP.Net", 
            "title": "Initializing"
        }, 
        {
            "location": "/webapi/#filterattribute", 
            "text": "Although filter attributes are instantiated by the MFC infrastructure,  LightInject  is still able to inject dependencies into properties.  public class FooFilterAttribute : ActionFilterAttribute\n{\n    public IFoo Foo { get; set; }\n}", 
            "title": "FilterAttribute"
        }, 
        {
            "location": "/webapi/#owin-selfhosting", 
            "text": "This example shows how to do Web API self hosting using OWIN.", 
            "title": "Owin Selfhosting"
        }, 
        {
            "location": "/webapi/#step-1", 
            "text": "Create a standard console application and run the following command from the package manager console.  \n    \n          PM  Install-Package Microsoft.AspNet.WebApi.OwinSelfHost", 
            "title": "Step 1"
        }, 
        {
            "location": "/webapi/#step-2", 
            "text": "Add a OWIN startup class.  public class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {                        \n        // Configure Web API for self-host. \n        var config = new HttpConfiguration();          \n        config.Routes.MapHttpRoute(\n            name:  DefaultApi ,\n            routeTemplate:  api/{controller}/{id} ,\n            defaults: new { id = RouteParameter.Optional });\n\n        app.UseWebApi(config); \n    }\n}\n ```\n\n### Step 3 ###\n\nAdd a controller\n```csharp\npublic class ValuesController : ApiController\n{        \n    public IEnumerable string  Get()\n    {\n        return new string[] {  value1 ,  value2  };\n    }        \n}", 
            "title": "Step 2"
        }, 
        {
            "location": "/webapi/#step-4", 
            "text": "Modify the  Main  method to start the OWIN host.  class Program\n{\n    static void Main(string[] args)\n    {            \n        // Start OWIN host \n        using (WebApp.Start Startup ( http://localhost:9000/ ))\n        {\n            Console.ReadLine(); \n        }\n\n        Console.ReadLine(); \n    }\n}    Press  F5  to run the application and browse to  http://localhost:9000/api/values .", 
            "title": "Step 4"
        }, 
        {
            "location": "/webapi/#step-5", 
            "text": "PM  Install-Package LightInject.WebApi  \n      Modify the  Startup  class to enable LightInject to be used as the dependency resolver.  public class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {                        \n        // Configure Web API for self-host. \n        var config = new HttpConfiguration();\n        var container = new ServiceContainer();\n        container.RegisterApiControllers();\n        container.EnableWebApi(config);\n        config.Routes.MapHttpRoute(\n            name:  DefaultApi ,\n            routeTemplate:  api/{controller}/{id} ,\n            defaults: new { id = RouteParameter.Optional });\n\n        app.UseWebApi(config); \n    }\n}      Note: LightInject.Web can be uninstalled as it is not used in the self host scenario.", 
            "title": "Step 5"
        }, 
        {
            "location": "/webapi/#scoping", 
            "text": "Scopes are handled by Web API itself and services registered with the PerScopeLifetime or PerRequestLifetime are disposed when the web request ends.", 
            "title": "Scoping"
        }, 
        {
            "location": "/webapi/#httprequestmessage", 
            "text": "The current  HttpRequestMessage  is available to us in the controllers as it is exposed through the  Request  property.\nTo make the  HttpRequestMessage  available to other services we need to make some minor changes   The following code will be included as part of the next version of LightInject.WebApi.   The first thing we need is a handler that can keep track of the current  HttpRequestMessage .  internal class HttpRequestMessageHandler : DelegatingHandler\n{\n    private LogicalThreadStorage HttpRequestMessageStorage  messageStorage =\n        new LogicalThreadStorage HttpRequestMessageStorage (() =  new HttpRequestMessageStorage());\n\n    protected override Task HttpResponseMessage  SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n    {\n        messageStorage.Value.Message = request;            \n        return base.SendAsync(request, cancellationToken);\n    }\n\n    public HttpRequestMessage GetCurrentMessage()\n    {\n        return messageStorage.Value.Message;\n    }\n}  The  HttpRequestMessageStorage  class is simply a \"holder\" class for the actual  HttpRequestMessage .  public class HttpRequestMessageStorage\n{\n    public HttpRequestMessage Message { get; set; }\n}  Next we modify the Startup class to support injection of a  Func HttpRequestMessage .  public class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {                                                \n        // Configure Web API for self-host. \n        var config = new HttpConfiguration();\n        var container = new ServiceContainer();\n        container.RegisterApiControllers();\n        container.EnableWebApi(config);\n        container.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider();\n        var handler = new HttpRequestMessageHandler();\n        config.MessageHandlers.Insert(0, handler);\n        container.Register Func HttpRequestMessage (factory =  () =  handler.GetCurrentMessage());\n\n        config.Routes.MapHttpRoute(\n            name:  DefaultApi ,\n            routeTemplate:  api/{controller}/{id} ,\n            defaults: new { id = RouteParameter.Optional });\n\n        app.UseWebApi(config); \n    }\n}  Now, if we need access to the current  HttpRequestMessage , we can just inject a function delegate.  public class Foo\n{\n    public Foo(Func HttpRequestMessage  getCurrentRequestMessage)\n    {\n        var currentMessage = getCurrentRequestMessage();\n    }\n\n}", 
            "title": "HttpRequestMessage"
        }, 
        {
            "location": "/signalr/", 
            "text": "SignalR\n\n\nLightInject.Signal\n provides an integration that enables dependency injection in \nSignalR\n hub implementations.\n\n\nInstalling\n\n\nLightInject.SignalR\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.SignalR \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.SignalR.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.SignalR.Source \n\n   \n\n\n\n\n\nThis will install a single file (\nLightInject.SignalR.cs\n) into the current project. \n\n\nInitializing\n\n\nThe following example shows how to enable support for \nSignalR\n in an \nOWIN\n startup class.\n\n\npublic class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {\n        var serviceContainer = new ServiceContainer();\n        serviceContainer.RegisterHubs();            \n        ..register other services\n\n        app.MapSignalR(serviceContainer.EnableSignalR());\n    }\n}\n\n\n\nServices\n\n\nServices that implements \nIDisposable\n must be registered with the with the \nPerScopeLifetime\n or the \nPerRequestLifetime\n to ensure that they are properly disposed when the \nHub\n is disposed.", 
            "title": "SignalR"
        }, 
        {
            "location": "/signalr/#signalr", 
            "text": "LightInject.Signal  provides an integration that enables dependency injection in  SignalR  hub implementations.", 
            "title": "SignalR"
        }, 
        {
            "location": "/signalr/#installing", 
            "text": "LightInject.SignalR  provides two distribution models via NuGet", 
            "title": "Installing"
        }, 
        {
            "location": "/signalr/#binary", 
            "text": "PM  Install-Package LightInject.SignalR  \n      This adds a reference to the  LightInject.SignalR.dll  in the target project.", 
            "title": "Binary"
        }, 
        {
            "location": "/signalr/#source", 
            "text": "PM  Install-Package LightInject.SignalR.Source  \n      This will install a single file ( LightInject.SignalR.cs ) into the current project.", 
            "title": "Source"
        }, 
        {
            "location": "/signalr/#initializing", 
            "text": "The following example shows how to enable support for  SignalR  in an  OWIN  startup class.  public class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {\n        var serviceContainer = new ServiceContainer();\n        serviceContainer.RegisterHubs();            \n        ..register other services\n\n        app.MapSignalR(serviceContainer.EnableSignalR());\n    }\n}", 
            "title": "Initializing"
        }, 
        {
            "location": "/signalr/#services", 
            "text": "Services that implements  IDisposable  must be registered with the with the  PerScopeLifetime  or the  PerRequestLifetime  to ensure that they are properly disposed when the  Hub  is disposed.", 
            "title": "Services"
        }, 
        {
            "location": "/nancy/", 
            "text": "Nancy\n\n\nLightInject.Nancy\n provides an integration that enables \nLightInject\n to be used as the IoC container in the Nancy web framework.\n\n\nInstalling\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Nancy \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.Nancy.dll\n in the target project.\n\n\nDependencies\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\npublic class SampleModule : NancyModule\n{\n    public SampleModule(IFoo foo)\n    {\n        Get[\"/\"] = parameters =\n \"Hello World\";\n    }\n}\n\n\n\nConfiguring additional services/dependencies is done by implementing the \nICompositionRoot\n interface.\n\n\npublic class CompositionRoot : ICompositionRoot\n{\n    void ICompositionRoot.Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.Register\nIFoo, Foo\n();\n    }\n}\n\n\n\n\n\nNote: \nLightInject\n will look for an \nICompositionRoot\n implementation in the same assembly as the requested service.\n\n\n\n\nCustom Bootstrapper\n\n\nIf we need to use an existing container instance or perform some other configuration, this can be done by inheriting from the \nLightInjectNancyBootstrapper\n class. \n\n\npublic class Bootstrapper : LightInjectNancyBootstrapper\n{\n    protected override IServiceContainer GetServiceContainer()\n    {\n        // Alteratively provide an existing container instance.\n        return base.GetServiceContainer();\n    }\n}\n\n\n\nLifetime\n\n\nServices registered with the \nPerScopeLifetime\n are scoped per web request while services registered with the \nPerContainerLifetime\n are as scoped per application. \n\n\nNancyContext\n\n\nBy injecting a \nFunc\nNancyContext\n delegate we can get access to the \nNancyContext\n even outside of \nNancy\n modules.\n\n\npublic class Foo \n{\n    private readonly Func\nNancyContext\n getNancyContext;\n\n    public Foo(Func\nNancyContext\n getNancyContext)\n    {\n        this.getNancyContext = getNancyContext;\n    }\n\n    public void DoSomething()\n    {\n        var nancyContext = getNancyContext();\n    }\n}", 
            "title": "Nancy"
        }, 
        {
            "location": "/nancy/#nancy", 
            "text": "LightInject.Nancy  provides an integration that enables  LightInject  to be used as the IoC container in the Nancy web framework.", 
            "title": "Nancy"
        }, 
        {
            "location": "/nancy/#installing", 
            "text": "PM  Install-Package LightInject.Nancy  \n      This adds a reference to the  LightInject.Nancy.dll  in the target project.", 
            "title": "Installing"
        }, 
        {
            "location": "/nancy/#dependencies", 
            "text": "public interface IFoo {}\npublic class Foo : IFoo {}\n\npublic class SampleModule : NancyModule\n{\n    public SampleModule(IFoo foo)\n    {\n        Get[\"/\"] = parameters =  \"Hello World\";\n    }\n}  Configuring additional services/dependencies is done by implementing the  ICompositionRoot  interface.  public class CompositionRoot : ICompositionRoot\n{\n    void ICompositionRoot.Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.Register IFoo, Foo ();\n    }\n}   Note:  LightInject  will look for an  ICompositionRoot  implementation in the same assembly as the requested service.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/nancy/#custom-bootstrapper", 
            "text": "If we need to use an existing container instance or perform some other configuration, this can be done by inheriting from the  LightInjectNancyBootstrapper  class.   public class Bootstrapper : LightInjectNancyBootstrapper\n{\n    protected override IServiceContainer GetServiceContainer()\n    {\n        // Alteratively provide an existing container instance.\n        return base.GetServiceContainer();\n    }\n}", 
            "title": "Custom Bootstrapper"
        }, 
        {
            "location": "/nancy/#lifetime", 
            "text": "Services registered with the  PerScopeLifetime  are scoped per web request while services registered with the  PerContainerLifetime  are as scoped per application.", 
            "title": "Lifetime"
        }, 
        {
            "location": "/nancy/#nancycontext", 
            "text": "By injecting a  Func NancyContext  delegate we can get access to the  NancyContext  even outside of  Nancy  modules.  public class Foo \n{\n    private readonly Func NancyContext  getNancyContext;\n\n    public Foo(Func NancyContext  getNancyContext)\n    {\n        this.getNancyContext = getNancyContext;\n    }\n\n    public void DoSomething()\n    {\n        var nancyContext = getNancyContext();\n    }\n}", 
            "title": "NancyContext"
        }, 
        {
            "location": "/microsoft.dependencyinjection/", 
            "text": "LightInject.Microsoft.DependencyInjection\n\n\n\n\n\n\n\n\nEnables \nLightInject\n to be used as the service container in ASP.NET Core and Entity Framework 7 applications.\n\n\nInstalling\n\n\ndependencies\n: {\n  \nLightInject.Microsoft.DependencyInjection\n: \nversion\n\n}\n\n\n\n\nUsage\n\n\npublic class Startup\n{       \n    public IServiceProvider ConfigureServices(IServiceCollection services)\n    {\n        var container = new ServiceContainer();\n        return container.CreateServiceProvider(services);\n    }\n\n    public void Configure(IApplicationBuilder app)\n    {          \n        app.Run(async (context) =\n\n        {\n            await context.Response.WriteAsync(\nHello from LightInject\n);\n        });\n    }\n}\n\n\n\n\nControllers\n\n\nBy default, controllers are not actually created by \nLightInject\n. They are created by the ASP.NET infrastructure and uses LightInject to resolve its dependencies. To enable LightInject to create the controller instances, we need to add the following line.\n\n\nservices.AddMvc().AddControllersAsServices();", 
            "title": "Microsoft DependencyInjection"
        }, 
        {
            "location": "/microsoft.dependencyinjection/#lightinjectmicrosoftdependencyinjection", 
            "text": "Enables  LightInject  to be used as the service container in ASP.NET Core and Entity Framework 7 applications.", 
            "title": "LightInject.Microsoft.DependencyInjection"
        }, 
        {
            "location": "/microsoft.dependencyinjection/#installing", 
            "text": "dependencies : {\n   LightInject.Microsoft.DependencyInjection :  version \n}", 
            "title": "Installing"
        }, 
        {
            "location": "/microsoft.dependencyinjection/#usage", 
            "text": "public class Startup\n{       \n    public IServiceProvider ConfigureServices(IServiceCollection services)\n    {\n        var container = new ServiceContainer();\n        return container.CreateServiceProvider(services);\n    }\n\n    public void Configure(IApplicationBuilder app)\n    {          \n        app.Run(async (context) = \n        {\n            await context.Response.WriteAsync( Hello from LightInject );\n        });\n    }\n}", 
            "title": "Usage"
        }, 
        {
            "location": "/microsoft.dependencyinjection/#controllers", 
            "text": "By default, controllers are not actually created by  LightInject . They are created by the ASP.NET infrastructure and uses LightInject to resolve its dependencies. To enable LightInject to create the controller instances, we need to add the following line.  services.AddMvc().AddControllersAsServices();", 
            "title": "Controllers"
        }, 
        {
            "location": "/webapirequestlogging/", 
            "text": "Web Api Request Logging\n\n\nThis post is going to show you how to use \nLightInject\n to enable logging in a \nWeb Api\n application. We are going to look into how to preserve contextual information associated with the incoming request so that this information can be used for logging purposes. All this goodness is going to end up in a simple \nconsole application\n that shows how all the pieces fit together.\n\n\nLogging\n\n\nSince logging is a cross cutting concern and is to be found scattered all around in our application, it makes sense to create an abstraction so that we don't create a direct dependency on a particular logging framework. This abstraction is something that we should own rather than relying on third part abstraction such as \nCommon Logging\n. Believe me, that is going to cause us nothing but pain as we would have to deal with different versions of a third party abstraction. Own you own abstraction!\n\n\nWe start of with a simple interface that is going to be used for logging.\n\n\npublic interface ILog\n{      \n    void Info(string message);\n\n    void Debug(string message);\n\n    void Error(string message, Exception exception = null);\n}\n\n\n\n\nThis is the interface that we will be injection into controllers, services or any other class that requires logging.\n\n\nThe actual implementation of this interface looks like this\n\n\npublic class Log : ILog\n{\n    private readonly Action\nstring\n logDebug;\n    private readonly Action\nstring, Exception\n logError;\n    private readonly Action\nstring\n logInfo;\n\n    public Log(Action\nstring\n logInfo, Action\nstring\n logDebug, Action\nstring, Exception\n logError)\n    {\n        this.logInfo = logInfo;\n        this.logDebug = logDebug;\n        this.logError = logError;\n    }\n\n    public void Info(string message)\n    {\n        logInfo(message);\n    }\n\n    public void Debug(string message)\n    {\n        logDebug(message);\n    }\n\n    public void Error(string message, Exception exception = null)\n    {\n        logError(message, exception);\n    }\n}\n\n\n\n\nThe \nLog\n class is not tied to a specific logging framework and it just takes a set of action delegates that represents the three logging levels supported by our abstraction.\n\n\nTo help us create a \nLog\n instance, we have this nice little interface.\n\n\npublic interface ILogFactory\n{\n    ILog GetLogger(Type type);\n}\n\n\n\n\nAnd since we are going to be using \nLog4Net\n in this sample application, we have an implementation called \nLog4NetLogFactory\n.\n\n\npublic class Log4NetLogFactory : ILogFactory\n{\n    public Log4NetLogFactory()\n    {\n        XmlConfigurator.Configure();           \n    }\n\n    public ILog GetLogger(Type type)\n    {            \n        var logger = LogManager.GetLogger(type);            \n        return new Log(logger.Info, logger.Debug, logger.Error);\n    }\n}\n\n\n\n\n\n\nNote: This is the ONLY place where we actually reference Log4Net.\n\n\n\n\nComposition root\n\n\nThis application has two composition roots (\nICompositionRoot\n), one that registers the core services (\nCompositionRoot\n )and one that registers services related to \nWeb Api\n (\nWebApiCompositionRoot\n). \n\n\npublic class CompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {            \n        serviceRegistry.Register\nILogFactory, Log4NetLogFactory\n(new PerContainerLifetime());\n        serviceRegistry.Register\nType, ILog\n((factory, type) =\n factory.GetInstance\nILogFactory\n().GetLogger(type));\n        serviceRegistry.RegisterConstructorDependency(\n            (factory, info) =\n factory.GetInstance\nType, ILog\n(info.Member.DeclaringType));            \n    }\n}\n\n\n\n\nThe first service that we register is the \nILogFactory\n that is responsible for creating an \nILog\n instance based on a given type.\n\n\nNext, we register the \nILog\n service with a factory delegate that calls into the already registered \nILogFactory\n service\n\n\nFinally we tell the container using the \nRegisterConstructorDependency\n method that whenever it sees an \nILog\n constructor dependency, it should provide an \nILog\n instance based on the actual class that uses it. \n\n\npublic class WebApiCompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.RegisterFrom\nCompositionRoot\n();\n        serviceRegistry.RegisterApiControllers();\n    }\n}\n\n\n\n\nThe \nWebApiCompositionRoot\n registers core services in addition services related to \nWeb Api\n which in this case means the controllers. \n\n\nControllers\n\n\nThis application has just one controller named \nPingController\n that is simply going to return the text \"pong\".\n\n\npublic class PingController : ApiController\n{\n    private readonly ILog log;\n\n    public PingController(ILog log)\n    {\n        this.log = log;\n    }\n\n    public async Task\nIHttpActionResult\n Get()\n    {\n        log.Info(\nPing start\n);        \n        var result =  Ok(\nPong\n);\n        log.Info(\nPing end\n);\n        return result;\n    }\n}\n\n\n\n\nAs we can see we are injecting an \nILog\n instance into the controller.\n\n\nThe \nStartup\n class for this application looks like this\n\n\npublic class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {\n        var configuration = new HttpConfiguration();\n        ConfigureHttpRoutes(configuration);\n        ConfigureMediaFormatter(configuration);\n\n        var container = new ServiceContainer();\n        container.RegisterFrom\nWebApiCompositionRoot\n();            \n        container.EnableWebApi(configuration);           \n\n        app.UseWebApi(configuration);\n    }\n\n    private static void ConfigureMediaFormatter(HttpConfiguration configuration)\n    {\n        configuration.Formatters.Clear();\n        configuration.Formatters.Add(new JsonMediaTypeFormatter());\n    }\n\n    private static void ConfigureHttpRoutes(HttpConfiguration config)\n    {\n        config.Routes.MapHttpRoute(\n            name: \nAPI Default\n,\n            routeTemplate: \napi/{controller}/{id}\n,\n            defaults: new { id = RouteParameter.Optional });\n    }\n}\n\n\n\n\nWe can see all this in action just by running the application and hitting the service.\n\n\nhttp://localhost:8080/api/ping\n\n\n\n\nThat should yield the following output in the console\n\n\n2016-02-11 09:14:28.489 [INFO] 13 WebApiRequestLogging.PingController: Ping start\n2016-02-11 09:14:28.603 [INFO] 6 WebApiRequestLogging.PingController: Ping end\n\n\n\n\nThe \nLog4Net\n conversion pattern is like this (app.config)\n\n\nconversionPattern value=\n%date{yyyy-MM-dd HH:mm:ss.fff} [%level] %thread %logger: %message%newline\n /\n\n\n\n\n\nRequest logging\n\n\nSometimes it might be useful to log each request and maybe also the duration of the request.\nWe start off with a simple class (\nOwinMiddleware\n) that logs the duration of the request.\n\n\npublic class RequestLoggingMiddleware : OwinMiddleware\n{\n    private readonly ILog log;\n\n\n    public RequestLoggingMiddleware(OwinMiddleware next, ILog log) : base(next)\n    {\n        this.log = log;\n    }\n\n    public override async Task Invoke(IOwinContext context)\n    {            \n        await Measure(context).ConfigureAwait(false);;            \n    }\n\n    private async Task Measure(IOwinContext context)\n    {\n        var stopWath = Stopwatch.StartNew();\n        await Next.Invoke(context).ConfigureAwait(false);\n        stopWath.Stop();\n        log.Info($\nRequest {context.Request.Uri.PathAndQuery} took {stopWath.ElapsedMilliseconds} ms\n);\n    }\n}\n\n\n\n\nIn addition to this we need to add this new middleware to the \nOwin\n pipeline by adding this line to the \nStartup\n class.\n\n\napp.Use\nRequestLoggingMiddleware\n(container.GetInstance\nType, ILog\n(typeof (RequestLogDecorator)));\n\n\n\n\n\n\nNote: The reason for using an \nOwinMiddleware\n instead of a \nDelegatingHandler\n is that the \nOwinMiddleware\n is not tied to \nWeb Api\n in any way and can also be used in other frameworks that build upon the \nOwin\n stack.\n\n\n\n\nConsole output should now be\n\n\n2016-02-11 13:07:48.466 [INFO] 11 WebApiRequestLogging.RequestLoggingMiddleware: Request /api/ping took 4 ms\n\n\n\n\nRequest Context\n\n\nIn some situations it is useful to be able to associate all log entries with the current web request. This can be used for analyzing the log later in tools such as \nSplunk\n making it possible to see all log entries tied to any given request.\n\n\nWe could make the \nIOwinContext\n available in the container so that it could be injected into any class that requires information about the current request. This would however mean that these classes would have to know about the \nIOwinContext\n which might not be the best solution. \n\n\nSo let's start off simple by creating a class to hold the request identifier.\n\n\npublic class RequestContext\n{\n    public RequestContext(string id)\n    {\n        Id = id;\n    }\n\n    public string Id { get; } \n}\n\n\n\n\nNext we create another middleware class to set the request identifier.\n\n\npublic class RequestContextMiddleware : OwinMiddleware\n{\n    private static readonly AsyncLocal\nRequestContext\n RequestContextStorage = new AsyncLocal\nRequestContext\n();\n\n    public RequestContextMiddleware(OwinMiddleware next) : base(next)\n    {\n    }\n\n    public override async Task Invoke(IOwinContext context)\n    {\n        RequestContextStorage.Value = new RequestContext(Guid.NewGuid().ToString());\n        await Next.Invoke(context);\n    }\n\n    public static RequestContext CurrentRequest =\n RequestContextStorage.Value;\n}\n\n\n\n\nThe actual \nRequestContext\n uses the \nAsyncLocal\nT\n class to ensure that the context flows across await points.\n\n\n\n\nThe \nAsyncLocal\nT\n class is sort of the async version of \nThreadLocal\nT\n. You should NEVER rely on any kind of storage that is tied to a specific thread in an async environment.\n\n\n\n\nThen we need to add the  \nRequestContextMiddleware\n to the \nOwin\n pipeline.\n\n\n app.Use\nRequestContextMiddleware\n();\n\n\n\n\nWe now have way to access the current \nRequestContext\n through the \nCurrentRequest\n property. Sweet.\n\n\nThe only thing missing now is to register a function delegate that represent getting the current \nRequestContext\n.\n\n\nserviceRegistry.Register\nFunc\nRequestContext\n(factory =\n (() =\n RequestContextMiddleware.CurrentRequest), new PerContainerLifetime());\n\n\n\n\nThe reason for injection a function delegate rather than just the \nRequestContext\n is that it might be used in services such as singletons that outlives the scope of a web request. By injecting the delegate that in turn gives us the \nRequestContext\n, we can be sure that it is valid.\n\n\nDecorators\n\n\nThe requirement here is that if we are logging outside the context of a web request, such as in a unit test, we should just log without the request identifier, but if we log inside a web request (production or integration tests), we should add the request identifier to the message being logged. This is a perfect example of where we can apply the \nDecorator Pattern\n. This allows us to add new functionality to a service without touching the original implementation. Did I hear \"open-closed principle\", anyone?\n\n\npublic class RequestLogDecorator : ILog\n{\n    private readonly ILog log;\n    private readonly Func\nRequestContext\n getRequestContext;\n\n    public RequestLogDecorator(ILog log, Func\nRequestContext\n getRequestContext)\n    {\n        this.log = log;\n        this.getRequestInfo = getRequestInfo;\n    }\n\n    public void Info(string message)\n    {\n        log.Info($\nRequest id: {getRequestContext().Id} {message}\n);\n    }\n\n    public void Debug(string message)\n    {\n        log.Debug($\nRequest id: {getRequestContext().Id} {message}\n);\n    }\n\n    public void Error(string message, Exception exception = null)\n    {\n        log.Error($\nRequest id: {getRequestContext().Id} {message}\n, exception);\n    }\n}\n\n\n\n\nThe decorator simply wraps the original \nILog\n instance and applies the request identifier now returned from the \ngetRequestContext\n delegate.  Don't you just love the new string interpolation features? \n\n\n\n\nNote: If you are new to the decorator pattern, you can think of it as a \nRussian Doll\n where inside there is an exact identical doll wrapped by an outer doll.\n\n\n\n\nDecorators are first-class citizens in \nLightInject\n and applying a decorator is just a one-liner in the \nWepApiCompositionRoot\n class.\n\n\nserviceRegistry.Decorate\nILog, RequestLogDecorator\n();\n\n\n\n\nSince we only apply the decorator in the \nWepApiCompositionRoot\n class it will only be used in the context of a web request.\n\n\nTo \"ensure\" that we don't always log on the same thread, we modify the \nPingController\n to inlude a delay.\n\n\npublic async Task\nIHttpActionResult\n Get()\n{\n    log.Info(\nPing start\n);\n\n    //ConfigureAwait(false) to say that we don't care about synchronization context.\n    await Task.Delay(100).ConfigureAwait(false);\n\n    // We are probably on another thread here\n    var result =  Ok(\nPong\n);\n    log.Info(\nPing end\n);\n    return result;\n}\n\n\n\n\nRunning the application and hitting the service should now yield the following output in the console\n\n\n2016-02-11 20:40:30.994 [INFO] 12 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping start\n2016-02-11 20:40:31.111 [INFO] 6 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping end\n2016-02-11 20:40:31.205 [INFO] 6 WebApiRequestLogging.RequestLogDecorator: Request id: 91444099-72ad-488f-99d6-ab201f20531e Request /api/ping took 463 ms\n\n\n\n\nAs we can see that even if we started and ended the request on two different threads, we still have the same request identifier.\n\n\nHappy logging!!", 
            "title": "Web Api Request Logging"
        }, 
        {
            "location": "/webapirequestlogging/#web-api-request-logging", 
            "text": "This post is going to show you how to use  LightInject  to enable logging in a  Web Api  application. We are going to look into how to preserve contextual information associated with the incoming request so that this information can be used for logging purposes. All this goodness is going to end up in a simple  console application  that shows how all the pieces fit together.", 
            "title": "Web Api Request Logging"
        }, 
        {
            "location": "/webapirequestlogging/#logging", 
            "text": "Since logging is a cross cutting concern and is to be found scattered all around in our application, it makes sense to create an abstraction so that we don't create a direct dependency on a particular logging framework. This abstraction is something that we should own rather than relying on third part abstraction such as  Common Logging . Believe me, that is going to cause us nothing but pain as we would have to deal with different versions of a third party abstraction. Own you own abstraction!  We start of with a simple interface that is going to be used for logging.  public interface ILog\n{      \n    void Info(string message);\n\n    void Debug(string message);\n\n    void Error(string message, Exception exception = null);\n}  This is the interface that we will be injection into controllers, services or any other class that requires logging.  The actual implementation of this interface looks like this  public class Log : ILog\n{\n    private readonly Action string  logDebug;\n    private readonly Action string, Exception  logError;\n    private readonly Action string  logInfo;\n\n    public Log(Action string  logInfo, Action string  logDebug, Action string, Exception  logError)\n    {\n        this.logInfo = logInfo;\n        this.logDebug = logDebug;\n        this.logError = logError;\n    }\n\n    public void Info(string message)\n    {\n        logInfo(message);\n    }\n\n    public void Debug(string message)\n    {\n        logDebug(message);\n    }\n\n    public void Error(string message, Exception exception = null)\n    {\n        logError(message, exception);\n    }\n}  The  Log  class is not tied to a specific logging framework and it just takes a set of action delegates that represents the three logging levels supported by our abstraction.  To help us create a  Log  instance, we have this nice little interface.  public interface ILogFactory\n{\n    ILog GetLogger(Type type);\n}  And since we are going to be using  Log4Net  in this sample application, we have an implementation called  Log4NetLogFactory .  public class Log4NetLogFactory : ILogFactory\n{\n    public Log4NetLogFactory()\n    {\n        XmlConfigurator.Configure();           \n    }\n\n    public ILog GetLogger(Type type)\n    {            \n        var logger = LogManager.GetLogger(type);            \n        return new Log(logger.Info, logger.Debug, logger.Error);\n    }\n}   Note: This is the ONLY place where we actually reference Log4Net.", 
            "title": "Logging"
        }, 
        {
            "location": "/webapirequestlogging/#composition-root", 
            "text": "This application has two composition roots ( ICompositionRoot ), one that registers the core services ( CompositionRoot  )and one that registers services related to  Web Api  ( WebApiCompositionRoot ).   public class CompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {            \n        serviceRegistry.Register ILogFactory, Log4NetLogFactory (new PerContainerLifetime());\n        serviceRegistry.Register Type, ILog ((factory, type) =  factory.GetInstance ILogFactory ().GetLogger(type));\n        serviceRegistry.RegisterConstructorDependency(\n            (factory, info) =  factory.GetInstance Type, ILog (info.Member.DeclaringType));            \n    }\n}  The first service that we register is the  ILogFactory  that is responsible for creating an  ILog  instance based on a given type.  Next, we register the  ILog  service with a factory delegate that calls into the already registered  ILogFactory  service  Finally we tell the container using the  RegisterConstructorDependency  method that whenever it sees an  ILog  constructor dependency, it should provide an  ILog  instance based on the actual class that uses it.   public class WebApiCompositionRoot : ICompositionRoot\n{\n    public void Compose(IServiceRegistry serviceRegistry)\n    {\n        serviceRegistry.RegisterFrom CompositionRoot ();\n        serviceRegistry.RegisterApiControllers();\n    }\n}  The  WebApiCompositionRoot  registers core services in addition services related to  Web Api  which in this case means the controllers.", 
            "title": "Composition root"
        }, 
        {
            "location": "/webapirequestlogging/#controllers", 
            "text": "This application has just one controller named  PingController  that is simply going to return the text \"pong\".  public class PingController : ApiController\n{\n    private readonly ILog log;\n\n    public PingController(ILog log)\n    {\n        this.log = log;\n    }\n\n    public async Task IHttpActionResult  Get()\n    {\n        log.Info( Ping start );        \n        var result =  Ok( Pong );\n        log.Info( Ping end );\n        return result;\n    }\n}  As we can see we are injecting an  ILog  instance into the controller.  The  Startup  class for this application looks like this  public class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {\n        var configuration = new HttpConfiguration();\n        ConfigureHttpRoutes(configuration);\n        ConfigureMediaFormatter(configuration);\n\n        var container = new ServiceContainer();\n        container.RegisterFrom WebApiCompositionRoot ();            \n        container.EnableWebApi(configuration);           \n\n        app.UseWebApi(configuration);\n    }\n\n    private static void ConfigureMediaFormatter(HttpConfiguration configuration)\n    {\n        configuration.Formatters.Clear();\n        configuration.Formatters.Add(new JsonMediaTypeFormatter());\n    }\n\n    private static void ConfigureHttpRoutes(HttpConfiguration config)\n    {\n        config.Routes.MapHttpRoute(\n            name:  API Default ,\n            routeTemplate:  api/{controller}/{id} ,\n            defaults: new { id = RouteParameter.Optional });\n    }\n}  We can see all this in action just by running the application and hitting the service.  http://localhost:8080/api/ping  That should yield the following output in the console  2016-02-11 09:14:28.489 [INFO] 13 WebApiRequestLogging.PingController: Ping start\n2016-02-11 09:14:28.603 [INFO] 6 WebApiRequestLogging.PingController: Ping end  The  Log4Net  conversion pattern is like this (app.config)  conversionPattern value= %date{yyyy-MM-dd HH:mm:ss.fff} [%level] %thread %logger: %message%newline  /", 
            "title": "Controllers"
        }, 
        {
            "location": "/webapirequestlogging/#request-logging", 
            "text": "Sometimes it might be useful to log each request and maybe also the duration of the request.\nWe start off with a simple class ( OwinMiddleware ) that logs the duration of the request.  public class RequestLoggingMiddleware : OwinMiddleware\n{\n    private readonly ILog log;\n\n\n    public RequestLoggingMiddleware(OwinMiddleware next, ILog log) : base(next)\n    {\n        this.log = log;\n    }\n\n    public override async Task Invoke(IOwinContext context)\n    {            \n        await Measure(context).ConfigureAwait(false);;            \n    }\n\n    private async Task Measure(IOwinContext context)\n    {\n        var stopWath = Stopwatch.StartNew();\n        await Next.Invoke(context).ConfigureAwait(false);\n        stopWath.Stop();\n        log.Info($ Request {context.Request.Uri.PathAndQuery} took {stopWath.ElapsedMilliseconds} ms );\n    }\n}  In addition to this we need to add this new middleware to the  Owin  pipeline by adding this line to the  Startup  class.  app.Use RequestLoggingMiddleware (container.GetInstance Type, ILog (typeof (RequestLogDecorator)));   Note: The reason for using an  OwinMiddleware  instead of a  DelegatingHandler  is that the  OwinMiddleware  is not tied to  Web Api  in any way and can also be used in other frameworks that build upon the  Owin  stack.   Console output should now be  2016-02-11 13:07:48.466 [INFO] 11 WebApiRequestLogging.RequestLoggingMiddleware: Request /api/ping took 4 ms", 
            "title": "Request logging"
        }, 
        {
            "location": "/webapirequestlogging/#request-context", 
            "text": "In some situations it is useful to be able to associate all log entries with the current web request. This can be used for analyzing the log later in tools such as  Splunk  making it possible to see all log entries tied to any given request.  We could make the  IOwinContext  available in the container so that it could be injected into any class that requires information about the current request. This would however mean that these classes would have to know about the  IOwinContext  which might not be the best solution.   So let's start off simple by creating a class to hold the request identifier.  public class RequestContext\n{\n    public RequestContext(string id)\n    {\n        Id = id;\n    }\n\n    public string Id { get; } \n}  Next we create another middleware class to set the request identifier.  public class RequestContextMiddleware : OwinMiddleware\n{\n    private static readonly AsyncLocal RequestContext  RequestContextStorage = new AsyncLocal RequestContext ();\n\n    public RequestContextMiddleware(OwinMiddleware next) : base(next)\n    {\n    }\n\n    public override async Task Invoke(IOwinContext context)\n    {\n        RequestContextStorage.Value = new RequestContext(Guid.NewGuid().ToString());\n        await Next.Invoke(context);\n    }\n\n    public static RequestContext CurrentRequest =  RequestContextStorage.Value;\n}  The actual  RequestContext  uses the  AsyncLocal T  class to ensure that the context flows across await points.   The  AsyncLocal T  class is sort of the async version of  ThreadLocal T . You should NEVER rely on any kind of storage that is tied to a specific thread in an async environment.   Then we need to add the   RequestContextMiddleware  to the  Owin  pipeline.   app.Use RequestContextMiddleware ();  We now have way to access the current  RequestContext  through the  CurrentRequest  property. Sweet.  The only thing missing now is to register a function delegate that represent getting the current  RequestContext .  serviceRegistry.Register Func RequestContext (factory =  (() =  RequestContextMiddleware.CurrentRequest), new PerContainerLifetime());  The reason for injection a function delegate rather than just the  RequestContext  is that it might be used in services such as singletons that outlives the scope of a web request. By injecting the delegate that in turn gives us the  RequestContext , we can be sure that it is valid.", 
            "title": "Request Context"
        }, 
        {
            "location": "/webapirequestlogging/#decorators", 
            "text": "The requirement here is that if we are logging outside the context of a web request, such as in a unit test, we should just log without the request identifier, but if we log inside a web request (production or integration tests), we should add the request identifier to the message being logged. This is a perfect example of where we can apply the  Decorator Pattern . This allows us to add new functionality to a service without touching the original implementation. Did I hear \"open-closed principle\", anyone?  public class RequestLogDecorator : ILog\n{\n    private readonly ILog log;\n    private readonly Func RequestContext  getRequestContext;\n\n    public RequestLogDecorator(ILog log, Func RequestContext  getRequestContext)\n    {\n        this.log = log;\n        this.getRequestInfo = getRequestInfo;\n    }\n\n    public void Info(string message)\n    {\n        log.Info($ Request id: {getRequestContext().Id} {message} );\n    }\n\n    public void Debug(string message)\n    {\n        log.Debug($ Request id: {getRequestContext().Id} {message} );\n    }\n\n    public void Error(string message, Exception exception = null)\n    {\n        log.Error($ Request id: {getRequestContext().Id} {message} , exception);\n    }\n}  The decorator simply wraps the original  ILog  instance and applies the request identifier now returned from the  getRequestContext  delegate.  Don't you just love the new string interpolation features?    Note: If you are new to the decorator pattern, you can think of it as a  Russian Doll  where inside there is an exact identical doll wrapped by an outer doll.   Decorators are first-class citizens in  LightInject  and applying a decorator is just a one-liner in the  WepApiCompositionRoot  class.  serviceRegistry.Decorate ILog, RequestLogDecorator ();  Since we only apply the decorator in the  WepApiCompositionRoot  class it will only be used in the context of a web request.  To \"ensure\" that we don't always log on the same thread, we modify the  PingController  to inlude a delay.  public async Task IHttpActionResult  Get()\n{\n    log.Info( Ping start );\n\n    //ConfigureAwait(false) to say that we don't care about synchronization context.\n    await Task.Delay(100).ConfigureAwait(false);\n\n    // We are probably on another thread here\n    var result =  Ok( Pong );\n    log.Info( Ping end );\n    return result;\n}  Running the application and hitting the service should now yield the following output in the console  2016-02-11 20:40:30.994 [INFO] 12 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping start\n2016-02-11 20:40:31.111 [INFO] 6 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping end\n2016-02-11 20:40:31.205 [INFO] 6 WebApiRequestLogging.RequestLogDecorator: Request id: 91444099-72ad-488f-99d6-ab201f20531e Request /api/ping took 463 ms  As we can see that even if we started and ended the request on two different threads, we still have the same request identifier.  Happy logging!!", 
            "title": "Decorators"
        }, 
        {
            "location": "/transactions/", 
            "text": "Transaction Management\n\n\nIn this example we will be looking into how to deal with connections and transactions in a Web application. We will also discuss how to implement automatic rollback for integration tests. Our testing framework will be \nxUnit\n and together with \nLightInject\n this will hopefully turn into a very smooth testing experience.\n\n\nCommands and Queries\n\n\nThere are many ways to manage the interaction with the database and in this application we are going to implement something that has come to be known as the Command-Query pattern. The basic idea here is that we have one interface (\nIQueryHandler\n) for everything that comes out of the database and another interface (\nICommandHandler\n)for everything that goes into the database. The fact that we are dealing with the same set of interfaces for all interaction with the database means that we can very easily add features through the use of decorators. \n\n\nI am not going to cover everything with regards to command and queries here, but we will look into the interfaces we need to implement in order to shuffle data back and forth to the database.\n\n\nQueries\n\n\nThe following interface represents a class that can handle a query and return some kind of result.\n\n\npublic interface IQueryHandler\nin TQuery, TResult\n where TQuery : IQuery\nTResult\n\n{    \n    Task\nTResult\n HandleAsync(TQuery query);\n}\n\n\n\n\nYou might wonder about the \nIQuery\nTResult\n generic contraint. This is just an interface to give type inference a helping hand as we move on to the next interface. \n\n\nThe IQueryExecutor represents a class that can execute any query.\n\n\npublic interface IQueryExecutor\n{     \n    Task\nTResult\n ExecuteAsync\nTResult\n(IQuery\nTResult\n query);\n}\n\n\n\n\n\nThis is where the \nIQuery\nTResult\n generic contraint comes into play. Without the contraint we would have to specify the type of result when calling the \nExecuteAsync\n method.\n\n\nvar result = queryExecutor.ExecuteAsync\nSomeResultType\n(somequery);\n\n\n\n\nWith the query class \"implementing\" the IQuery\nTResult\n interface we can instead do this\n\n\nvar result = queryExecutor.ExecuteAsync(somequery);\n\n\n\n\nCommands\n\n\nThe following interface represents a class that can handle a command where the command can be any class.\n\n\n    public interface ICommandHandler\nin TCommand\n\n    {   \n        Task HandleAsync(TCommand command);\n    }\n\n\n\n\nWill be seeing examples of both queries and commands throughout this example.\n\n\nWhy not an ORM?\n\n\nThe best answer I can give you is that I have already been there and felt the pain that eventually comes sneaking upon you. A little at first and then more and more as things gets more complicated. In fact, I have actually written an inhouse ORM back in the days and writing a Linq provider for instance, certainly represents the Mount Everest of programming. Not because Linq is so hard, but because you have to deal with all the mismatches between the relational model and the object model. ORM's tries to free you from understanding SQL and it is such a failed abstraction. Eventually at some point, you find yourself in a situation where you are trying to come up with a Linq expression that generates the SQL you've already written. Bottom line, bite the bullet and learn SQL.\n\n\nCustomers\n\n\nThe first task is to create a query handler that can retrieve customers from the database based on their origin (country).\n\n\nThe SQL for ths look like this:\n\n\nSELECT \n    CustomerId,\n    CompanyName\nFROM \n    Customers\nWHERE \n    Country = @Country;\n\n\n\n\nWith the SQL in place, we are ready to implement the query handler.\n\n\npublic class CustomersQueryHandler : IQueryHandler\nCustomersQuery, Customer[]\n\n{\n    private readonly IDbConnection dbConnection;\n\n    public CustomersQueryHandler(IDbConnection dbConnection)\n    {\n        this.dbConnection = dbConnection;\n    }\n\n    public async Task\nCustomer[]\n HandleAsync(CustomersQuery query)\n    {\n        var result = await dbConnection.QueryAsync\nCustomerRow\n(SQL.CustomersByCountry, query);\n        return result.ToArray();\n    }\n}\n\n\n\n\n\n\nNote: Query and command handlers does not dictate that the data is stored in a relational database. It might just as well be stored in a file or another type of database such as a document database.\n\n\n\n\nThis query handler has just one dependency, the \nIDbConnection\n off which Dapper provides the \nQueryAsync\n method used to execute the query.\nThe query (\nCustomersQuery\n) looks like this\n\n\npublic class CustomersQuery : IQuery\nCustomer[]\n\n{\n    public string Country { get; set; }\n}\n\n\n\n\nPassing data through layers\n\n\nOkay, so we have our application that consists of different layers. \n\n\n\n\nData Access Layer (query and command handlers)\n\n\nBusiness Layer (services using the data access layer)\n\n\nPublic API (typically a REST based API using services from the business layer)\n\n\n\n\nData Access Layer\n\n\nThis is where we actually interact with the underlying data store which for most applications even today means a relational database. These databases store relational data and is not very well suited for storing objects and we should treat the database accordingly. Relational databases does not store objects, they store rows of data. \nThis is why we represent the result from \nDapper\n as a set of \nCustomerRow\n instances. \n\n\nBusiness Layer\n\n\nThis layer consists of the services that in turn will be using the data access layer. This is also the place to put any kind of business logic related to our services.  By mocking the data access layer we can test this functionality without hitting the database.\n\n\nAPI Layer\n\n\nThis is our public API which in this sample application is exposed as a RESTful API using Web Api.  Try to keep this layer as thin as possible. It should not deal with any kind of business logic, but it should for instance deal with making sure that we return the correct status codes according to REST best practices. \n\n\nSo should each layer have its own representation of the same data? \n\n\nMy answer is this: Be pragmatic about this. If the representation looks identical throughout the various layers, you might as well reuse the same class for different layers. Once you need to add JsonIgnore attributes to ensure that database-only properties does not get exposed in the Web API, you might consider another representation.  It is also likely that the representations for reading and writing will differ so there is a lot to consider her. There is also a performance penalty involved here since we need to constantly map the \"same\" data between layers. \n\n\nThere might also be situations where the service layer just acts as a pass-t through layer and it that case it might be just fine to use the query/command handlers directly in our controllers. \n\n\nComposition Root\n\n\nThe composition root is where we register services into the container.\n\n\nserviceRegistry.Register\nIQueryExecutor, QueryExecutor\n(new PerContainerLifetime());\n            serviceRegistry.RegisterQueryHandlers();\n\n            // We register the connection that it is disposed when the scope ends.\n            // The scope here is per web request.\n            serviceRegistry.Register(factory =\n CreateConnection(), new PerScopeLifetime());\n\n\n\n\nWe register the \nIDbConnection\n with the \nPerScopeLifetime\n which means that we get the same connection within a scope. The scope is usually per web request, but it can also be per test method as we will see in a minute.\n\nThis is actually a nice aspect of the scoping mechanism in LightInject. We tell a service to be per scope without providing any details about how the scope is started or ended.\n\n\nTesting query handlers\n\n\nBefore we dive into how to handle transactions, we are going to look at how to test our new query handler. \nLightInject\n provides an extension(\nLightInject.xUnit\n) that makes it possible to inject services into test methods.\n\n\n[Theory, Scoped, InjectData]\npublic async Task ShouldGetCustomersFromGermany(IQueryExecutor queryExecutor)\n{\n    var query = new CustomersQuery {Country = \nGermany\n};\n    var result = await queryExecutor.ExecuteAsync(query);\n    Assert.Equal(11, result.Length);\n}\n\n\n\n\nThe \nScoped\n attribute tells \nLightInject\n to wrap a scope around this test method. When the test method ends, the scope will end as well and that will in turn cause the \nIDbConnection\n to be disposed since that service is registered with the \nPerScopeLifetime\n. \n\n\nThe \nInjectData\n attribute simply tells \nLightInject\n to inject method arguments and can be thought off as a more sophisticated version of the \nInlineData\n attribute usually seen in \nxUnit\n theory based tests.\n\n\nLightInject.xUnit\n creates a container instance behind the scenes and uses that instance to inject services into the test methods. The default behavior in \nLightInject\n is to look for composition roots in the same assembly as the requested service. This is part of the fallback mechanism and means that we don't really need to explicitly configure the container in the test class although it is possible to do so by declaring the following static method.\n\n\npublic static void Configure(IServiceContainer container)\n{\n    container.RegisterFrom\nCompositionRoot\n();\n}\n\n\n\n\nWe can also use the \nInjectData\n attribute so specify inline data in addition to the service being injected.\n\n\n[Theory, Scoped]\n[InjectData(\nFrance\n, 11)]\n[InjectData(\nGermany\n, 11)]\n[InjectData(\nNorway\n, 1)]\npublic async Task ShouldGetCustomers(IQueryExecutor queryExecutor, string country, int expectedCount)\n{\n    var result = await queryExecutor.ExecuteAsync(new CustomersQuery() { Country = country });\n    Assert.Equal(expectedCount, result.Length);\n}\n\n\n\n\nTransactions\n\n\nWe are going to build upon the standard \nIDbConnection\n and \nIDbTransaction\n interfaces and provide a way to transparently apply transactions to command handlers. \n\n\nRequirements:\n \n\n\n\n\nTransactions should as short lived as possible.\n\n\nOnly one transaction per scope (web request)\n\n\nSupport sequential and nested execution of command handlers within the same transaction. \n\n\nAllow integration tests to roll back changes when the test ends.\n\n\n\n\nThis might seem like a tall order and the solution might look a bit controversial, but bare with me on this one and you will see that the implementation is actually quite simple. \n\n\nInserting data\n\n\nBefore we start to think about transactions, we need something that writes to the database. A simple insert should do the trick.\n\n\npublic class AddCustomerCommandHandler : ICommandHandler\nAddCustomerCommand\n\n{\n    private readonly IDbConnection dbConnection;\n\n    public AddCustomerCommandHandler(IDbConnection dbConnection)\n    {\n        this.dbConnection = dbConnection;\n    }\n\n    public async Task HandleAsync(AddCustomerCommand command)\n    {\n        await dbConnection.ExecuteAsync(SQL.InsertCustomer, command);\n    }\n}\n\n\n\n\nThe command handler takes care of executing a simple insert into the \nCustomers\n table using the \nExecuteAsync\n extension method provided by \nDapper\n. The  \nAddCustomerCommand\n  is just a simple POCO class that contains the data to be inserted.\n\n\npublic class AddCustomerCommand\n{\n    public string CustomerId { get; set; }\n\n    public string CompanyName { get; set; }\n}\n\n\n\n\nThe SQL looks like this:\n\n\nINSERT INTO Customers (CustomerId, CompanyName)\nVALUES (@CustomerId, @CompanyName)\n\n\n\n\nWrapping command handlers inside a transaction is just a matter of applying a simple decorator.\n\n\npublic class TransactionalCommandHandler\nTCommand\n : ICommandHandler\nTCommand\n\n{\n    private readonly IDbConnection dbConnection;\n    private readonly ICommandHandler\nTCommand\n commandHandler;\n\n    public TransactionalCommandHandler(IDbConnection dbConnection, ICommandHandler\nTCommand\n commandHandler)\n    {\n        this.dbConnection = dbConnection;\n        this.commandHandler = commandHandler;\n    }\n\n    public async Task HandleAsync(TCommand command)\n    {\n        using (var transaction = dbConnection.BeginTransaction())\n        {\n            await commandHandler.HandleAsync(command);\n            transaction.Commit();\n        }                \n    }\n}\n\n\n\n\nWith a single line of code in the composition root , we can now apply this decorator to all command handlers.\n\n\nserviceRegistry.Decorate(typeof(ICommandHandler\n), typeof(TransactionalCommandHandler\n));\n\n\n\n\nMultiple command handlers\n\n\nWithin a single scope (web request), we might have to execute more than one command handler, either sequentially or nested within each other. Since we now have an all-purpose decorator (\nTransactionalCommandHandler\n) that starts a new transaction before each underlying command handler, we need to make sure that only one transaction exists within the scope (web request).\n\n\nWe do this by implementing yet another decorator and this time a decorator for the \nIDbConnection\n interface.\n\n\npublic class ConnectionDecorator : IDbConnection\n{\n    private readonly IDbConnection dbConnection;\n    private readonly Lazy\nTransactionDecorator\n dbTransaction;        \n\n    public ConnectionDecorator(IDbConnection dbConnection)\n    {\n        this.dbConnection = dbConnection;\n        dbTransaction =\n            new Lazy\nTransactionDecorator\n(() =\n new TransactionDecorator(this, dbConnection.BeginTransaction()));\n    }\n\n    public void Dispose()\n    {\n        if (dbTransaction.IsValueCreated)\n        {\n            dbTransaction.Value.EndTransaction();\n        }\n        dbConnection.Dispose();\n    }\n\n    public IDbTransaction BeginTransaction()\n    {\n        dbTransaction.Value.IncrementTransactionCount();\n        return dbTransaction.Value;           \n    }\n\n    public IDbTransaction BeginTransaction(IsolationLevel il)\n    {\n        return BeginTransaction();\n    }\n\n    public void Close()\n    {\n        dbConnection.Close();\n    }\n\n    public void ChangeDatabase(string databaseName)\n    {\n        dbConnection.ChangeDatabase(databaseName);\n    }\n\n    public IDbCommand CreateCommand()\n    {\n        return dbConnection.CreateCommand();\n    }\n\n    public void Open()\n    {\n        dbConnection.Open();\n    }\n\n    public string ConnectionString\n    {\n        get { return dbConnection.ConnectionString; }\n        set { dbConnection.ConnectionString = value; }\n    }\n\n    public int ConnectionTimeout\n    {\n        get { return dbConnection.ConnectionTimeout; }\n    }\n\n    public string Database\n    {\n        get { return dbConnection.Database; }\n    }\n\n    public ConnectionState State\n    {\n        get { return dbConnection.State; }\n    }\n}\n\n\n\n\nMost of the methods and properties here just call into the underlying \nIDbConnection\n, except for the \nDispose\n and \nBeginTransaction\n methods that we will explain in a minute. \n\n\nBut first the code for the \nTransactionDecorator\n\n\npublic class TransactionDecorator : IDbTransaction\n{\n    private readonly IDbTransaction dbTransaction;\n    private int transactionCount;\n    private int commitCount;\n    public TransactionDecorator(IDbConnection dbConnection, IDbTransaction dbTransaction)\n    {\n        Connection = dbConnection;\n        this.dbTransaction = dbTransaction;\n    }\n\n    public void IncrementTransactionCount()\n    {\n        transactionCount++;\n    }\n\n    public void EndTransaction()\n    {\n        if (commitCount == transactionCount)\n        {\n            dbTransaction.Commit();\n        }\n        else\n        {\n            dbTransaction.Rollback();\n        }\n        dbTransaction.Dispose();\n    }\n\n    public void Dispose() { }\n\n    public virtual void Commit()\n    {\n        commitCount++;\n    }\n\n    public void Rollback() { }\n\n    public IDbConnection Connection { get; }\n\n    public IsolationLevel IsolationLevel =\n dbTransaction.IsolationLevel;\n}\n\n\n\n\nOkay, it is time to what is going on here. Hang on!\n\n\nWhen the \nBeginTransaction\n method is executed we create a new \nIDbTransaction\n  and wraps that transaction inside a \nTransactionDecorator\n. This transaction is provided through a \nLazy\nT\n that makes sure that we only create a single transaction no matter how many times the \nBeginTransaction\n method is called. \nWe also increment the \"\ntransactionCount\n\"  which basically reflects the number of calls to the \nBeginTransaction\n method.\n\n\nThe \"\ntransactionCount\n\" is then used inside the \nEndTransaction\n method to decide if we should perform a commit or a rollback.  The rule here is simple. In order for the transaction to be committed, we need the \ncommitCount\n to be equal to the \ntransactionCount\n. If they are not equal it means that a BeginTransaction was executed without a commit. In that case we do a rollback.\n\n\nThe \nEndTransaction\n method is called from the \nDispose\n method inside the the \nConnectionDecorator\n that first checks if we actually have a transaction at all. If so, we execute the \nEndTransaction\n method and finally disposes the underlying connection.\n\n\nThe connection is as mentioned before disposed when the scope (web request) ends because it is registered with the \nPerScopeLifetime\n.\n\n\nPlugging all this goodness into our code is a simple as \n\n\nserviceRegistry.Decorate\nIDbConnection, ConnectionDecorator\n();\n\n\n\n\nWe can now execute nested command handlers as well as command handlers sequentially and still have them operate within the same transaction that either gets committed or rolled back when the connection is disposed.\n\n\nAutomatic rollback\n\n\nIntegration tests that writes to the database should perform a rollback when the test ends. This is now just a matter of adding another decorator that simply executes a rollback rather than a commit.\n\n\npublic class RollbackCommandHandler\nTCommand\n : ICommandHandler\nTCommand\n\n{\n    private readonly IDbConnection dbConnection;\n    private readonly ICommandHandler\nTCommand\n commandHandler;\n\n    public RollbackCommandHandler(IDbConnection dbConnection, ICommandHandler\nTCommand\n commandHandler)\n    {\n        this.dbConnection = dbConnection;\n        this.commandHandler = commandHandler;\n    }\n\n    public async Task HandleAsync(TCommand command)\n    {\n        using (var transaction = dbConnection.BeginTransaction())\n        {\n            await commandHandler.HandleAsync(command);\n            transaction.Rollback();\n        }\n    }\n}\n\n\n\n\nThis decorator only lives in the test project and we can apply the decorator by implementing a static \nConfigure\n method in the test class.\n\n\npublic static void Configure(IServiceContainer container)\n{\n    container.RegisterFrom\nCompositionRoot\n();\n    container.Decorate(typeof(ICommandHandler\n), typeof(RollbackCommandHandler\n));\n}\n\n\n\n\nWe can now finally write a test that verifies that a new customer has been written to the database.\n\n\n[Theory, Scoped, InjectData]\npublic async Task ShouldAddCustomer(ICommandExecutor commandExecutor, IQueryExecutor queryExecutor)\n{\n    await commandExecutor.ExecuteAsync(new AddCustomerCommand {CustomerId = \nAAPL\n, CompanyName = \nApple Inc\n});\n    var newCustomer = await queryExecutor.ExecuteAsync(new CustomerQuery {CustomerId = \nAAPL\n});\n    Assert.Equal(\nApple Inc\n, newCustomer.CompanyName);\n}\n\n\n\n\nSince the transaction is not ended until the test ends, we can still query the database for the newly inserted customer and verify that is was inserted.\n\n\nTesting Controllers\n\n\nTesting the public API in a Web API application means testing the controllers and by using the \nMicrosoft.Owin.Testing\n package we can create an in-memory server that lets us test our Owin based web application end to end. \n\n\nLets just quickly take a look at the controller we are going to test.\n\n\npublic class CustomersController : ApiController\n{\n    private readonly IQueryExecutor queryExecutor;        \n\n    public CustomersController(IQueryExecutor queryExecutor)\n    {\n        this.queryExecutor = queryExecutor;            \n    }\n\n    public async Task\nIHttpActionResult\n Get(string country)\n    {            \n        var customers = await queryExecutor.ExecuteAsync(new CustomersQuery {Country = country});            \n        return Ok(customers);\n    }\n}\n\n\n\n\nA typical test for this controller would look like this.\n\n\n[Fact]\npublic async Task ShouldGetCustomersUsingTestServer()\n{\n    using (var server = TestServer.Create\nStartup\n())\n    {\n        HttpClient client = server.HttpClient;\n        HttpResponseMessage response = await client.GetAsync(\napi/customers?country=Germany\n);\n        string content = await response.Content.ReadAsStringAsync();\n        Customer[] customers = JsonConvert.DeserializeObject\nCustomer[]\n(content);\n        Assert.Equal(11, customers.Length);\n    }\n}\n\n\n\n\nLet's create an extension method to help us shorten this code a bit.\n\n\npublic static class HttpClientExtensions\n{\n    public static async Task\nResponse\nTResult\n GetAsync\nTResult\n(this HttpClient client, string requestUri)\n    {\n\n        var responseMessage = await client.GetAsync(requestUri).ConfigureAwait(false);\n        Response\nTResult\n response = new Response\nTResult\n() {Message = responseMessage};\n        if (responseMessage.IsSuccessStatusCode)\n        {\n            var content = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);\n            response.Value = JsonConvert.DeserializeObject\nTResult\n(content);\n        }\n        return response;\n    }\n}\n\n\n\n\nThis extension method returns the response as a Response\nT\n that contains the \nHttpResponseMessage\n and the typed result object. This means that we can do asserts on the actual result in addition to data related to the request such as the \nHttpStatusCode\n.\n\n\n[Fact]\npublic async Task ShouldGetCustomersUsingExtensionMethod()\n{\n    using (var server = TestServer.Create\nStartup\n())\n    {\n        HttpClient client = server.HttpClient;\n        var response = await client.GetAsync\nCustomer[]\n(\napi/customers?country=Germany\n);\n        Assert.Equal(11, response.Value.Length);\n    }\n}\n\n\n\n\nThe nice thing about the \nTestServer\n is that it allows us to pass the \nStartup\n class to be used for the test. This means that we can pass a startup class that might be specific to the test.  The startup class for this application looks like this.\n\n\npublic class Startup\n{\n    public Startup()\n    {\n        Container = new ServiceContainer();            \n    }\n\n    public void Configuration(IAppBuilder app)\n    {\n        var config = new HttpConfiguration();\n        Configure(Container);\n        ConfigureMediaFormatter(config);\n        ConfigureHttpRoutes(config);\n        Container.RegisterApiControllers();\n        Container.EnableWebApi(config);\n        app.UseWebApi(config);\n    }\n\n    private static void ConfigureMediaFormatter(HttpConfiguration configuration)\n    {\n        configuration.Formatters.Clear();\n        configuration.Formatters.Add(new JsonMediaTypeFormatter());\n    }\n\n    private static void ConfigureHttpRoutes(HttpConfiguration config)\n    {\n        config.Routes.MapHttpRoute(\n            name: \nAPI Default\n,\n            routeTemplate: \napi/{controller}/{id}\n,\n            defaults: new { id = RouteParameter.Optional });\n    }\n\n    public virtual void Configure(IServiceContainer serviceContainer)\n    {\n        serviceContainer.RegisterFrom\nCompositionRoot\n();        \n    }\n\n    public IServiceContainer Container { get; }         \n}\n\n\n\n\nThe thing to notice here is that we have a virtual \nConfigure\n method that makes it possible to inherit from this class in a test project and override the way we configure the container.  We also expose the container used by Web Api so that we can get access to it in an inherited startup class.\n\n\nThe next class is a base class for testing controllers that makes it possible to specify the startup class type as a generic argument to the class itself.\n\n\npublic abstract class ControllerTestBase\nTStartup\n where TStartup : Startup, new()\n{\n    public static void Configure(IServiceContainer container)\n    {\n        var startup = new TStartup();\n        container.Register(factory =\n TestServer.Create(builder =\n startup.Configuration(builder)), new PerScopeLifetime());\n        container.Register(CreateHttpClient);\n    }\n\n    private static HttpClient CreateHttpClient(IServiceFactory container)\n    {\n        var testServer = container.GetInstance\nTestServer\n();\n        var httpClient = new HttpClient(testServer.Handler);\n        httpClient.BaseAddress = testServer.BaseAddress;\n        return httpClient;\n    }\n}\n\n\n\n\nThis base class now makes it possible to specify the startup class and it also allows us to inject the \nHttpClient\n instance. \n\n\npublic class ControllerTests : ControllerTestBase\nStartup\n\n{\n    [Theory, Scoped, InjectData]\n    public async Task ShouldGetCustomersUsingInjectedClient(HttpClient client)\n    {\n        var response = await client.GetAsync\nCustomer[]\n(\napi/customers?country=Germany\n);\n        Assert.Equal(11, response.Value.Length);\n    }\n}\n\n\n\n\nBeing good REST citizens, we should also make sure that we return the correct status code along with the content. Say now that we want to test that the service returns 204-NoContent if no customers are found for the given country. \nWe could do this by making sure that we have the appropriate  test data in the database or we could mock the \nIQueryExecutor\n and have it return an empty list without even touching the database.\n\n\nBy extending the \nHttpClient\n we can really simplify the way to mock services used in the test.\n\n\npublic class TestClient : HttpClient\n{\n    private readonly IServiceRegistry serviceRegistry;\n\n    public TestClient(IServiceRegistry serviceRegistry, HttpMessageHandler handler) : base(handler)\n    {\n        this.serviceRegistry = serviceRegistry;\n    }\n\n    public Mock\nTService\n Mock\nTService\n() where TService:class \n    {\n        var mock = new Mock\nTService\n();\n\n        serviceRegistry.Override(registration =\n registration.ServiceType == typeof(TService),\n            (factory, registration) =\n CreateMockRegistration(mock));\n\n        return mock;\n    }\n\n    private static ServiceRegistration CreateMockRegistration\nTService\n(Mock\nTService\n mock) where TService:class\n    {\n        return new ServiceRegistration() {ServiceType = typeof(TService), Value = mock.Object };\n    }\n}\n\n\n\n\nThis class basically replaces the existing \nIQueryExecutor\n registration with a mock instance and makes it possible to mock services very easily.\n\n\n[Theory, Scoped, InjectData]\npublic async Task ShouldReturnNoContent(TestClient client)\n{\n    var mock = client.Mock\nIQueryExecutor\n();\n    mock.Setup(m =\n m.ExecuteAsync(It.IsAny\nIQuery\nCustomer[]\n())).ReturnsAsync(new Customer[] {});\n\n    var response = await client.GetAsync\nCustomer[]\n(\napi/customers?country=Germany\n);\n\n    Assert.Equal(HttpStatusCode.NoContent, response.Message.StatusCode);\n}", 
            "title": "Transactions and Testing"
        }, 
        {
            "location": "/transactions/#transaction-management", 
            "text": "In this example we will be looking into how to deal with connections and transactions in a Web application. We will also discuss how to implement automatic rollback for integration tests. Our testing framework will be  xUnit  and together with  LightInject  this will hopefully turn into a very smooth testing experience.", 
            "title": "Transaction Management"
        }, 
        {
            "location": "/transactions/#commands-and-queries", 
            "text": "There are many ways to manage the interaction with the database and in this application we are going to implement something that has come to be known as the Command-Query pattern. The basic idea here is that we have one interface ( IQueryHandler ) for everything that comes out of the database and another interface ( ICommandHandler )for everything that goes into the database. The fact that we are dealing with the same set of interfaces for all interaction with the database means that we can very easily add features through the use of decorators.   I am not going to cover everything with regards to command and queries here, but we will look into the interfaces we need to implement in order to shuffle data back and forth to the database.", 
            "title": "Commands and Queries"
        }, 
        {
            "location": "/transactions/#queries", 
            "text": "The following interface represents a class that can handle a query and return some kind of result.  public interface IQueryHandler in TQuery, TResult  where TQuery : IQuery TResult \n{    \n    Task TResult  HandleAsync(TQuery query);\n}  You might wonder about the  IQuery TResult  generic contraint. This is just an interface to give type inference a helping hand as we move on to the next interface.   The IQueryExecutor represents a class that can execute any query.  public interface IQueryExecutor\n{     \n    Task TResult  ExecuteAsync TResult (IQuery TResult  query);\n}  This is where the  IQuery TResult  generic contraint comes into play. Without the contraint we would have to specify the type of result when calling the  ExecuteAsync  method.  var result = queryExecutor.ExecuteAsync SomeResultType (somequery);  With the query class \"implementing\" the IQuery TResult  interface we can instead do this  var result = queryExecutor.ExecuteAsync(somequery);", 
            "title": "Queries"
        }, 
        {
            "location": "/transactions/#commands", 
            "text": "The following interface represents a class that can handle a command where the command can be any class.      public interface ICommandHandler in TCommand \n    {   \n        Task HandleAsync(TCommand command);\n    }  Will be seeing examples of both queries and commands throughout this example.", 
            "title": "Commands"
        }, 
        {
            "location": "/transactions/#why-not-an-orm", 
            "text": "The best answer I can give you is that I have already been there and felt the pain that eventually comes sneaking upon you. A little at first and then more and more as things gets more complicated. In fact, I have actually written an inhouse ORM back in the days and writing a Linq provider for instance, certainly represents the Mount Everest of programming. Not because Linq is so hard, but because you have to deal with all the mismatches between the relational model and the object model. ORM's tries to free you from understanding SQL and it is such a failed abstraction. Eventually at some point, you find yourself in a situation where you are trying to come up with a Linq expression that generates the SQL you've already written. Bottom line, bite the bullet and learn SQL.", 
            "title": "Why not an ORM?"
        }, 
        {
            "location": "/transactions/#customers", 
            "text": "The first task is to create a query handler that can retrieve customers from the database based on their origin (country).  The SQL for ths look like this:  SELECT \n    CustomerId,\n    CompanyName\nFROM \n    Customers\nWHERE \n    Country = @Country;  With the SQL in place, we are ready to implement the query handler.  public class CustomersQueryHandler : IQueryHandler CustomersQuery, Customer[] \n{\n    private readonly IDbConnection dbConnection;\n\n    public CustomersQueryHandler(IDbConnection dbConnection)\n    {\n        this.dbConnection = dbConnection;\n    }\n\n    public async Task Customer[]  HandleAsync(CustomersQuery query)\n    {\n        var result = await dbConnection.QueryAsync CustomerRow (SQL.CustomersByCountry, query);\n        return result.ToArray();\n    }\n}   Note: Query and command handlers does not dictate that the data is stored in a relational database. It might just as well be stored in a file or another type of database such as a document database.   This query handler has just one dependency, the  IDbConnection  off which Dapper provides the  QueryAsync  method used to execute the query.\nThe query ( CustomersQuery ) looks like this  public class CustomersQuery : IQuery Customer[] \n{\n    public string Country { get; set; }\n}", 
            "title": "Customers"
        }, 
        {
            "location": "/transactions/#passing-data-through-layers", 
            "text": "Okay, so we have our application that consists of different layers.    Data Access Layer (query and command handlers)  Business Layer (services using the data access layer)  Public API (typically a REST based API using services from the business layer)", 
            "title": "Passing data through layers"
        }, 
        {
            "location": "/transactions/#data-access-layer", 
            "text": "This is where we actually interact with the underlying data store which for most applications even today means a relational database. These databases store relational data and is not very well suited for storing objects and we should treat the database accordingly. Relational databases does not store objects, they store rows of data. \nThis is why we represent the result from  Dapper  as a set of  CustomerRow  instances.", 
            "title": "Data Access Layer"
        }, 
        {
            "location": "/transactions/#business-layer", 
            "text": "This layer consists of the services that in turn will be using the data access layer. This is also the place to put any kind of business logic related to our services.  By mocking the data access layer we can test this functionality without hitting the database.", 
            "title": "Business Layer"
        }, 
        {
            "location": "/transactions/#api-layer", 
            "text": "This is our public API which in this sample application is exposed as a RESTful API using Web Api.  Try to keep this layer as thin as possible. It should not deal with any kind of business logic, but it should for instance deal with making sure that we return the correct status codes according to REST best practices.   So should each layer have its own representation of the same data?   My answer is this: Be pragmatic about this. If the representation looks identical throughout the various layers, you might as well reuse the same class for different layers. Once you need to add JsonIgnore attributes to ensure that database-only properties does not get exposed in the Web API, you might consider another representation.  It is also likely that the representations for reading and writing will differ so there is a lot to consider her. There is also a performance penalty involved here since we need to constantly map the \"same\" data between layers.   There might also be situations where the service layer just acts as a pass-t through layer and it that case it might be just fine to use the query/command handlers directly in our controllers.", 
            "title": "API Layer"
        }, 
        {
            "location": "/transactions/#composition-root", 
            "text": "The composition root is where we register services into the container.  serviceRegistry.Register IQueryExecutor, QueryExecutor (new PerContainerLifetime());\n            serviceRegistry.RegisterQueryHandlers();\n\n            // We register the connection that it is disposed when the scope ends.\n            // The scope here is per web request.\n            serviceRegistry.Register(factory =  CreateConnection(), new PerScopeLifetime());  We register the  IDbConnection  with the  PerScopeLifetime  which means that we get the same connection within a scope. The scope is usually per web request, but it can also be per test method as we will see in a minute. \nThis is actually a nice aspect of the scoping mechanism in LightInject. We tell a service to be per scope without providing any details about how the scope is started or ended.", 
            "title": "Composition Root"
        }, 
        {
            "location": "/transactions/#testing-query-handlers", 
            "text": "Before we dive into how to handle transactions, we are going to look at how to test our new query handler.  LightInject  provides an extension( LightInject.xUnit ) that makes it possible to inject services into test methods.  [Theory, Scoped, InjectData]\npublic async Task ShouldGetCustomersFromGermany(IQueryExecutor queryExecutor)\n{\n    var query = new CustomersQuery {Country =  Germany };\n    var result = await queryExecutor.ExecuteAsync(query);\n    Assert.Equal(11, result.Length);\n}  The  Scoped  attribute tells  LightInject  to wrap a scope around this test method. When the test method ends, the scope will end as well and that will in turn cause the  IDbConnection  to be disposed since that service is registered with the  PerScopeLifetime .   The  InjectData  attribute simply tells  LightInject  to inject method arguments and can be thought off as a more sophisticated version of the  InlineData  attribute usually seen in  xUnit  theory based tests.  LightInject.xUnit  creates a container instance behind the scenes and uses that instance to inject services into the test methods. The default behavior in  LightInject  is to look for composition roots in the same assembly as the requested service. This is part of the fallback mechanism and means that we don't really need to explicitly configure the container in the test class although it is possible to do so by declaring the following static method.  public static void Configure(IServiceContainer container)\n{\n    container.RegisterFrom CompositionRoot ();\n}  We can also use the  InjectData  attribute so specify inline data in addition to the service being injected.  [Theory, Scoped]\n[InjectData( France , 11)]\n[InjectData( Germany , 11)]\n[InjectData( Norway , 1)]\npublic async Task ShouldGetCustomers(IQueryExecutor queryExecutor, string country, int expectedCount)\n{\n    var result = await queryExecutor.ExecuteAsync(new CustomersQuery() { Country = country });\n    Assert.Equal(expectedCount, result.Length);\n}", 
            "title": "Testing query handlers"
        }, 
        {
            "location": "/transactions/#transactions", 
            "text": "We are going to build upon the standard  IDbConnection  and  IDbTransaction  interfaces and provide a way to transparently apply transactions to command handlers.   Requirements:     Transactions should as short lived as possible.  Only one transaction per scope (web request)  Support sequential and nested execution of command handlers within the same transaction.   Allow integration tests to roll back changes when the test ends.   This might seem like a tall order and the solution might look a bit controversial, but bare with me on this one and you will see that the implementation is actually quite simple.", 
            "title": "Transactions"
        }, 
        {
            "location": "/transactions/#inserting-data", 
            "text": "Before we start to think about transactions, we need something that writes to the database. A simple insert should do the trick.  public class AddCustomerCommandHandler : ICommandHandler AddCustomerCommand \n{\n    private readonly IDbConnection dbConnection;\n\n    public AddCustomerCommandHandler(IDbConnection dbConnection)\n    {\n        this.dbConnection = dbConnection;\n    }\n\n    public async Task HandleAsync(AddCustomerCommand command)\n    {\n        await dbConnection.ExecuteAsync(SQL.InsertCustomer, command);\n    }\n}  The command handler takes care of executing a simple insert into the  Customers  table using the  ExecuteAsync  extension method provided by  Dapper . The   AddCustomerCommand   is just a simple POCO class that contains the data to be inserted.  public class AddCustomerCommand\n{\n    public string CustomerId { get; set; }\n\n    public string CompanyName { get; set; }\n}  The SQL looks like this:  INSERT INTO Customers (CustomerId, CompanyName)\nVALUES (@CustomerId, @CompanyName)  Wrapping command handlers inside a transaction is just a matter of applying a simple decorator.  public class TransactionalCommandHandler TCommand  : ICommandHandler TCommand \n{\n    private readonly IDbConnection dbConnection;\n    private readonly ICommandHandler TCommand  commandHandler;\n\n    public TransactionalCommandHandler(IDbConnection dbConnection, ICommandHandler TCommand  commandHandler)\n    {\n        this.dbConnection = dbConnection;\n        this.commandHandler = commandHandler;\n    }\n\n    public async Task HandleAsync(TCommand command)\n    {\n        using (var transaction = dbConnection.BeginTransaction())\n        {\n            await commandHandler.HandleAsync(command);\n            transaction.Commit();\n        }                \n    }\n}  With a single line of code in the composition root , we can now apply this decorator to all command handlers.  serviceRegistry.Decorate(typeof(ICommandHandler ), typeof(TransactionalCommandHandler ));", 
            "title": "Inserting data"
        }, 
        {
            "location": "/transactions/#multiple-command-handlers", 
            "text": "Within a single scope (web request), we might have to execute more than one command handler, either sequentially or nested within each other. Since we now have an all-purpose decorator ( TransactionalCommandHandler ) that starts a new transaction before each underlying command handler, we need to make sure that only one transaction exists within the scope (web request).  We do this by implementing yet another decorator and this time a decorator for the  IDbConnection  interface.  public class ConnectionDecorator : IDbConnection\n{\n    private readonly IDbConnection dbConnection;\n    private readonly Lazy TransactionDecorator  dbTransaction;        \n\n    public ConnectionDecorator(IDbConnection dbConnection)\n    {\n        this.dbConnection = dbConnection;\n        dbTransaction =\n            new Lazy TransactionDecorator (() =  new TransactionDecorator(this, dbConnection.BeginTransaction()));\n    }\n\n    public void Dispose()\n    {\n        if (dbTransaction.IsValueCreated)\n        {\n            dbTransaction.Value.EndTransaction();\n        }\n        dbConnection.Dispose();\n    }\n\n    public IDbTransaction BeginTransaction()\n    {\n        dbTransaction.Value.IncrementTransactionCount();\n        return dbTransaction.Value;           \n    }\n\n    public IDbTransaction BeginTransaction(IsolationLevel il)\n    {\n        return BeginTransaction();\n    }\n\n    public void Close()\n    {\n        dbConnection.Close();\n    }\n\n    public void ChangeDatabase(string databaseName)\n    {\n        dbConnection.ChangeDatabase(databaseName);\n    }\n\n    public IDbCommand CreateCommand()\n    {\n        return dbConnection.CreateCommand();\n    }\n\n    public void Open()\n    {\n        dbConnection.Open();\n    }\n\n    public string ConnectionString\n    {\n        get { return dbConnection.ConnectionString; }\n        set { dbConnection.ConnectionString = value; }\n    }\n\n    public int ConnectionTimeout\n    {\n        get { return dbConnection.ConnectionTimeout; }\n    }\n\n    public string Database\n    {\n        get { return dbConnection.Database; }\n    }\n\n    public ConnectionState State\n    {\n        get { return dbConnection.State; }\n    }\n}  Most of the methods and properties here just call into the underlying  IDbConnection , except for the  Dispose  and  BeginTransaction  methods that we will explain in a minute.   But first the code for the  TransactionDecorator  public class TransactionDecorator : IDbTransaction\n{\n    private readonly IDbTransaction dbTransaction;\n    private int transactionCount;\n    private int commitCount;\n    public TransactionDecorator(IDbConnection dbConnection, IDbTransaction dbTransaction)\n    {\n        Connection = dbConnection;\n        this.dbTransaction = dbTransaction;\n    }\n\n    public void IncrementTransactionCount()\n    {\n        transactionCount++;\n    }\n\n    public void EndTransaction()\n    {\n        if (commitCount == transactionCount)\n        {\n            dbTransaction.Commit();\n        }\n        else\n        {\n            dbTransaction.Rollback();\n        }\n        dbTransaction.Dispose();\n    }\n\n    public void Dispose() { }\n\n    public virtual void Commit()\n    {\n        commitCount++;\n    }\n\n    public void Rollback() { }\n\n    public IDbConnection Connection { get; }\n\n    public IsolationLevel IsolationLevel =  dbTransaction.IsolationLevel;\n}  Okay, it is time to what is going on here. Hang on!  When the  BeginTransaction  method is executed we create a new  IDbTransaction   and wraps that transaction inside a  TransactionDecorator . This transaction is provided through a  Lazy T  that makes sure that we only create a single transaction no matter how many times the  BeginTransaction  method is called. \nWe also increment the \" transactionCount \"  which basically reflects the number of calls to the  BeginTransaction  method.  The \" transactionCount \" is then used inside the  EndTransaction  method to decide if we should perform a commit or a rollback.  The rule here is simple. In order for the transaction to be committed, we need the  commitCount  to be equal to the  transactionCount . If they are not equal it means that a BeginTransaction was executed without a commit. In that case we do a rollback.  The  EndTransaction  method is called from the  Dispose  method inside the the  ConnectionDecorator  that first checks if we actually have a transaction at all. If so, we execute the  EndTransaction  method and finally disposes the underlying connection.  The connection is as mentioned before disposed when the scope (web request) ends because it is registered with the  PerScopeLifetime .  Plugging all this goodness into our code is a simple as   serviceRegistry.Decorate IDbConnection, ConnectionDecorator ();  We can now execute nested command handlers as well as command handlers sequentially and still have them operate within the same transaction that either gets committed or rolled back when the connection is disposed.", 
            "title": "Multiple command handlers"
        }, 
        {
            "location": "/transactions/#automatic-rollback", 
            "text": "Integration tests that writes to the database should perform a rollback when the test ends. This is now just a matter of adding another decorator that simply executes a rollback rather than a commit.  public class RollbackCommandHandler TCommand  : ICommandHandler TCommand \n{\n    private readonly IDbConnection dbConnection;\n    private readonly ICommandHandler TCommand  commandHandler;\n\n    public RollbackCommandHandler(IDbConnection dbConnection, ICommandHandler TCommand  commandHandler)\n    {\n        this.dbConnection = dbConnection;\n        this.commandHandler = commandHandler;\n    }\n\n    public async Task HandleAsync(TCommand command)\n    {\n        using (var transaction = dbConnection.BeginTransaction())\n        {\n            await commandHandler.HandleAsync(command);\n            transaction.Rollback();\n        }\n    }\n}  This decorator only lives in the test project and we can apply the decorator by implementing a static  Configure  method in the test class.  public static void Configure(IServiceContainer container)\n{\n    container.RegisterFrom CompositionRoot ();\n    container.Decorate(typeof(ICommandHandler ), typeof(RollbackCommandHandler ));\n}  We can now finally write a test that verifies that a new customer has been written to the database.  [Theory, Scoped, InjectData]\npublic async Task ShouldAddCustomer(ICommandExecutor commandExecutor, IQueryExecutor queryExecutor)\n{\n    await commandExecutor.ExecuteAsync(new AddCustomerCommand {CustomerId =  AAPL , CompanyName =  Apple Inc });\n    var newCustomer = await queryExecutor.ExecuteAsync(new CustomerQuery {CustomerId =  AAPL });\n    Assert.Equal( Apple Inc , newCustomer.CompanyName);\n}  Since the transaction is not ended until the test ends, we can still query the database for the newly inserted customer and verify that is was inserted.", 
            "title": "Automatic rollback"
        }, 
        {
            "location": "/transactions/#testing-controllers", 
            "text": "Testing the public API in a Web API application means testing the controllers and by using the  Microsoft.Owin.Testing  package we can create an in-memory server that lets us test our Owin based web application end to end.   Lets just quickly take a look at the controller we are going to test.  public class CustomersController : ApiController\n{\n    private readonly IQueryExecutor queryExecutor;        \n\n    public CustomersController(IQueryExecutor queryExecutor)\n    {\n        this.queryExecutor = queryExecutor;            \n    }\n\n    public async Task IHttpActionResult  Get(string country)\n    {            \n        var customers = await queryExecutor.ExecuteAsync(new CustomersQuery {Country = country});            \n        return Ok(customers);\n    }\n}  A typical test for this controller would look like this.  [Fact]\npublic async Task ShouldGetCustomersUsingTestServer()\n{\n    using (var server = TestServer.Create Startup ())\n    {\n        HttpClient client = server.HttpClient;\n        HttpResponseMessage response = await client.GetAsync( api/customers?country=Germany );\n        string content = await response.Content.ReadAsStringAsync();\n        Customer[] customers = JsonConvert.DeserializeObject Customer[] (content);\n        Assert.Equal(11, customers.Length);\n    }\n}  Let's create an extension method to help us shorten this code a bit.  public static class HttpClientExtensions\n{\n    public static async Task Response TResult  GetAsync TResult (this HttpClient client, string requestUri)\n    {\n\n        var responseMessage = await client.GetAsync(requestUri).ConfigureAwait(false);\n        Response TResult  response = new Response TResult () {Message = responseMessage};\n        if (responseMessage.IsSuccessStatusCode)\n        {\n            var content = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);\n            response.Value = JsonConvert.DeserializeObject TResult (content);\n        }\n        return response;\n    }\n}  This extension method returns the response as a Response T  that contains the  HttpResponseMessage  and the typed result object. This means that we can do asserts on the actual result in addition to data related to the request such as the  HttpStatusCode .  [Fact]\npublic async Task ShouldGetCustomersUsingExtensionMethod()\n{\n    using (var server = TestServer.Create Startup ())\n    {\n        HttpClient client = server.HttpClient;\n        var response = await client.GetAsync Customer[] ( api/customers?country=Germany );\n        Assert.Equal(11, response.Value.Length);\n    }\n}  The nice thing about the  TestServer  is that it allows us to pass the  Startup  class to be used for the test. This means that we can pass a startup class that might be specific to the test.  The startup class for this application looks like this.  public class Startup\n{\n    public Startup()\n    {\n        Container = new ServiceContainer();            \n    }\n\n    public void Configuration(IAppBuilder app)\n    {\n        var config = new HttpConfiguration();\n        Configure(Container);\n        ConfigureMediaFormatter(config);\n        ConfigureHttpRoutes(config);\n        Container.RegisterApiControllers();\n        Container.EnableWebApi(config);\n        app.UseWebApi(config);\n    }\n\n    private static void ConfigureMediaFormatter(HttpConfiguration configuration)\n    {\n        configuration.Formatters.Clear();\n        configuration.Formatters.Add(new JsonMediaTypeFormatter());\n    }\n\n    private static void ConfigureHttpRoutes(HttpConfiguration config)\n    {\n        config.Routes.MapHttpRoute(\n            name:  API Default ,\n            routeTemplate:  api/{controller}/{id} ,\n            defaults: new { id = RouteParameter.Optional });\n    }\n\n    public virtual void Configure(IServiceContainer serviceContainer)\n    {\n        serviceContainer.RegisterFrom CompositionRoot ();        \n    }\n\n    public IServiceContainer Container { get; }         \n}  The thing to notice here is that we have a virtual  Configure  method that makes it possible to inherit from this class in a test project and override the way we configure the container.  We also expose the container used by Web Api so that we can get access to it in an inherited startup class.  The next class is a base class for testing controllers that makes it possible to specify the startup class type as a generic argument to the class itself.  public abstract class ControllerTestBase TStartup  where TStartup : Startup, new()\n{\n    public static void Configure(IServiceContainer container)\n    {\n        var startup = new TStartup();\n        container.Register(factory =  TestServer.Create(builder =  startup.Configuration(builder)), new PerScopeLifetime());\n        container.Register(CreateHttpClient);\n    }\n\n    private static HttpClient CreateHttpClient(IServiceFactory container)\n    {\n        var testServer = container.GetInstance TestServer ();\n        var httpClient = new HttpClient(testServer.Handler);\n        httpClient.BaseAddress = testServer.BaseAddress;\n        return httpClient;\n    }\n}  This base class now makes it possible to specify the startup class and it also allows us to inject the  HttpClient  instance.   public class ControllerTests : ControllerTestBase Startup \n{\n    [Theory, Scoped, InjectData]\n    public async Task ShouldGetCustomersUsingInjectedClient(HttpClient client)\n    {\n        var response = await client.GetAsync Customer[] ( api/customers?country=Germany );\n        Assert.Equal(11, response.Value.Length);\n    }\n}  Being good REST citizens, we should also make sure that we return the correct status code along with the content. Say now that we want to test that the service returns 204-NoContent if no customers are found for the given country. \nWe could do this by making sure that we have the appropriate  test data in the database or we could mock the  IQueryExecutor  and have it return an empty list without even touching the database.  By extending the  HttpClient  we can really simplify the way to mock services used in the test.  public class TestClient : HttpClient\n{\n    private readonly IServiceRegistry serviceRegistry;\n\n    public TestClient(IServiceRegistry serviceRegistry, HttpMessageHandler handler) : base(handler)\n    {\n        this.serviceRegistry = serviceRegistry;\n    }\n\n    public Mock TService  Mock TService () where TService:class \n    {\n        var mock = new Mock TService ();\n\n        serviceRegistry.Override(registration =  registration.ServiceType == typeof(TService),\n            (factory, registration) =  CreateMockRegistration(mock));\n\n        return mock;\n    }\n\n    private static ServiceRegistration CreateMockRegistration TService (Mock TService  mock) where TService:class\n    {\n        return new ServiceRegistration() {ServiceType = typeof(TService), Value = mock.Object };\n    }\n}  This class basically replaces the existing  IQueryExecutor  registration with a mock instance and makes it possible to mock services very easily.  [Theory, Scoped, InjectData]\npublic async Task ShouldReturnNoContent(TestClient client)\n{\n    var mock = client.Mock IQueryExecutor ();\n    mock.Setup(m =  m.ExecuteAsync(It.IsAny IQuery Customer[] ())).ReturnsAsync(new Customer[] {});\n\n    var response = await client.GetAsync Customer[] ( api/customers?country=Germany );\n\n    Assert.Equal(HttpStatusCode.NoContent, response.Message.StatusCode);\n}", 
            "title": "Testing Controllers"
        }, 
        {
            "location": "/lightmock/", 
            "text": "LightMock\n\n\nLightMock\n is a simple mocking library that can be used on platforms that does not allow dynamic code generation.    \n\n\nInstalling\n\n\n\n   \n\n         \nPM\n Install-Package LightMock \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightMock\n in the target project.\n\n\nThe \nLightMock\n library is a a portable class library that makes it possible to use this across all platforms including iOS and Android.\n\n\nCreating a mock object\n\n\nEven though the mock objects are created manually, they can be reused in many scenarios.\n\n\nAs an an example we will use this simple interface.\n\n\npublic interface IFoo\n{\n    void Execute(string value);\n    string Execute();        \n}\n\n\n\nThe mock object implementing this interface looks like this\n\n\npublic class FooMock : IFoo\n{\n    private readonly IInvocationContext\nIFoo\n context;\n\n    public FooMock(IInvocationContext\nIFoo\n context)\n    {\n        this.context = context;\n    }\n\n    public void Execute(string value)\n    {\n        context.Invoke(f =\n f.Execute(value));\n    }\n\n    public string Execute()\n    {\n        return context.Invoke(f =\n f.Execute());\n    }        \n}\n\n\n\n\n\nNote: Only mocked methods needs to be implemented. Other methods that does not get invoked during testing can just throw a NotImplementedException.\n\n\n\n\nAssertions\n\n\nThe \nAssert\n method is used to verify that the given method has been executed the expected number of times using the expected arguments.   \n\n\n//Arrange\nvar mockContext = new MockContext\nIFoo\n();\nvar fooMock = new FooMock(mockContext);\n\n//Act\nfooMock.Execute(\"SomeValue\");\n\n//Assert\nmockContext.Assert(f =\n f.Execute(\"SomeValue\"));\n\n\n\n\n\nNote: Not specifying the expected number of invocations, means at least once.\n\n\n\n\nIf we don't care about the actual argument value, we can use a special class called \nThe\n.\n\n\nvar mockContext = new MockContext\nIFoo\n();\nvar fooMock = new FooMock(mockContext);\n\nfooMock.Execute(\"SomeValue\");\n\nmockContext.Assert(f =\n f.Execute(The\nstring\n.IsAnyValue), Invoked.Once);\n\n\n\nWe call also use this class to perform custom verification.\n\n\nvar mockContext = new MockContext\nIFoo\n();\nvar fooMock = new FooMock(mockContext);\n\nfooMock.Execute(\"SomeValue\");\n\nmockContext.Assert(f =\n f.Execute(The\nstring\n.Is(s =\n s.StartsWith(\"Some\"))), Invoked.Once);\n\n\n\nArrangements\n\n\nWe can use arrangements to add behavior to the mock object.\n\n\nFor instance we can set up the mock object to return a value.\n\n\nvar mockContext = new MockContext\nIFoo\n();\nvar fooMock = new FooMock(mockContext);\nmockContext.Arrange(f =\n f.Execute()).Returns(\"SomeValue\");\n\nvar result = fooMock.Execute();\n\nAssert.AreEqual(\"SomeValue\", result);\n\n\n\nThrow an exception\n\n\nvar mockContext = new MockContext\nIFoo\n();\nvar fooMock = new FooMock(mockContext);\nmockContext.Arrange(f =\n f.Execute(\"SomeValue\")).Throws\nInvalidOperationException\n();\nfooMock.Execute(\"SomeValue\");\n\n\n\nThrow an exception using a exception factory.\n\n\nvar mockContext = new MockContext\nIFoo\n();\nvar fooMock = new FooMock(mockContext);\nmockContext.Arrange(f =\n f.Execute(\"SomeValue\")).Throws(() =\n new InvalidOperationException());\nfooMock.Execute(\"SomeValue\");\n\n\n\nExecute a callback\n\n\nvar mockContext = new MockContext\nIFoo\n();\nvar fooMock = new FooMock(mockContext);\nstring callBackResult = null;\nmockContext.Arrange(f =\n f.Execute(The\nstring\n.IsAnyValue))\n    .Callback\nstring\n(s =\n callBackResult = s);\n\nfooMock.Execute(\"SomeValue\");\n\nAssert.AreEqual(\"SomeValue\", callBackResult);", 
            "title": "LightMock"
        }, 
        {
            "location": "/lightmock/#lightmock", 
            "text": "LightMock  is a simple mocking library that can be used on platforms that does not allow dynamic code generation.", 
            "title": "LightMock"
        }, 
        {
            "location": "/lightmock/#installing", 
            "text": "PM  Install-Package LightMock  \n      This adds a reference to the  LightMock  in the target project.  The  LightMock  library is a a portable class library that makes it possible to use this across all platforms including iOS and Android.", 
            "title": "Installing"
        }, 
        {
            "location": "/lightmock/#creating-a-mock-object", 
            "text": "Even though the mock objects are created manually, they can be reused in many scenarios.  As an an example we will use this simple interface.  public interface IFoo\n{\n    void Execute(string value);\n    string Execute();        \n}  The mock object implementing this interface looks like this  public class FooMock : IFoo\n{\n    private readonly IInvocationContext IFoo  context;\n\n    public FooMock(IInvocationContext IFoo  context)\n    {\n        this.context = context;\n    }\n\n    public void Execute(string value)\n    {\n        context.Invoke(f =  f.Execute(value));\n    }\n\n    public string Execute()\n    {\n        return context.Invoke(f =  f.Execute());\n    }        \n}   Note: Only mocked methods needs to be implemented. Other methods that does not get invoked during testing can just throw a NotImplementedException.", 
            "title": "Creating a mock object"
        }, 
        {
            "location": "/lightmock/#assertions", 
            "text": "The  Assert  method is used to verify that the given method has been executed the expected number of times using the expected arguments.     //Arrange\nvar mockContext = new MockContext IFoo ();\nvar fooMock = new FooMock(mockContext);\n\n//Act\nfooMock.Execute(\"SomeValue\");\n\n//Assert\nmockContext.Assert(f =  f.Execute(\"SomeValue\"));   Note: Not specifying the expected number of invocations, means at least once.   If we don't care about the actual argument value, we can use a special class called  The .  var mockContext = new MockContext IFoo ();\nvar fooMock = new FooMock(mockContext);\n\nfooMock.Execute(\"SomeValue\");\n\nmockContext.Assert(f =  f.Execute(The string .IsAnyValue), Invoked.Once);  We call also use this class to perform custom verification.  var mockContext = new MockContext IFoo ();\nvar fooMock = new FooMock(mockContext);\n\nfooMock.Execute(\"SomeValue\");\n\nmockContext.Assert(f =  f.Execute(The string .Is(s =  s.StartsWith(\"Some\"))), Invoked.Once);", 
            "title": "Assertions"
        }, 
        {
            "location": "/lightmock/#arrangements", 
            "text": "We can use arrangements to add behavior to the mock object.  For instance we can set up the mock object to return a value.  var mockContext = new MockContext IFoo ();\nvar fooMock = new FooMock(mockContext);\nmockContext.Arrange(f =  f.Execute()).Returns(\"SomeValue\");\n\nvar result = fooMock.Execute();\n\nAssert.AreEqual(\"SomeValue\", result);  Throw an exception  var mockContext = new MockContext IFoo ();\nvar fooMock = new FooMock(mockContext);\nmockContext.Arrange(f =  f.Execute(\"SomeValue\")).Throws InvalidOperationException ();\nfooMock.Execute(\"SomeValue\");  Throw an exception using a exception factory.  var mockContext = new MockContext IFoo ();\nvar fooMock = new FooMock(mockContext);\nmockContext.Arrange(f =  f.Execute(\"SomeValue\")).Throws(() =  new InvalidOperationException());\nfooMock.Execute(\"SomeValue\");  Execute a callback  var mockContext = new MockContext IFoo ();\nvar fooMock = new FooMock(mockContext);\nstring callBackResult = null;\nmockContext.Arrange(f =  f.Execute(The string .IsAnyValue))\n    .Callback string (s =  callBackResult = s);\n\nfooMock.Execute(\"SomeValue\");\n\nAssert.AreEqual(\"SomeValue\", callBackResult);", 
            "title": "Arrangements"
        }, 
        {
            "location": "/licence/", 
            "text": "The MIT License (MIT)\n\n\nCopyright (c) 2014 bernhard.richter@gmail.com\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "Licence"
        }, 
        {
            "location": "/licence/#the-mit-license-mit", 
            "text": "Copyright (c) 2014 bernhard.richter@gmail.com  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "The MIT License (MIT)"
        }
    ]
}