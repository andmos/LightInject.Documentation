{
    "docs": [
        {
            "location": "/", 
            "text": "Installing\n\n\nLightInject\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject\n\n   \n\n\n\n\n\nThis adds a reference to the LightInject.dll in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Source \n\n   \n\n\n\n\n\nThis will install a single file (LightInject.cs) into the current project.\n\n\nCreating a container\n\n\nvar container = new LightInject.ServiceContainer();\n\n\n\nThe container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope.\n\n\nDefault services\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar instance = container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(instance, typeof(Foo));\n\n\n\nNamed services\n\n\npublic class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instance = container.GetInstance\nIFoo\n(\"AnotherFoo\");\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));\n\n\n\nIf only one named registration exists, \nLightInject\n is capable of resolving this as the default service.\n\n\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instance = container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));\n\n\n\nUnresolved services\n\n\nLightInject can resolve services that are not registered with the container using the \nRegisterFallback\n method.\n\n\nvar container = new ServiceContainer();\ncontainer.RegisterFallback((type, s) =\n true, request =\n new Foo());\nvar foo = container.GetInstance\nIFoo\n();\n\n\n\nThe first argument to the \nRegisterFallback\n method makes it possible to possible to decide if the service can be \"late-resolved\".\nThe second argument is a \nServiceRequest\n instance that provides the requested service type and service name.\n\n\nIEnumerable\nT\n\n\nWhen we register multiple services with the same service type, \nLightInject\n is capable of resolving these services as an  \nIEnumerable\nT\n.\n\n\npublic class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instances = container.GetInstance\nIEnumerable\nIFoo\n()\nAssert.AreEqual(2, instances.Count());\n\n\n\nAlternatively using the \nGetAllInstances\n method.\n\n\nvar instances = container.GetAllInstances\nIFoo\n();\nAssert.AreEqual(2, instances.Count());\n\n\n\nIn addition, \nLightInject\n supports the following \nIEnumerable\nT\n sub-types. \n\n\n\n\nArray\n\n\nICollection\nT\n\n\nIList\nT\n\n\nIReadOnlyCollection\nT\n (Net 4.5 and Windows Runtime);\n\n\nIReadOnlyList\nT\n (Net 4.5 and Windows Runtime)\n\n\n\n\nBy default, \nLightInject\n will resolve all services that are compatible with the requested element type.\n\n\ncontainer.Register\nFoo\n();\ncontainer.Register\nDerivedFoo\n();\nvar instances = container.GetAllInstances\nFoo\n();\nAssert.AreEqual(2, instances.Count());\n\n\n\nThis behavior can be overridden using the \nEnableVariance\n container option.\n\n\nvar container = new ServiceContainer(new ContainerOptions { EnableVariance = false });\ncontainer.Register\nFoo\n();\ncontainer.Register\nDerivedFoo\n();\nvar instances = container.GetAllInstances\nFoo\n();\nAssert.AreEqual(1, instances.Count());\n\n\n\nValues\n\n\nRegisters the value as a constant.\n\n\ncontainer.RegisterInstance\nstring\n(\"SomeValue\");\nvar value = container.GetInstance\nstring\n();\nAssert.AreEqual(\"SomeValue, value);\n\n\n\nLifetime\n\n\nThe default behavior in \nLightInject\n is to treat all objects as transients unless otherwise specified.\n\n\ncontainer.Register\nIFoo,Foo\n();\nvar firstInstance = container.GetInstance\nIFoo\n();\nvar secondInstance = container.GetInstance\nIFoo\n();\nAssert.AreNotSame(firstInstance, secondInstance);\n\n\n\nPerScopeLifetime\n\n\nEnsures that only one instance of a given service can exists within a scope.\nThe container will call the \nDispose\n method on all disposable objects created within the scope.\n\n\ncontainer.Register\nIFoo,Foo\n(new PerScopeLifetime());\nusing(container.BeginScope())\n{\n\n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreSame(firstInstance, secondInstance);\n}\n\n\n\nNote:\n \nAn \nInvalidOperationException\n is thrown if a service registered with the \nPerScopeLifetime\n is requested outside the scope.\n\n\nPerContainerLifetime\n\n\nEnsures that only one instance of a given service can exist within the container.\nThe container will call the Dispose method on all disposable objects when the container itself is disposed.\n\n\nusing(container = new ServiceContainer())\n{\n    container.Register\nIFoo,Foo\n(new PerContainerLifetime());   \n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreSame(firstInstance, secondInstance);\n}\n\n\n\nPerRequestLifeTime\n\n\nA new instance is created for each request and the container calls \nDispose\n when the scope ends.\nThis lifetime is used when the conrete class implements \nIDisposable\n.\n\n\ncontainer.Register\nIFoo,Foo\n(new PerRequestLifeTime());\nusing(container.BeginScope())\n{       \n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreNotSame(firstInstance, secondInstance);\n}\n\n\n\n\n\nNote:\n \nAn \nInvalidOperationException\n is thrown if a service registered with the \nPerRequestLifeTime\n is requested outside the scope.\n\n\n\n\nCustom lifetime\n\n\nA custom lifetime is created by implementing the \nILifetime\n interface\n\n\ninternal interface ILifetime\n{\n    object GetInstance(Func\nobject\n instanceFactory, Scope currentScope);        \n}\n\n\n\nThe following example shows to create a custom lifetime that ensures only one instance per thread.\n\n\npublic class PerThreadLifetime : ILifetime\n{\n    ThreadLocal\nobject\n instances = new ThreadLocal\nobject\n();\n\n    public object GetInstance(Func\nobject\n instanceFactory, Scope currentScope)\n    {\n        if (instances.value == null)\n        {\n            instances.value = instanceFactory();\n        }\n        return instances.value;\n    }\n}\n\n\n\nThat is all it takes to create a custom lifetime, but what about disposable services?\n\n\npublic class PerThreadLifetime : ILifetime\n{\n    ThreadLocal\nobject\n instances = new ThreadLocal\nobject\n();\n\n    public object GetInstance(Func\nobject\n instanceFactory, Scope currentScope)\n    {           \n        if (instances.value == null)\n        {               \n            object instance = instanceFactory();                \n            IDisposable disposable = instance as IDisposable;               \n            if (disposable != null)\n            {\n                if (currentScope == null)\n                {\n                    throw new InvalidOperationException(\"Attempt to create an disposable object \n                                                        without a current scope.\")\n                }\n                currentScope.TrackInstance(disposable);\n            }\n\n            instances.value = instance;\n        }\n        return instance.value;\n    }\n}\n\n\n\nImportant\n\n\nA lifetime object controls the lifetime of a single service and can \nnever\n be shared for multiple service registrations.\n\n\nWrong\n\n\nILifetime lifetime = new PerContainerLifeTime();\ncontainer.Register\nIFoo,Foo\n(lifetime);\ncontainer.Register\nIBar,Bar\n(lifetime);\n\n\n\nRight\n\n\ncontainer.Register\nIFoo,Foo\n(new PerContainerLifeTime());\ncontainer.Register\nIBar,Bar\n(new PerContainerLifeTime());\n\n\n\nA lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations.\n\n\nAsync and Await\n\n\nBy default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread.\n\n\nWith the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread.\n\n\nTo illustrate this lets consider an example that is going to cause an instance to be resolved on another thread.\n\n\nWe start of by creating an interface that returns a \nTask\nIBar\n\n\npublic interface IAsyncFoo\n{\n    Task\nIBar\n GetBar();\n}\n\n\n\nNext we implement this interface in such a way that the \nIBar\n instance is requested on another thread.\n\n\npublic class AsyncFoo : IAsyncFoo\n{\n    private readonly Lazy\nIBar\n lazyBar;\n\n    public AsyncFoo(Lazy\nIBar\n lazyBar)\n    {\n        this.lazyBar = lazyBar;\n    }\n\n    public async Task\nIBar\n GetBar()\n    {\n        await Task.Delay(10);\n        return lazyBar.Value; \n--This code is executed on another thread (continuation).\n    }\n}\n\n\n\nThe we register the dependency (\nIBar\n) with the \nPerScopeLifetime\n that is going to cause the container to ask for the current scope so that the instance can be registered with that scope.\n\n\nvar container = new ServiceContainer();\ncontainer.Register\nIBar, Bar\n(new PerScopeLifetime());\ncontainer.Register\nIAsyncFoo, AsyncFoo\n();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance\nIAsyncFoo\n();\n    ExceptionAssert.Throws\nAggregateException\n(() =\n instance.GetBar().Wait());                \n}\n\n\n\nThis will throw an exception that states the following:\n\n\nAttempt to create a scoped instance without a current scope.\n\n\n\nThe reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread.\n\n\nTo deal with this issue, \nLightInject\n now supports scopes across the logical \nCallContext\n.  \n\n\nvar container = new ServiceContainer();\ncontainer.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider();\ncontainer.Register\nIBar, Bar\n(new PerScopeLifetime());\ncontainer.Register\nIAsyncFoo, AsyncFoo\n();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance\nIAsyncFoo\n();\n    var bar = instance.GetBar().Result;\n    Assert.IsInstanceOfType(bar, typeof(IBar));\n}\n\n\n\n\n\nNote that the \nPerLogicalCallContextScopeManagerProvider\n is only available when running under .Net 4.5.\nFor more information, please refer to the following \narticle\n by Stephen Cleary.\n\n\n\n\nDependencies\n\n\nConstructor Injection\n\n\npublic interface IFoo {}        \npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public Foo(IBar bar) \n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; } \n}\n\npublic class Bar : IBar {}\n\n\n\nImplicit service registration\n\n\nRegisters a service without specifying any information about how to resolve the constructor dependencies of the implementing type.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIBar, Bar\n();\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));\n\n\n\n\n\nNote: In the case where the implementing type(Foo) has more than one constructor, \nLightInject\n will choose the constructor with the most parameters. \n\n\n\n\nFor fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency.\n\n\ncontainer.RegisterConstructorDependency\nIBar\n((factory, parameterInfo) =\n new Bar());\n\n\n\nThis tells the container to inject a new \nBar\n instance whenever it sees an \nIBar\n constructor dependency.\n\n\nExplicit service registration\n\n\nRegisters a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies.\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nIFoo\n(factory =\n new Foo(factory.GetInstance\nIBar\n));\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.Bar);\n\n\n\nParameters\n\n\nParameters are used when we want to supply one or more values when the service is resolved.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((arg, factory) =\n new Foo(arg));\nvar foo = (Foo)container.GetInstance\nint, IFoo\n(42);\nAssert.AreEqual(42,foo.Value);\n\n\n\nWe can also do a combination of supplied values and dependencies.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value, IBar bar)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n    public IBar Bar { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value, factory.GetInstance\nIBar\n()));\nvar foo = (Foo)container.GetInstance\nint, IFoo\n();\nAssert.AreEqual(42, foo.Value);\nAssert.IsNotNull(foo.Bar);\n\n\n\nProperty Injection\n\n\npublic interface IFoo {}\n\npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public IBar Bar { get; set; }\n}\n\npublic class Bar : IBar {}\n\n\n\nImplicit service registration\n\n\nRegisters the service without specifying any information about how to resolve the property dependencies.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIBar, Bar\n();\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.bar);\n\n\n\n\n\nNote:\n \nLightInject\n* considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will \nNOT*\n throw an exception in the case of an unresolved property dependency.\n          \n\n\n\n\nFor fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency.\n\n\ncontainer.RegisterPropertyDependency\nIBar\n((factory, propertyInfo) =\n new Bar());\n\n\n\nThis tells the container to inject a new \nBar\n instance whenever it sees an \nIBar\n property dependency.\n\n\nExplicit service registration\n\n\nRegisters a service by providing explicit information about how to create the service instance and how to resolve the property dependencies.\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nIFoo\n(factory =\n new Foo() {Bar = factory.GetInstance\nIBar\n()}) \nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.bar);\n\n\n\nProperty injection on existing instances.\n\n\nIn the cases where we don't control the creation of the service instance, \nLightInject\n can inject property dependencies into an existing instance.\n\n\ncontainer.Register\nIBar, Bar\n();\nvar foo = new Foo();\ncontainer.InjectProperties(foo);\nAssert.IsNotNull(foo);\n\n\n\nInitializers\n\n\nUse the \nInitialize\n method to perform service instance initialization/post-processing.  \n\n\ncontainer.Register\nIFoo, FooWithPropertyDependency\n();\ncontainer.Initialize(registration =\n registration.ServiceType == typeof(IFoo), \n    (factory, instance) =\n ((FooWithPropertyDependency)instance).Bar = new Bar());\nvar foo = (FooWithProperyDependency)container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));\n\n\n\nAssembly Scanning\n\n\nLightInject is capable of registering services by looking at the types of a given assembly.\n\n\ncontainer.RegisterAssembly(typeof(IFoo).Assembly)\n\n\n\nTo filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type.\n\n\ncontainer.RegisterAssembly(typeof(IFoo).Assembly, (serviceType, implementingType) =\n serviceType.NameSpace == \"SomeNamespace\");\n\n\n\nIt is also possible to scan a set assembly files based on a search pattern.\n\n\ncontainer.RegisterAssembly(\"SomeAssemblyName*.dll\");\n\n\n\nComposition Root\n\n\nWhen \nLightInject\n scans an assembly it will look for an implementation of the \nICompositionRoot\n interface.   \n\n\npublic class SampleCompositionRoot : ICompositionRoot\n{               \n    public void Compose(IServiceRegistry serviceRegistry)\n    {     \n        serviceRegistry.Register(typeof(IFoo),typeof(Foo));\n    }\n}\n\n\n\nIf one or more implementations of the \nICompositionRoot\n interface is found, they will be created and executed.\n\n\n\n\nNote:\n \nAny other services contained within the target assembly that is not registered in the composition root, will \nNOT\n be registered.\n\n\n\n\nRather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a \nICompositionRoot\n, is that they can easily be reused in automated tests.   \n\n\nLazy Composition Roots\n\n\nLightInject\n is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading.\n\n\nIf an unregistered service is requested, \nLightInject\n will scan the assembly where this service is contained.  \n\n\nCompositionRootAttribute\n\n\nWhen an assembly is being scanned, \nLightInject\n will look for implementations of the \nICompositionRoot\n interface. For large assemblies that contains many type, this might be an expensive operation. The \nCompositionRootAttribute\n is an assembly level attribute that simply helps \nLightInject\n to locate the compostion root.\n\n\n[assembly: CompositionRootType(typeof(SampleCompositionRoot))]\n\n\n\nRegisterFrom\n\n\nAllows explicit execution of a composition root.\n\n\ncontainer.RegisterFrom\nSampleCompositionRoot\n();\n\n\n\nGenerics\n\n\npublic interface IFoo\nT\n {};\npublic class Foo\nT\n : IFoo\nT\n {};\n\n\n\nThe container creates the closed generic type based on the service request.\n\n\ncontainer.Register(typeof(IFoo\n), typeof(Foo\n));\nvar instance = container.GetInstance(typeof(IFoo\nint\n));\nAssert.IsInstanceOfType(instance, typeof(Foo\nint\n));\n\n\n\nConstraints\n\n\nLightInject\n enforces generic constrains  \n\n\nLazy\nT\n\n\nLightInject\n can resolve a service as an instance of \nLazy\nT\n when we want to postpone resolving the underlying service until it is needed.\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar lazyFoo = container.GetInstance\nLazy\nIFoo\n();\nAssert.IsNotNull(lazyFoo.Value);\n\n\n\nFunction Factories\n\n\nFunction factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the \nService Locator\n (anti)pattern.\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo,Foo\n();\nvar func = container.GetInstance\nFunc\nIFoo\n();\nvar foo = func();\nAssert.IsNotNull(foo);\n\n\n\n\n\nNote:\n \nA function factory is effectively a delegate that redirects back to the corresponding \nGetInstance\n method on the service container.\n\n\n\n\nNamed Factories\n\n\nThe container returns a function delegate that represents calling the \nGetInstance\n method with \"SomeFoo\" as the service name argument.\n\n\ncontainer.Register\nIFoo, Foo\n(\"SomeFoo\");\nvar func = container.GetInstance\nFunc\nIFoo\n(\"SomeFoo\");   \nvar foo = func();\nAssert.IsNotNull(foo);\n\n\n\nParameters\n\n\nFunction factories can also take parameters that will be used create the service instance.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));\nvar fooFactory = container.GetInstance\nFunc\nint, IFoo\n();\nvar foo = (Foo)fooFactory(42); \nAssert.AreEqual(foo.Value, 42);\n\n\n\n\n\nNote\n : \nThe service must be explicitly registered in order for the container to resolve it as a parameterized function factory.\n\n\n\n\nIDisposable\n\n\nThe only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable.\n\n\npublic interface IFoo : IDisposable {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar fooFactory = container.GetInstance\nFunc\nIFoo\n();\n\nusing(IFoo foo = fooFactory())\n{\n\n} \n--Instance is disposed here\n\n\n\n\n\nNote:\n \nAlthough this is common practice even in the \nBCL\n, this kind of interfaces are often referred to as \nleaky abstractions\n.\n\n\n\n\nTyped Factories\n\n\nA typed factory is a class that wraps the function factory that is used to create the underlying service instance.\nAs opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory.   \n\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nIFoo\n createFoo;\n\n    public FooFactory(Func\nIFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo()\n    {\n        return createFoo();\n    }\n}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFooFactory, FooFactory\n(new PerContainerLifetime());\nvar fooFactory = container.GetInstance\nIFooFactory\n();\nvar foo = fooFactory.GetFoo();\nAssert.IsNotNull(foo);\n\n\n\n\n\nNote:\n \nRegister typed factories with the \nPerContainerLifetime\n unless a compelling reason exists to choose a different lifetime.\n  \n\n\n\n\nParameters\n\n\nTypes factories can also wrap a parameterized function factory and allows us to pass arguments.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nint, IFoo\n createFoo;\n\n    public FooFactory(Func\nint, IFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));\ncontainer.Register\nIFooFactory, FooFactory\n(new PerContainerLifetime());\nvar typedFooFactory = container.GetInstance\nIFooFactory\n();\nvar foo = typedFooFactory.GetFoo(42);\nAssert.AreEqual(foo.Value, 42);\n\n\n\nIDisposable\n\n\nWorking with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction.\n\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n    void Release(IFoo foo);\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nIFoo\n createFoo;\n\n    public FooFactory(Func\nIFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n\n    public void Release(IFoo foo)\n    {\n        var disposable = foo as IDisposable;\n        if (disposable != null)\n        {\n            disposable.Dispose();\n        }\n    }\n}\n\n\n\nRecursive dependency detection\n\n\nA recursive dependency graph is when a service depends directly or indirectly on itself.\n\n\npublic class FooWithRecursiveDependency : IFoo\n{\n    public FooWithRecursiveDependency(IFoo foo)\n    {\n    }\n}\n\n\n\nThe following code will throw an \nInvalidOperationException\n stating that there are existing recursive dependencies. \n\n\ncontainer.Register(typeof(IFoo), typeof(FooWithRecursiveDependency));\ncontainer.GetInstance\nIFoo\n()\n\n\n\nInternals\n\n\nWhen running under the .Net platform, \nLightInject\n is capable of creating instances of classes that has the \ninternal\n modifier. \n\n\nThe only requirement is that the internal class exposes a public constructor.\n\n\ninternal class InternalFooWithPublicConstructor : IFoo\n{\n    public InternalFooWithPublicConstructor () {}\n}", 
            "title": "Home"
        }, 
        {
            "location": "/#installing", 
            "text": "LightInject  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject \n      This adds a reference to the LightInject.dll in the target project.  Source  \n    \n          PM  Install-Package LightInject.Source  \n      This will install a single file (LightInject.cs) into the current project.  Creating a container  var container = new LightInject.ServiceContainer();  The container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope.  Default services  public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar instance = container.GetInstance IFoo ();\nAssert.IsInstanceOfType(instance, typeof(Foo));  Named services  public class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}   container.Register IFoo, Foo ();\ncontainer.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instance = container.GetInstance IFoo (\"AnotherFoo\");\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));  If only one named registration exists,  LightInject  is capable of resolving this as the default service.  container.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instance = container.GetInstance IFoo ();\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));  Unresolved services  LightInject can resolve services that are not registered with the container using the  RegisterFallback  method.  var container = new ServiceContainer();\ncontainer.RegisterFallback((type, s) =  true, request =  new Foo());\nvar foo = container.GetInstance IFoo ();  The first argument to the  RegisterFallback  method makes it possible to possible to decide if the service can be \"late-resolved\".\nThe second argument is a  ServiceRequest  instance that provides the requested service type and service name.  IEnumerable T  When we register multiple services with the same service type,  LightInject  is capable of resolving these services as an   IEnumerable T .  public class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}   container.Register IFoo, Foo ();\ncontainer.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instances = container.GetInstance IEnumerable IFoo ()\nAssert.AreEqual(2, instances.Count());  Alternatively using the  GetAllInstances  method.  var instances = container.GetAllInstances IFoo ();\nAssert.AreEqual(2, instances.Count());  In addition,  LightInject  supports the following  IEnumerable T  sub-types.    Array  ICollection T  IList T  IReadOnlyCollection T  (Net 4.5 and Windows Runtime);  IReadOnlyList T  (Net 4.5 and Windows Runtime)   By default,  LightInject  will resolve all services that are compatible with the requested element type.  container.Register Foo ();\ncontainer.Register DerivedFoo ();\nvar instances = container.GetAllInstances Foo ();\nAssert.AreEqual(2, instances.Count());  This behavior can be overridden using the  EnableVariance  container option.  var container = new ServiceContainer(new ContainerOptions { EnableVariance = false });\ncontainer.Register Foo ();\ncontainer.Register DerivedFoo ();\nvar instances = container.GetAllInstances Foo ();\nAssert.AreEqual(1, instances.Count());  Values  Registers the value as a constant.  container.RegisterInstance string (\"SomeValue\");\nvar value = container.GetInstance string ();\nAssert.AreEqual(\"SomeValue, value);", 
            "title": "Installing"
        }, 
        {
            "location": "/#lifetime", 
            "text": "The default behavior in  LightInject  is to treat all objects as transients unless otherwise specified.  container.Register IFoo,Foo ();\nvar firstInstance = container.GetInstance IFoo ();\nvar secondInstance = container.GetInstance IFoo ();\nAssert.AreNotSame(firstInstance, secondInstance);  PerScopeLifetime  Ensures that only one instance of a given service can exists within a scope.\nThe container will call the  Dispose  method on all disposable objects created within the scope.  container.Register IFoo,Foo (new PerScopeLifetime());\nusing(container.BeginScope())\n{\n\n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreSame(firstInstance, secondInstance);\n}  Note:   An  InvalidOperationException  is thrown if a service registered with the  PerScopeLifetime  is requested outside the scope.  PerContainerLifetime  Ensures that only one instance of a given service can exist within the container.\nThe container will call the Dispose method on all disposable objects when the container itself is disposed.  using(container = new ServiceContainer())\n{\n    container.Register IFoo,Foo (new PerContainerLifetime());   \n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreSame(firstInstance, secondInstance);\n}  PerRequestLifeTime  A new instance is created for each request and the container calls  Dispose  when the scope ends.\nThis lifetime is used when the conrete class implements  IDisposable .  container.Register IFoo,Foo (new PerRequestLifeTime());\nusing(container.BeginScope())\n{       \n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreNotSame(firstInstance, secondInstance);\n}   Note:   An  InvalidOperationException  is thrown if a service registered with the  PerRequestLifeTime  is requested outside the scope.   Custom lifetime  A custom lifetime is created by implementing the  ILifetime  interface  internal interface ILifetime\n{\n    object GetInstance(Func object  instanceFactory, Scope currentScope);        \n}  The following example shows to create a custom lifetime that ensures only one instance per thread.  public class PerThreadLifetime : ILifetime\n{\n    ThreadLocal object  instances = new ThreadLocal object ();\n\n    public object GetInstance(Func object  instanceFactory, Scope currentScope)\n    {\n        if (instances.value == null)\n        {\n            instances.value = instanceFactory();\n        }\n        return instances.value;\n    }\n}  That is all it takes to create a custom lifetime, but what about disposable services?  public class PerThreadLifetime : ILifetime\n{\n    ThreadLocal object  instances = new ThreadLocal object ();\n\n    public object GetInstance(Func object  instanceFactory, Scope currentScope)\n    {           \n        if (instances.value == null)\n        {               \n            object instance = instanceFactory();                \n            IDisposable disposable = instance as IDisposable;               \n            if (disposable != null)\n            {\n                if (currentScope == null)\n                {\n                    throw new InvalidOperationException(\"Attempt to create an disposable object \n                                                        without a current scope.\")\n                }\n                currentScope.TrackInstance(disposable);\n            }\n\n            instances.value = instance;\n        }\n        return instance.value;\n    }\n}  Important  A lifetime object controls the lifetime of a single service and can  never  be shared for multiple service registrations.  Wrong  ILifetime lifetime = new PerContainerLifeTime();\ncontainer.Register IFoo,Foo (lifetime);\ncontainer.Register IBar,Bar (lifetime);  Right  container.Register IFoo,Foo (new PerContainerLifeTime());\ncontainer.Register IBar,Bar (new PerContainerLifeTime());  A lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations.  Async and Await  By default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread.  With the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread.  To illustrate this lets consider an example that is going to cause an instance to be resolved on another thread.  We start of by creating an interface that returns a  Task IBar  public interface IAsyncFoo\n{\n    Task IBar  GetBar();\n}  Next we implement this interface in such a way that the  IBar  instance is requested on another thread.  public class AsyncFoo : IAsyncFoo\n{\n    private readonly Lazy IBar  lazyBar;\n\n    public AsyncFoo(Lazy IBar  lazyBar)\n    {\n        this.lazyBar = lazyBar;\n    }\n\n    public async Task IBar  GetBar()\n    {\n        await Task.Delay(10);\n        return lazyBar.Value;  --This code is executed on another thread (continuation).\n    }\n}  The we register the dependency ( IBar ) with the  PerScopeLifetime  that is going to cause the container to ask for the current scope so that the instance can be registered with that scope.  var container = new ServiceContainer();\ncontainer.Register IBar, Bar (new PerScopeLifetime());\ncontainer.Register IAsyncFoo, AsyncFoo ();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance IAsyncFoo ();\n    ExceptionAssert.Throws AggregateException (() =  instance.GetBar().Wait());                \n}  This will throw an exception that states the following:  Attempt to create a scoped instance without a current scope.  The reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread.  To deal with this issue,  LightInject  now supports scopes across the logical  CallContext .    var container = new ServiceContainer();\ncontainer.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider();\ncontainer.Register IBar, Bar (new PerScopeLifetime());\ncontainer.Register IAsyncFoo, AsyncFoo ();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance IAsyncFoo ();\n    var bar = instance.GetBar().Result;\n    Assert.IsInstanceOfType(bar, typeof(IBar));\n}   Note that the  PerLogicalCallContextScopeManagerProvider  is only available when running under .Net 4.5.\nFor more information, please refer to the following  article  by Stephen Cleary.", 
            "title": "Lifetime"
        }, 
        {
            "location": "/#dependencies", 
            "text": "Constructor Injection  public interface IFoo {}        \npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public Foo(IBar bar) \n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; } \n}\n\npublic class Bar : IBar {}  Implicit service registration  Registers a service without specifying any information about how to resolve the constructor dependencies of the implementing type.  container.Register IFoo, Foo ();\ncontainer.Register IBar, Bar ();\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));   Note: In the case where the implementing type(Foo) has more than one constructor,  LightInject  will choose the constructor with the most parameters.    For fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency.  container.RegisterConstructorDependency IBar ((factory, parameterInfo) =  new Bar());  This tells the container to inject a new  Bar  instance whenever it sees an  IBar  constructor dependency.  Explicit service registration  Registers a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies.  container.Register IBar, Bar ();\ncontainer.Register IFoo (factory =  new Foo(factory.GetInstance IBar ));\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.Bar);  Parameters  Parameters are used when we want to supply one or more values when the service is resolved.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}   container.Register int, IFoo ((arg, factory) =  new Foo(arg));\nvar foo = (Foo)container.GetInstance int, IFoo (42);\nAssert.AreEqual(42,foo.Value);  We can also do a combination of supplied values and dependencies.  public class Foo : IFoo\n{\n    public Foo(int value, IBar bar)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n    public IBar Bar { get; private set; }\n}   container.Register IBar, Bar ();\ncontainer.Register int, IFoo ((factory, value) =  new Foo(value, factory.GetInstance IBar ()));\nvar foo = (Foo)container.GetInstance int, IFoo ();\nAssert.AreEqual(42, foo.Value);\nAssert.IsNotNull(foo.Bar);  Property Injection  public interface IFoo {}\n\npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public IBar Bar { get; set; }\n}\n\npublic class Bar : IBar {}  Implicit service registration  Registers the service without specifying any information about how to resolve the property dependencies.  container.Register IFoo, Foo ();\ncontainer.Register IBar, Bar ();\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.bar);   Note:   LightInject * considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will  NOT*  throw an exception in the case of an unresolved property dependency.              For fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency.  container.RegisterPropertyDependency IBar ((factory, propertyInfo) =  new Bar());  This tells the container to inject a new  Bar  instance whenever it sees an  IBar  property dependency.  Explicit service registration  Registers a service by providing explicit information about how to create the service instance and how to resolve the property dependencies.  container.Register IBar, Bar ();\ncontainer.Register IFoo (factory =  new Foo() {Bar = factory.GetInstance IBar ()}) \nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.bar);  Property injection on existing instances.  In the cases where we don't control the creation of the service instance,  LightInject  can inject property dependencies into an existing instance.  container.Register IBar, Bar ();\nvar foo = new Foo();\ncontainer.InjectProperties(foo);\nAssert.IsNotNull(foo);", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#initializers", 
            "text": "Use the  Initialize  method to perform service instance initialization/post-processing.    container.Register IFoo, FooWithPropertyDependency ();\ncontainer.Initialize(registration =  registration.ServiceType == typeof(IFoo), \n    (factory, instance) =  ((FooWithPropertyDependency)instance).Bar = new Bar());\nvar foo = (FooWithProperyDependency)container.GetInstance IFoo ();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));", 
            "title": "Initializers"
        }, 
        {
            "location": "/#assembly-scanning", 
            "text": "LightInject is capable of registering services by looking at the types of a given assembly.  container.RegisterAssembly(typeof(IFoo).Assembly)  To filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type.  container.RegisterAssembly(typeof(IFoo).Assembly, (serviceType, implementingType) =  serviceType.NameSpace == \"SomeNamespace\");  It is also possible to scan a set assembly files based on a search pattern.  container.RegisterAssembly(\"SomeAssemblyName*.dll\");", 
            "title": "Assembly Scanning"
        }, 
        {
            "location": "/#composition-root", 
            "text": "When  LightInject  scans an assembly it will look for an implementation of the  ICompositionRoot  interface.     public class SampleCompositionRoot : ICompositionRoot\n{               \n    public void Compose(IServiceRegistry serviceRegistry)\n    {     \n        serviceRegistry.Register(typeof(IFoo),typeof(Foo));\n    }\n}  If one or more implementations of the  ICompositionRoot  interface is found, they will be created and executed.   Note:   Any other services contained within the target assembly that is not registered in the composition root, will  NOT  be registered.   Rather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a  ICompositionRoot , is that they can easily be reused in automated tests.     Lazy Composition Roots  LightInject  is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading.  If an unregistered service is requested,  LightInject  will scan the assembly where this service is contained.    CompositionRootAttribute  When an assembly is being scanned,  LightInject  will look for implementations of the  ICompositionRoot  interface. For large assemblies that contains many type, this might be an expensive operation. The  CompositionRootAttribute  is an assembly level attribute that simply helps  LightInject  to locate the compostion root.  [assembly: CompositionRootType(typeof(SampleCompositionRoot))]  RegisterFrom  Allows explicit execution of a composition root.  container.RegisterFrom SampleCompositionRoot ();", 
            "title": "Composition Root"
        }, 
        {
            "location": "/#generics", 
            "text": "public interface IFoo T  {};\npublic class Foo T  : IFoo T  {};  The container creates the closed generic type based on the service request.  container.Register(typeof(IFoo ), typeof(Foo ));\nvar instance = container.GetInstance(typeof(IFoo int ));\nAssert.IsInstanceOfType(instance, typeof(Foo int ));  Constraints  LightInject  enforces generic constrains", 
            "title": "Generics"
        }, 
        {
            "location": "/#lazyt", 
            "text": "LightInject  can resolve a service as an instance of  Lazy T  when we want to postpone resolving the underlying service until it is needed.  public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar lazyFoo = container.GetInstance Lazy IFoo ();\nAssert.IsNotNull(lazyFoo.Value);", 
            "title": "Lazy&lt;T&gt;"
        }, 
        {
            "location": "/#function-factories", 
            "text": "Function factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the  Service Locator  (anti)pattern.  public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo,Foo ();\nvar func = container.GetInstance Func IFoo ();\nvar foo = func();\nAssert.IsNotNull(foo);   Note:   A function factory is effectively a delegate that redirects back to the corresponding  GetInstance  method on the service container.   Named Factories  The container returns a function delegate that represents calling the  GetInstance  method with \"SomeFoo\" as the service name argument.  container.Register IFoo, Foo (\"SomeFoo\");\nvar func = container.GetInstance Func IFoo (\"SomeFoo\");   \nvar foo = func();\nAssert.IsNotNull(foo);  Parameters  Function factories can also take parameters that will be used create the service instance.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}   container.Register int, IFoo ((factory, value) =  new Foo(value));\nvar fooFactory = container.GetInstance Func int, IFoo ();\nvar foo = (Foo)fooFactory(42); \nAssert.AreEqual(foo.Value, 42);   Note  :  The service must be explicitly registered in order for the container to resolve it as a parameterized function factory.   IDisposable  The only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable.  public interface IFoo : IDisposable {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar fooFactory = container.GetInstance Func IFoo ();\n\nusing(IFoo foo = fooFactory())\n{\n\n}  --Instance is disposed here   Note:   Although this is common practice even in the  BCL , this kind of interfaces are often referred to as  leaky abstractions .", 
            "title": "Function Factories"
        }, 
        {
            "location": "/#typed-factories", 
            "text": "A typed factory is a class that wraps the function factory that is used to create the underlying service instance.\nAs opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory.     public interface IFooFactory\n{\n    IFoo GetFoo();\n}   public class FooFactory : IFooFactory\n{\n    private Func IFoo  createFoo;\n\n    public FooFactory(Func IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo()\n    {\n        return createFoo();\n    }\n}   container.Register IFoo, Foo ();\ncontainer.Register IFooFactory, FooFactory (new PerContainerLifetime());\nvar fooFactory = container.GetInstance IFooFactory ();\nvar foo = fooFactory.GetFoo();\nAssert.IsNotNull(foo);   Note:   Register typed factories with the  PerContainerLifetime  unless a compelling reason exists to choose a different lifetime.      Parameters  Types factories can also wrap a parameterized function factory and allows us to pass arguments.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}   public class FooFactory : IFooFactory\n{\n    private Func int, IFoo  createFoo;\n\n    public FooFactory(Func int, IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n}   container.Register int, IFoo ((factory, value) =  new Foo(value));\ncontainer.Register IFooFactory, FooFactory (new PerContainerLifetime());\nvar typedFooFactory = container.GetInstance IFooFactory ();\nvar foo = typedFooFactory.GetFoo(42);\nAssert.AreEqual(foo.Value, 42);  IDisposable  Working with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction.  public interface IFooFactory\n{\n    IFoo GetFoo(int value);\n    void Release(IFoo foo);\n}   public class FooFactory : IFooFactory\n{\n    private Func IFoo  createFoo;\n\n    public FooFactory(Func IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n\n    public void Release(IFoo foo)\n    {\n        var disposable = foo as IDisposable;\n        if (disposable != null)\n        {\n            disposable.Dispose();\n        }\n    }\n}", 
            "title": "Typed Factories"
        }, 
        {
            "location": "/#recursive-dependency-detection", 
            "text": "A recursive dependency graph is when a service depends directly or indirectly on itself.  public class FooWithRecursiveDependency : IFoo\n{\n    public FooWithRecursiveDependency(IFoo foo)\n    {\n    }\n}  The following code will throw an  InvalidOperationException  stating that there are existing recursive dependencies.   container.Register(typeof(IFoo), typeof(FooWithRecursiveDependency));\ncontainer.GetInstance IFoo ()", 
            "title": "Recursive dependency detection"
        }, 
        {
            "location": "/#internals", 
            "text": "When running under the .Net platform,  LightInject  is capable of creating instances of classes that has the  internal  modifier.   The only requirement is that the internal class exposes a public constructor.  internal class InternalFooWithPublicConstructor : IFoo\n{\n    public InternalFooWithPublicConstructor () {}\n}", 
            "title": "Internals"
        }, 
        {
            "location": "/xunit/", 
            "text": "LightInject.xUnit\n\n\nLightInject.xUnit\n provides an integration that enables dependency injection in \nxUnit\n test methods.\n\n\nInstalling\n\n\nLightInject.xUnit\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.xUnit \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.Xunit.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.xUnit.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.Xunit.cs\n in the target project.\n\n\nInjecting services\n\n\nServices from \nLightInject\n are injected into methods that are decorated with the \nInjectData\n attribute. \n\n\n[Theory, InjectData]                \npublic void TestMethod(IFoo foo)\n{\n    Assert.NotNull(foo);\n}\n\n\n\nConfiguration\n\n\nLightInject\n will look for an \nICompositionRoot\n implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root.   \n\n\nIf such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature.\n\n\npublic static void Configure(IServiceContainer container)\n{\n    container.Register\nIFoo, Foo\n();            \n}\n\n\n\nThis method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.  \n\n\nScoping (xUnit \n= 1.9.2)\n\n\nServices registered with the \nPerScopeLifetime\n or \nPerRequestLifetime\n needs to be resolved within an active \nScope\n to ensure that any services that implements \nIDisposable\n are properly disposed.  \n\n\nBy decorating the test method with the \nScopedTheory\n attribute, a new \nScope\n will be started when the test method starts and it will end when the test method ends.   \n\n\n[ScopedTheory, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}\n\n\n\nScoping (xUnit \n= 2.0.0)\n\n\nServices registered with the \nPerScopeLifetime\n or \nPerRequestLifetime\n needs to be resolved within an active \nScope\n to ensure that any services that implements \nIDisposable\n are properly disposed.  \n\n\nBy decorating the test method with the \nScoped\n attribute, a new \nScope\n will be started when the test method starts and it will end when the test method ends.   \n\n\n[Theory, Scoped, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "xUnit"
        }, 
        {
            "location": "/xunit/#lightinjectxunit", 
            "text": "LightInject.xUnit  provides an integration that enables dependency injection in  xUnit  test methods.", 
            "title": "LightInject.xUnit"
        }, 
        {
            "location": "/xunit/#installing", 
            "text": "LightInject.xUnit  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject.xUnit  \n      This adds a reference to the  LightInject.Xunit.dll  in the target project.  Source  \n    \n          PM  Install-Package LightInject.xUnit.Source  \n      This will install a single file,  LightInject.Xunit.cs  in the target project.", 
            "title": "Installing"
        }, 
        {
            "location": "/xunit/#injecting-services", 
            "text": "Services from  LightInject  are injected into methods that are decorated with the  InjectData  attribute.   [Theory, InjectData]                \npublic void TestMethod(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Injecting services"
        }, 
        {
            "location": "/xunit/#configuration", 
            "text": "LightInject  will look for an  ICompositionRoot  implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root.     If such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature.  public static void Configure(IServiceContainer container)\n{\n    container.Register IFoo, Foo ();            \n}  This method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.", 
            "title": "Configuration"
        }, 
        {
            "location": "/xunit/#scoping-xunit-192", 
            "text": "Services registered with the  PerScopeLifetime  or  PerRequestLifetime  needs to be resolved within an active  Scope  to ensure that any services that implements  IDisposable  are properly disposed.    By decorating the test method with the  ScopedTheory  attribute, a new  Scope  will be started when the test method starts and it will end when the test method ends.     [ScopedTheory, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Scoping (xUnit &lt;= 1.9.2)"
        }, 
        {
            "location": "/xunit/#scoping-xunit-200", 
            "text": "Services registered with the  PerScopeLifetime  or  PerRequestLifetime  needs to be resolved within an active  Scope  to ensure that any services that implements  IDisposable  are properly disposed.    By decorating the test method with the  Scoped  attribute, a new  Scope  will be started when the test method starts and it will end when the test method ends.     [Theory, Scoped, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Scoping (xUnit &gt;= 2.0.0)"
        }, 
        {
            "location": "/autofactory/", 
            "text": "AutoFactory\n\n\n\n\nLightInject.AutoFactory\n enables automatic implementation of factory interfaces.\n\n\nInstalling\n\n\nLightInject.AutoFactory\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.AutoFactory \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.AutoFactory.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.AutoFactory.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.AutoFactory.cs\n in the target project.\n\n\nFactory\n\n\nThe following interface represents a factory class used to resolve \nIFoo\n instances. \n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}\n\n\n\nInstead of having to manually implement the \nIFooFactory\n interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented.\n\n\ncontainer.Register\nIFoo, Foo\n();    \ncontainer.RegisterAutoFactory\nIFooFactory\n(); \nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo();\n\n\n\nParameters\n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo \n{\n    public Foo(int value) {}        \n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}\n\n\n\nRuntime arguments can now be passed to the factory method.\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));  \ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo(42);\n\n\n\nNamed Services\n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic class AnotherFoo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n    IFoo GetAnotherFoo();\n}\n\n\n\nThe name of the factory method is used to identify named services.\n\n\ncontainer.Register\nIFoo, Foo\n();    \ncontainer.Register\nIFoo, Foo\n(\"AnotherFoo\");    \ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo();\nvar anotherFoo = factory.GetAnotherFoo();\n\n\n\nOpen Generics\n\n\npublic interface IFoo\nT\n {}\n\npublic class Foo\nT\n : IFoo\nT\n {}\n\npublic interface IFooFactory\n{\n    IFoo\nT\n GetFoo\nT\n();    \n}\n\n\n\nThe generic type arguments from the factory method are used to create the service instance.\n\n\ncontainer.Register(typeof(IFoo\n), typeof(Foo\n));\ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo\nint\n();", 
            "title": "AutoFactory"
        }, 
        {
            "location": "/autofactory/#autofactory", 
            "text": "LightInject.AutoFactory  enables automatic implementation of factory interfaces.", 
            "title": "AutoFactory"
        }, 
        {
            "location": "/autofactory/#installing", 
            "text": "LightInject.AutoFactory  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject.AutoFactory  \n      This adds a reference to the  LightInject.AutoFactory.dll  in the target project.  Source  \n    \n          PM  Install-Package LightInject.AutoFactory.Source  \n      This will install a single file,  LightInject.AutoFactory.cs  in the target project.", 
            "title": "Installing"
        }, 
        {
            "location": "/autofactory/#factory", 
            "text": "The following interface represents a factory class used to resolve  IFoo  instances.   public interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}  Instead of having to manually implement the  IFooFactory  interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented.  container.Register IFoo, Foo ();    \ncontainer.RegisterAutoFactory IFooFactory (); \nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo();", 
            "title": "Factory"
        }, 
        {
            "location": "/autofactory/#parameters", 
            "text": "public interface IFoo {}\n\npublic class Foo : IFoo \n{\n    public Foo(int value) {}        \n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}  Runtime arguments can now be passed to the factory method.  container.Register int, IFoo ((factory, value) =  new Foo(value));  \ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo(42);", 
            "title": "Parameters"
        }, 
        {
            "location": "/autofactory/#named-services", 
            "text": "public interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic class AnotherFoo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n    IFoo GetAnotherFoo();\n}  The name of the factory method is used to identify named services.  container.Register IFoo, Foo ();    \ncontainer.Register IFoo, Foo (\"AnotherFoo\");    \ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo();\nvar anotherFoo = factory.GetAnotherFoo();", 
            "title": "Named Services"
        }, 
        {
            "location": "/autofactory/#open-generics", 
            "text": "public interface IFoo T  {}\n\npublic class Foo T  : IFoo T  {}\n\npublic interface IFooFactory\n{\n    IFoo T  GetFoo T ();    \n}  The generic type arguments from the factory method are used to create the service instance.  container.Register(typeof(IFoo ), typeof(Foo ));\ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo int ();", 
            "title": "Open Generics"
        }
    ]
}