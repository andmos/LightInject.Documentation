{
    "docs": [
        {
            "location": "/", 
            "text": "Installing\n\n\nLightInject\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject\n\n   \n\n\n\n\n\nThis adds a reference to the LightInject.dll in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Source \n\n   \n\n\n\n\n\nThis will install a single file (LightInject.cs) into the current project.\n\n\nCreating a container\n\n\nvar container = new LightInject.ServiceContainer();\n\n\n\nThe container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope.\n\n\nDefault services\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar instance = container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(instance, typeof(Foo));\n\n\n\nNamed services\n\n\npublic class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instance = container.GetInstance\nIFoo\n(\"AnotherFoo\");\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));\n\n\n\nIf only one named registration exists, \nLightInject\n is capable of resolving this as the default service.\n\n\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instance = container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));\n\n\n\nUnresolved services\n\n\nLightInject can resolve services that are not registered with the container using the \nRegisterFallback\n method.\n\n\nvar container = new ServiceContainer();\ncontainer.RegisterFallback((type, s) =\n true, request =\n new Foo());\nvar foo = container.GetInstance\nIFoo\n();\n\n\n\nThe first argument to the \nRegisterFallback\n method makes it possible to possible to decide if the service can be \"late-resolved\".\nThe second argument is a \nServiceRequest\n instance that provides the requested service type and service name.\n\n\nIEnumerable\nT\n\n\nWhen we register multiple services with the same service type, \nLightInject\n is capable of resolving these services as an  \nIEnumerable\nT\n.\n\n\npublic class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFoo, AnotherFoo\n(\"AnotherFoo\");\nvar instances = container.GetInstance\nIEnumerable\nIFoo\n()\nAssert.AreEqual(2, instances.Count());\n\n\n\nAlternatively using the \nGetAllInstances\n method.\n\n\nvar instances = container.GetAllInstances\nIFoo\n();\nAssert.AreEqual(2, instances.Count());\n\n\n\nIn addition, \nLightInject\n supports the following \nIEnumerable\nT\n sub-types. \n\n\n\n\nArray\n\n\nICollection\nT\n\n\nIList\nT\n\n\nIReadOnlyCollection\nT\n (Net 4.5 and Windows Runtime);\n\n\nIReadOnlyList\nT\n (Net 4.5 and Windows Runtime)\n\n\n\n\nBy default, \nLightInject\n will resolve all services that are compatible with the requested element type.\n\n\ncontainer.Register\nFoo\n();\ncontainer.Register\nDerivedFoo\n();\nvar instances = container.GetAllInstances\nFoo\n();\nAssert.AreEqual(2, instances.Count());\n\n\n\nThis behavior can be overridden using the \nEnableVariance\n container option.\n\n\nvar container = new ServiceContainer(new ContainerOptions { EnableVariance = false });\ncontainer.Register\nFoo\n();\ncontainer.Register\nDerivedFoo\n();\nvar instances = container.GetAllInstances\nFoo\n();\nAssert.AreEqual(1, instances.Count());\n\n\n\nValues\n\n\nRegisters the value as a constant.\n\n\ncontainer.RegisterInstance\nstring\n(\"SomeValue\");\nvar value = container.GetInstance\nstring\n();\nAssert.AreEqual(\"SomeValue, value);\n\n\n\nLifetime\n\n\nThe default behavior in \nLightInject\n is to treat all objects as transients unless otherwise specified.\n\n\ncontainer.Register\nIFoo,Foo\n();\nvar firstInstance = container.GetInstance\nIFoo\n();\nvar secondInstance = container.GetInstance\nIFoo\n();\nAssert.AreNotSame(firstInstance, secondInstance);\n\n\n\nPerScopeLifetime\n\n\nEnsures that only one instance of a given service can exists within a scope.\nThe container will call the \nDispose\n method on all disposable objects created within the scope.\n\n\ncontainer.Register\nIFoo,Foo\n(new PerScopeLifetime());\nusing(container.BeginScope())\n{\n\n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreSame(firstInstance, secondInstance);\n}\n\n\n\nNote:\n \nAn \nInvalidOperationException\n is thrown if a service registered with the \nPerScopeLifetime\n is requested outside the scope.\n\n\nPerContainerLifetime\n\n\nEnsures that only one instance of a given service can exist within the container.\nThe container will call the Dispose method on all disposable objects when the container itself is disposed.\n\n\nusing(container = new ServiceContainer())\n{\n    container.Register\nIFoo,Foo\n(new PerContainerLifetime());   \n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreSame(firstInstance, secondInstance);\n}\n\n\n\nPerRequestLifeTime\n\n\nA new instance is created for each request and the container calls \nDispose\n when the scope ends.\nThis lifetime is used when the conrete class implements \nIDisposable\n.\n\n\ncontainer.Register\nIFoo,Foo\n(new PerRequestLifeTime());\nusing(container.BeginScope())\n{       \n    var firstInstance = container.GetInstance\nIFoo\n();\n    var secondInstance = container.GetInstance\nIFoo\n();\n    Assert.AreNotSame(firstInstance, secondInstance);\n}\n\n\n\n\n\nNote:\n \nAn \nInvalidOperationException\n is thrown if a service registered with the \nPerRequestLifeTime\n is requested outside the scope.\n\n\n\n\nCustom lifetime\n\n\nA custom lifetime is created by implementing the \nILifetime\n interface\n\n\ninternal interface ILifetime\n{\n    object GetInstance(Func\nobject\n instanceFactory, Scope currentScope);        \n}\n\n\n\nThe following example shows to create a custom lifetime that ensures only one instance per thread.\n\n\npublic class PerThreadLifetime : ILifetime\n{\n    ThreadLocal\nobject\n instances = new ThreadLocal\nobject\n();\n\n    public object GetInstance(Func\nobject\n instanceFactory, Scope currentScope)\n    {\n        if (instances.value == null)\n        {\n            instances.value = instanceFactory();\n        }\n        return instances.value;\n    }\n}\n\n\n\nThat is all it takes to create a custom lifetime, but what about disposable services?\n\n\npublic class PerThreadLifetime : ILifetime\n{\n    ThreadLocal\nobject\n instances = new ThreadLocal\nobject\n();\n\n    public object GetInstance(Func\nobject\n instanceFactory, Scope currentScope)\n    {           \n        if (instances.value == null)\n        {               \n            object instance = instanceFactory();                \n            IDisposable disposable = instance as IDisposable;               \n            if (disposable != null)\n            {\n                if (currentScope == null)\n                {\n                    throw new InvalidOperationException(\"Attempt to create an disposable object \n                                                        without a current scope.\")\n                }\n                currentScope.TrackInstance(disposable);\n            }\n\n            instances.value = instance;\n        }\n        return instance.value;\n    }\n}\n\n\n\nImportant\n\n\nA lifetime object controls the lifetime of a single service and can \nnever\n be shared for multiple service registrations.\n\n\nWrong\n\n\nILifetime lifetime = new PerContainerLifeTime();\ncontainer.Register\nIFoo,Foo\n(lifetime);\ncontainer.Register\nIBar,Bar\n(lifetime);\n\n\n\nRight\n\n\ncontainer.Register\nIFoo,Foo\n(new PerContainerLifeTime());\ncontainer.Register\nIBar,Bar\n(new PerContainerLifeTime());\n\n\n\nA lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations.\n\n\nAsync and Await\n\n\nBy default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread.\n\n\nWith the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread.\n\n\nTo illustrate this lets consider an example that is going to cause an instance to be resolved on another thread.\n\n\nWe start of by creating an interface that returns a \nTask\nIBar\n\n\npublic interface IAsyncFoo\n{\n    Task\nIBar\n GetBar();\n}\n\n\n\nNext we implement this interface in such a way that the \nIBar\n instance is requested on another thread.\n\n\npublic class AsyncFoo : IAsyncFoo\n{\n    private readonly Lazy\nIBar\n lazyBar;\n\n    public AsyncFoo(Lazy\nIBar\n lazyBar)\n    {\n        this.lazyBar = lazyBar;\n    }\n\n    public async Task\nIBar\n GetBar()\n    {\n        await Task.Delay(10);\n        return lazyBar.Value; \n--This code is executed on another thread (continuation).\n    }\n}\n\n\n\nThe we register the dependency (\nIBar\n) with the \nPerScopeLifetime\n that is going to cause the container to ask for the current scope so that the instance can be registered with that scope.\n\n\nvar container = new ServiceContainer();\ncontainer.Register\nIBar, Bar\n(new PerScopeLifetime());\ncontainer.Register\nIAsyncFoo, AsyncFoo\n();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance\nIAsyncFoo\n();\n    ExceptionAssert.Throws\nAggregateException\n(() =\n instance.GetBar().Wait());                \n}\n\n\n\nThis will throw an exception that states the following:\n\n\nAttempt to create a scoped instance without a current scope.\n\n\n\nThe reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread.\n\n\nTo deal with this issue, \nLightInject\n now supports scopes across the logical \nCallContext\n.  \n\n\nvar container = new ServiceContainer();\ncontainer.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider();\ncontainer.Register\nIBar, Bar\n(new PerScopeLifetime());\ncontainer.Register\nIAsyncFoo, AsyncFoo\n();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance\nIAsyncFoo\n();\n    var bar = instance.GetBar().Result;\n    Assert.IsInstanceOfType(bar, typeof(IBar));\n}\n\n\n\n\n\nNote that the \nPerLogicalCallContextScopeManagerProvider\n is only available when running under .Net 4.5.\nFor more information, please refer to the following \narticle\n by Stephen Cleary.\n\n\n\n\nDependencies\n\n\nConstructor Injection\n\n\npublic interface IFoo {}        \npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public Foo(IBar bar) \n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; } \n}\n\npublic class Bar : IBar {}\n\n\n\nImplicit service registration\n\n\nRegisters a service without specifying any information about how to resolve the constructor dependencies of the implementing type.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIBar, Bar\n();\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));\n\n\n\n\n\nNote: In the case where the implementing type(Foo) has more than one constructor, \nLightInject\n will choose the constructor with the most parameters. \n\n\n\n\nFor fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency.\n\n\ncontainer.RegisterConstructorDependency\nIBar\n((factory, parameterInfo) =\n new Bar());\n\n\n\nThis tells the container to inject a new \nBar\n instance whenever it sees an \nIBar\n constructor dependency.\n\n\nExplicit service registration\n\n\nRegisters a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies.\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nIFoo\n(factory =\n new Foo(factory.GetInstance\nIBar\n));\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.Bar);\n\n\n\nParameters\n\n\nParameters are used when we want to supply one or more values when the service is resolved.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((arg, factory) =\n new Foo(arg));\nvar foo = (Foo)container.GetInstance\nint, IFoo\n(42);\nAssert.AreEqual(42,foo.Value);\n\n\n\nWe can also do a combination of supplied values and dependencies.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value, IBar bar)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n    public IBar Bar { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value, factory.GetInstance\nIBar\n()));\nvar foo = (Foo)container.GetInstance\nint, IFoo\n();\nAssert.AreEqual(42, foo.Value);\nAssert.IsNotNull(foo.Bar);\n\n\n\nProperty Injection\n\n\npublic interface IFoo {}\n\npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public IBar Bar { get; set; }\n}\n\npublic class Bar : IBar {}\n\n\n\nImplicit service registration\n\n\nRegisters the service without specifying any information about how to resolve the property dependencies.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIBar, Bar\n();\nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.bar);\n\n\n\n\n\nNote:\n \nLightInject\n* considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will \nNOT*\n throw an exception in the case of an unresolved property dependency.\n          \n\n\n\n\nFor fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency.\n\n\ncontainer.RegisterPropertyDependency\nIBar\n((factory, propertyInfo) =\n new Bar());\n\n\n\nThis tells the container to inject a new \nBar\n instance whenever it sees an \nIBar\n property dependency.\n\n\nExplicit service registration\n\n\nRegisters a service by providing explicit information about how to create the service instance and how to resolve the property dependencies.\n\n\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nIFoo\n(factory =\n new Foo() {Bar = factory.GetInstance\nIBar\n()}) \nvar foo = (Foo)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(foo.bar);\n\n\n\nProperty injection on existing instances.\n\n\nIn the cases where we don't control the creation of the service instance, \nLightInject\n can inject property dependencies into an existing instance.\n\n\ncontainer.Register\nIBar, Bar\n();\nvar foo = new Foo();\ncontainer.InjectProperties(foo);\nAssert.IsNotNull(foo);\n\n\n\nInitializers\n\n\nUse the \nInitialize\n method to perform service instance initialization/post-processing.  \n\n\ncontainer.Register\nIFoo, FooWithPropertyDependency\n();\ncontainer.Initialize(registration =\n registration.ServiceType == typeof(IFoo), \n    (factory, instance) =\n ((FooWithPropertyDependency)instance).Bar = new Bar());\nvar foo = (FooWithProperyDependency)container.GetInstance\nIFoo\n();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));\n\n\n\nAssembly Scanning\n\n\nLightInject is capable of registering services by looking at the types of a given assembly.\n\n\ncontainer.RegisterAssembly(typeof(IFoo).Assembly)\n\n\n\nTo filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type.\n\n\ncontainer.RegisterAssembly(typeof(IFoo).Assembly, (serviceType, implementingType) =\n serviceType.NameSpace == \"SomeNamespace\");\n\n\n\nIt is also possible to scan a set assembly files based on a search pattern.\n\n\ncontainer.RegisterAssembly(\"SomeAssemblyName*.dll\");\n\n\n\nComposition Root\n\n\nWhen \nLightInject\n scans an assembly it will look for an implementation of the \nICompositionRoot\n interface.   \n\n\npublic class SampleCompositionRoot : ICompositionRoot\n{               \n    public void Compose(IServiceRegistry serviceRegistry)\n    {     \n        serviceRegistry.Register(typeof(IFoo),typeof(Foo));\n    }\n}\n\n\n\nIf one or more implementations of the \nICompositionRoot\n interface is found, they will be created and executed.\n\n\n\n\nNote:\n \nAny other services contained within the target assembly that is not registered in the composition root, will \nNOT\n be registered.\n\n\n\n\nRather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a \nICompositionRoot\n, is that they can easily be reused in automated tests.   \n\n\nLazy Composition Roots\n\n\nLightInject\n is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading.\n\n\nIf an unregistered service is requested, \nLightInject\n will scan the assembly where this service is contained.  \n\n\nCompositionRootAttribute\n\n\nWhen an assembly is being scanned, \nLightInject\n will look for implementations of the \nICompositionRoot\n interface. For large assemblies that contains many type, this might be an expensive operation. The \nCompositionRootAttribute\n is an assembly level attribute that simply helps \nLightInject\n to locate the compostion root.\n\n\n[assembly: CompositionRootType(typeof(SampleCompositionRoot))]\n\n\n\nRegisterFrom\n\n\nAllows explicit execution of a composition root.\n\n\ncontainer.RegisterFrom\nSampleCompositionRoot\n();\n\n\n\nGenerics\n\n\npublic interface IFoo\nT\n {};\npublic class Foo\nT\n : IFoo\nT\n {};\n\n\n\nThe container creates the closed generic type based on the service request.\n\n\ncontainer.Register(typeof(IFoo\n), typeof(Foo\n));\nvar instance = container.GetInstance(typeof(IFoo\nint\n));\nAssert.IsInstanceOfType(instance, typeof(Foo\nint\n));\n\n\n\nConstraints\n\n\nLightInject\n enforces generic constrains  \n\n\nLazy\nT\n\n\nLightInject\n can resolve a service as an instance of \nLazy\nT\n when we want to postpone resolving the underlying service until it is needed.\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar lazyFoo = container.GetInstance\nLazy\nIFoo\n();\nAssert.IsNotNull(lazyFoo.Value);\n\n\n\nFunction Factories\n\n\nFunction factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the \nService Locator\n (anti)pattern.\n\n\npublic interface IFoo {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo,Foo\n();\nvar func = container.GetInstance\nFunc\nIFoo\n();\nvar foo = func();\nAssert.IsNotNull(foo);\n\n\n\n\n\nNote:\n \nA function factory is effectively a delegate that redirects back to the corresponding \nGetInstance\n method on the service container.\n\n\n\n\nNamed Factories\n\n\nThe container returns a function delegate that represents calling the \nGetInstance\n method with \"SomeFoo\" as the service name argument.\n\n\ncontainer.Register\nIFoo, Foo\n(\"SomeFoo\");\nvar func = container.GetInstance\nFunc\nIFoo\n(\"SomeFoo\");   \nvar foo = func();\nAssert.IsNotNull(foo);\n\n\n\nParameters\n\n\nFunction factories can also take parameters that will be used create the service instance.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));\nvar fooFactory = container.GetInstance\nFunc\nint, IFoo\n();\nvar foo = (Foo)fooFactory(42); \nAssert.AreEqual(foo.Value, 42);\n\n\n\n\n\nNote\n : \nThe service must be explicitly registered in order for the container to resolve it as a parameterized function factory.\n\n\n\n\nIDisposable\n\n\nThe only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable.\n\n\npublic interface IFoo : IDisposable {}\npublic class Foo : IFoo {}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\nvar fooFactory = container.GetInstance\nFunc\nIFoo\n();\n\nusing(IFoo foo = fooFactory())\n{\n\n} \n--Instance is disposed here\n\n\n\n\n\nNote:\n \nAlthough this is common practice even in the \nBCL\n, this kind of interfaces are often referred to as \nleaky abstractions\n.\n\n\n\n\nTyped Factories\n\n\nA typed factory is a class that wraps the function factory that is used to create the underlying service instance.\nAs opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory.   \n\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nIFoo\n createFoo;\n\n    public FooFactory(Func\nIFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo()\n    {\n        return createFoo();\n    }\n}\n\n\n\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Register\nIFooFactory, FooFactory\n(new PerContainerLifetime());\nvar fooFactory = container.GetInstance\nIFooFactory\n();\nvar foo = fooFactory.GetFoo();\nAssert.IsNotNull(foo);\n\n\n\n\n\nNote:\n \nRegister typed factories with the \nPerContainerLifetime\n unless a compelling reason exists to choose a different lifetime.\n  \n\n\n\n\nParameters\n\n\nTypes factories can also wrap a parameterized function factory and allows us to pass arguments.\n\n\npublic class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nint, IFoo\n createFoo;\n\n    public FooFactory(Func\nint, IFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n}\n\n\n\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));\ncontainer.Register\nIFooFactory, FooFactory\n(new PerContainerLifetime());\nvar typedFooFactory = container.GetInstance\nIFooFactory\n();\nvar foo = typedFooFactory.GetFoo(42);\nAssert.AreEqual(foo.Value, 42);\n\n\n\nIDisposable\n\n\nWorking with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction.\n\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n    void Release(IFoo foo);\n}\n\n\n\n\n\npublic class FooFactory : IFooFactory\n{\n    private Func\nIFoo\n createFoo;\n\n    public FooFactory(Func\nIFoo\n createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n\n    public void Release(IFoo foo)\n    {\n        var disposable = foo as IDisposable;\n        if (disposable != null)\n        {\n            disposable.Dispose();\n        }\n    }\n}\n\n\n\nRecursive dependency detection\n\n\nA recursive dependency graph is when a service depends directly or indirectly on itself.\n\n\npublic class FooWithRecursiveDependency : IFoo\n{\n    public FooWithRecursiveDependency(IFoo foo)\n    {\n    }\n}\n\n\n\nThe following code will throw an \nInvalidOperationException\n stating that there are existing recursive dependencies. \n\n\ncontainer.Register(typeof(IFoo), typeof(FooWithRecursiveDependency));\ncontainer.GetInstance\nIFoo\n()\n\n\n\nInternals\n\n\nWhen running under the .Net platform, \nLightInject\n is capable of creating instances of classes that has the \ninternal\n modifier. \n\n\nThe only requirement is that the internal class exposes a public constructor.\n\n\ninternal class InternalFooWithPublicConstructor : IFoo\n{\n    public InternalFooWithPublicConstructor () {}\n}", 
            "title": "Home"
        }, 
        {
            "location": "/#installing", 
            "text": "LightInject  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject \n      This adds a reference to the LightInject.dll in the target project.  Source  \n    \n          PM  Install-Package LightInject.Source  \n      This will install a single file (LightInject.cs) into the current project.  Creating a container  var container = new LightInject.ServiceContainer();  The container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope.  Default services  public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar instance = container.GetInstance IFoo ();\nAssert.IsInstanceOfType(instance, typeof(Foo));  Named services  public class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}   container.Register IFoo, Foo ();\ncontainer.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instance = container.GetInstance IFoo (\"AnotherFoo\");\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));  If only one named registration exists,  LightInject  is capable of resolving this as the default service.  container.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instance = container.GetInstance IFoo ();\nAssert.IsInstanceOfType(instance, typeof(AnotherFoo));  Unresolved services  LightInject can resolve services that are not registered with the container using the  RegisterFallback  method.  var container = new ServiceContainer();\ncontainer.RegisterFallback((type, s) =  true, request =  new Foo());\nvar foo = container.GetInstance IFoo ();  The first argument to the  RegisterFallback  method makes it possible to possible to decide if the service can be \"late-resolved\".\nThe second argument is a  ServiceRequest  instance that provides the requested service type and service name.  IEnumerable T  When we register multiple services with the same service type,  LightInject  is capable of resolving these services as an   IEnumerable T .  public class Foo : IFoo {}\npublic class AnotherFoo : IFoo {}   container.Register IFoo, Foo ();\ncontainer.Register IFoo, AnotherFoo (\"AnotherFoo\");\nvar instances = container.GetInstance IEnumerable IFoo ()\nAssert.AreEqual(2, instances.Count());  Alternatively using the  GetAllInstances  method.  var instances = container.GetAllInstances IFoo ();\nAssert.AreEqual(2, instances.Count());  In addition,  LightInject  supports the following  IEnumerable T  sub-types.    Array  ICollection T  IList T  IReadOnlyCollection T  (Net 4.5 and Windows Runtime);  IReadOnlyList T  (Net 4.5 and Windows Runtime)   By default,  LightInject  will resolve all services that are compatible with the requested element type.  container.Register Foo ();\ncontainer.Register DerivedFoo ();\nvar instances = container.GetAllInstances Foo ();\nAssert.AreEqual(2, instances.Count());  This behavior can be overridden using the  EnableVariance  container option.  var container = new ServiceContainer(new ContainerOptions { EnableVariance = false });\ncontainer.Register Foo ();\ncontainer.Register DerivedFoo ();\nvar instances = container.GetAllInstances Foo ();\nAssert.AreEqual(1, instances.Count());  Values  Registers the value as a constant.  container.RegisterInstance string (\"SomeValue\");\nvar value = container.GetInstance string ();\nAssert.AreEqual(\"SomeValue, value);", 
            "title": "Installing"
        }, 
        {
            "location": "/#lifetime", 
            "text": "The default behavior in  LightInject  is to treat all objects as transients unless otherwise specified.  container.Register IFoo,Foo ();\nvar firstInstance = container.GetInstance IFoo ();\nvar secondInstance = container.GetInstance IFoo ();\nAssert.AreNotSame(firstInstance, secondInstance);  PerScopeLifetime  Ensures that only one instance of a given service can exists within a scope.\nThe container will call the  Dispose  method on all disposable objects created within the scope.  container.Register IFoo,Foo (new PerScopeLifetime());\nusing(container.BeginScope())\n{\n\n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreSame(firstInstance, secondInstance);\n}  Note:   An  InvalidOperationException  is thrown if a service registered with the  PerScopeLifetime  is requested outside the scope.  PerContainerLifetime  Ensures that only one instance of a given service can exist within the container.\nThe container will call the Dispose method on all disposable objects when the container itself is disposed.  using(container = new ServiceContainer())\n{\n    container.Register IFoo,Foo (new PerContainerLifetime());   \n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreSame(firstInstance, secondInstance);\n}  PerRequestLifeTime  A new instance is created for each request and the container calls  Dispose  when the scope ends.\nThis lifetime is used when the conrete class implements  IDisposable .  container.Register IFoo,Foo (new PerRequestLifeTime());\nusing(container.BeginScope())\n{       \n    var firstInstance = container.GetInstance IFoo ();\n    var secondInstance = container.GetInstance IFoo ();\n    Assert.AreNotSame(firstInstance, secondInstance);\n}   Note:   An  InvalidOperationException  is thrown if a service registered with the  PerRequestLifeTime  is requested outside the scope.   Custom lifetime  A custom lifetime is created by implementing the  ILifetime  interface  internal interface ILifetime\n{\n    object GetInstance(Func object  instanceFactory, Scope currentScope);        \n}  The following example shows to create a custom lifetime that ensures only one instance per thread.  public class PerThreadLifetime : ILifetime\n{\n    ThreadLocal object  instances = new ThreadLocal object ();\n\n    public object GetInstance(Func object  instanceFactory, Scope currentScope)\n    {\n        if (instances.value == null)\n        {\n            instances.value = instanceFactory();\n        }\n        return instances.value;\n    }\n}  That is all it takes to create a custom lifetime, but what about disposable services?  public class PerThreadLifetime : ILifetime\n{\n    ThreadLocal object  instances = new ThreadLocal object ();\n\n    public object GetInstance(Func object  instanceFactory, Scope currentScope)\n    {           \n        if (instances.value == null)\n        {               \n            object instance = instanceFactory();                \n            IDisposable disposable = instance as IDisposable;               \n            if (disposable != null)\n            {\n                if (currentScope == null)\n                {\n                    throw new InvalidOperationException(\"Attempt to create an disposable object \n                                                        without a current scope.\")\n                }\n                currentScope.TrackInstance(disposable);\n            }\n\n            instances.value = instance;\n        }\n        return instance.value;\n    }\n}  Important  A lifetime object controls the lifetime of a single service and can  never  be shared for multiple service registrations.  Wrong  ILifetime lifetime = new PerContainerLifeTime();\ncontainer.Register IFoo,Foo (lifetime);\ncontainer.Register IBar,Bar (lifetime);  Right  container.Register IFoo,Foo (new PerContainerLifeTime());\ncontainer.Register IBar,Bar (new PerContainerLifeTime());  A lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations.  Async and Await  By default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread.  With the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread.  To illustrate this lets consider an example that is going to cause an instance to be resolved on another thread.  We start of by creating an interface that returns a  Task IBar  public interface IAsyncFoo\n{\n    Task IBar  GetBar();\n}  Next we implement this interface in such a way that the  IBar  instance is requested on another thread.  public class AsyncFoo : IAsyncFoo\n{\n    private readonly Lazy IBar  lazyBar;\n\n    public AsyncFoo(Lazy IBar  lazyBar)\n    {\n        this.lazyBar = lazyBar;\n    }\n\n    public async Task IBar  GetBar()\n    {\n        await Task.Delay(10);\n        return lazyBar.Value;  --This code is executed on another thread (continuation).\n    }\n}  The we register the dependency ( IBar ) with the  PerScopeLifetime  that is going to cause the container to ask for the current scope so that the instance can be registered with that scope.  var container = new ServiceContainer();\ncontainer.Register IBar, Bar (new PerScopeLifetime());\ncontainer.Register IAsyncFoo, AsyncFoo ();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance IAsyncFoo ();\n    ExceptionAssert.Throws AggregateException (() =  instance.GetBar().Wait());                \n}  This will throw an exception that states the following:  Attempt to create a scoped instance without a current scope.  The reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread.  To deal with this issue,  LightInject  now supports scopes across the logical  CallContext .    var container = new ServiceContainer();\ncontainer.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider();\ncontainer.Register IBar, Bar (new PerScopeLifetime());\ncontainer.Register IAsyncFoo, AsyncFoo ();\n\nusing (container.BeginScope())\n{\n    var instance = container.GetInstance IAsyncFoo ();\n    var bar = instance.GetBar().Result;\n    Assert.IsInstanceOfType(bar, typeof(IBar));\n}   Note that the  PerLogicalCallContextScopeManagerProvider  is only available when running under .Net 4.5.\nFor more information, please refer to the following  article  by Stephen Cleary.", 
            "title": "Lifetime"
        }, 
        {
            "location": "/#dependencies", 
            "text": "Constructor Injection  public interface IFoo {}        \npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public Foo(IBar bar) \n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; } \n}\n\npublic class Bar : IBar {}  Implicit service registration  Registers a service without specifying any information about how to resolve the constructor dependencies of the implementing type.  container.Register IFoo, Foo ();\ncontainer.Register IBar, Bar ();\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));   Note: In the case where the implementing type(Foo) has more than one constructor,  LightInject  will choose the constructor with the most parameters.    For fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency.  container.RegisterConstructorDependency IBar ((factory, parameterInfo) =  new Bar());  This tells the container to inject a new  Bar  instance whenever it sees an  IBar  constructor dependency.  Explicit service registration  Registers a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies.  container.Register IBar, Bar ();\ncontainer.Register IFoo (factory =  new Foo(factory.GetInstance IBar ));\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.Bar);  Parameters  Parameters are used when we want to supply one or more values when the service is resolved.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}   container.Register int, IFoo ((arg, factory) =  new Foo(arg));\nvar foo = (Foo)container.GetInstance int, IFoo (42);\nAssert.AreEqual(42,foo.Value);  We can also do a combination of supplied values and dependencies.  public class Foo : IFoo\n{\n    public Foo(int value, IBar bar)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n    public IBar Bar { get; private set; }\n}   container.Register IBar, Bar ();\ncontainer.Register int, IFoo ((factory, value) =  new Foo(value, factory.GetInstance IBar ()));\nvar foo = (Foo)container.GetInstance int, IFoo ();\nAssert.AreEqual(42, foo.Value);\nAssert.IsNotNull(foo.Bar);  Property Injection  public interface IFoo {}\n\npublic interface IBar {}\n\npublic class Foo : IFoo\n{\n    public IBar Bar { get; set; }\n}\n\npublic class Bar : IBar {}  Implicit service registration  Registers the service without specifying any information about how to resolve the property dependencies.  container.Register IFoo, Foo ();\ncontainer.Register IBar, Bar ();\nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.bar);   Note:   LightInject * considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will  NOT*  throw an exception in the case of an unresolved property dependency.              For fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency.  container.RegisterPropertyDependency IBar ((factory, propertyInfo) =  new Bar());  This tells the container to inject a new  Bar  instance whenever it sees an  IBar  property dependency.  Explicit service registration  Registers a service by providing explicit information about how to create the service instance and how to resolve the property dependencies.  container.Register IBar, Bar ();\ncontainer.Register IFoo (factory =  new Foo() {Bar = factory.GetInstance IBar ()}) \nvar foo = (Foo)container.GetInstance IFoo ();\nAssert.IsNotNull(foo.bar);  Property injection on existing instances.  In the cases where we don't control the creation of the service instance,  LightInject  can inject property dependencies into an existing instance.  container.Register IBar, Bar ();\nvar foo = new Foo();\ncontainer.InjectProperties(foo);\nAssert.IsNotNull(foo);", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#initializers", 
            "text": "Use the  Initialize  method to perform service instance initialization/post-processing.    container.Register IFoo, FooWithPropertyDependency ();\ncontainer.Initialize(registration =  registration.ServiceType == typeof(IFoo), \n    (factory, instance) =  ((FooWithPropertyDependency)instance).Bar = new Bar());\nvar foo = (FooWithProperyDependency)container.GetInstance IFoo ();\nAssert.IsInstanceOfType(foo.Bar, typeof(Bar));", 
            "title": "Initializers"
        }, 
        {
            "location": "/#assembly-scanning", 
            "text": "LightInject is capable of registering services by looking at the types of a given assembly.  container.RegisterAssembly(typeof(IFoo).Assembly)  To filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type.  container.RegisterAssembly(typeof(IFoo).Assembly, (serviceType, implementingType) =  serviceType.NameSpace == \"SomeNamespace\");  It is also possible to scan a set assembly files based on a search pattern.  container.RegisterAssembly(\"SomeAssemblyName*.dll\");", 
            "title": "Assembly Scanning"
        }, 
        {
            "location": "/#composition-root", 
            "text": "When  LightInject  scans an assembly it will look for an implementation of the  ICompositionRoot  interface.     public class SampleCompositionRoot : ICompositionRoot\n{               \n    public void Compose(IServiceRegistry serviceRegistry)\n    {     \n        serviceRegistry.Register(typeof(IFoo),typeof(Foo));\n    }\n}  If one or more implementations of the  ICompositionRoot  interface is found, they will be created and executed.   Note:   Any other services contained within the target assembly that is not registered in the composition root, will  NOT  be registered.   Rather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a  ICompositionRoot , is that they can easily be reused in automated tests.     Lazy Composition Roots  LightInject  is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading.  If an unregistered service is requested,  LightInject  will scan the assembly where this service is contained.    CompositionRootAttribute  When an assembly is being scanned,  LightInject  will look for implementations of the  ICompositionRoot  interface. For large assemblies that contains many type, this might be an expensive operation. The  CompositionRootAttribute  is an assembly level attribute that simply helps  LightInject  to locate the compostion root.  [assembly: CompositionRootType(typeof(SampleCompositionRoot))]  RegisterFrom  Allows explicit execution of a composition root.  container.RegisterFrom SampleCompositionRoot ();", 
            "title": "Composition Root"
        }, 
        {
            "location": "/#generics", 
            "text": "public interface IFoo T  {};\npublic class Foo T  : IFoo T  {};  The container creates the closed generic type based on the service request.  container.Register(typeof(IFoo ), typeof(Foo ));\nvar instance = container.GetInstance(typeof(IFoo int ));\nAssert.IsInstanceOfType(instance, typeof(Foo int ));  Constraints  LightInject  enforces generic constrains", 
            "title": "Generics"
        }, 
        {
            "location": "/#lazyt", 
            "text": "LightInject  can resolve a service as an instance of  Lazy T  when we want to postpone resolving the underlying service until it is needed.  public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar lazyFoo = container.GetInstance Lazy IFoo ();\nAssert.IsNotNull(lazyFoo.Value);", 
            "title": "Lazy&lt;T&gt;"
        }, 
        {
            "location": "/#function-factories", 
            "text": "Function factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the  Service Locator  (anti)pattern.  public interface IFoo {}\npublic class Foo : IFoo {}   container.Register IFoo,Foo ();\nvar func = container.GetInstance Func IFoo ();\nvar foo = func();\nAssert.IsNotNull(foo);   Note:   A function factory is effectively a delegate that redirects back to the corresponding  GetInstance  method on the service container.   Named Factories  The container returns a function delegate that represents calling the  GetInstance  method with \"SomeFoo\" as the service name argument.  container.Register IFoo, Foo (\"SomeFoo\");\nvar func = container.GetInstance Func IFoo (\"SomeFoo\");   \nvar foo = func();\nAssert.IsNotNull(foo);  Parameters  Function factories can also take parameters that will be used create the service instance.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}   container.Register int, IFoo ((factory, value) =  new Foo(value));\nvar fooFactory = container.GetInstance Func int, IFoo ();\nvar foo = (Foo)fooFactory(42); \nAssert.AreEqual(foo.Value, 42);   Note  :  The service must be explicitly registered in order for the container to resolve it as a parameterized function factory.   IDisposable  The only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable.  public interface IFoo : IDisposable {}\npublic class Foo : IFoo {}   container.Register IFoo, Foo ();\nvar fooFactory = container.GetInstance Func IFoo ();\n\nusing(IFoo foo = fooFactory())\n{\n\n}  --Instance is disposed here   Note:   Although this is common practice even in the  BCL , this kind of interfaces are often referred to as  leaky abstractions .", 
            "title": "Function Factories"
        }, 
        {
            "location": "/#typed-factories", 
            "text": "A typed factory is a class that wraps the function factory that is used to create the underlying service instance.\nAs opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory.     public interface IFooFactory\n{\n    IFoo GetFoo();\n}   public class FooFactory : IFooFactory\n{\n    private Func IFoo  createFoo;\n\n    public FooFactory(Func IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo()\n    {\n        return createFoo();\n    }\n}   container.Register IFoo, Foo ();\ncontainer.Register IFooFactory, FooFactory (new PerContainerLifetime());\nvar fooFactory = container.GetInstance IFooFactory ();\nvar foo = fooFactory.GetFoo();\nAssert.IsNotNull(foo);   Note:   Register typed factories with the  PerContainerLifetime  unless a compelling reason exists to choose a different lifetime.      Parameters  Types factories can also wrap a parameterized function factory and allows us to pass arguments.  public class Foo : IFoo\n{\n    public Foo(int value)\n    {\n        Value = value;\n    }\n\n    public int Value { get; private set; }\n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}   public class FooFactory : IFooFactory\n{\n    private Func int, IFoo  createFoo;\n\n    public FooFactory(Func int, IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n}   container.Register int, IFoo ((factory, value) =  new Foo(value));\ncontainer.Register IFooFactory, FooFactory (new PerContainerLifetime());\nvar typedFooFactory = container.GetInstance IFooFactory ();\nvar foo = typedFooFactory.GetFoo(42);\nAssert.AreEqual(foo.Value, 42);  IDisposable  Working with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction.  public interface IFooFactory\n{\n    IFoo GetFoo(int value);\n    void Release(IFoo foo);\n}   public class FooFactory : IFooFactory\n{\n    private Func IFoo  createFoo;\n\n    public FooFactory(Func IFoo  createFoo)\n    {\n        this.createFoo = createFoo;\n    }\n\n    public IFoo GetFoo(int value)\n    {\n        return createFoo(value);\n    }\n\n    public void Release(IFoo foo)\n    {\n        var disposable = foo as IDisposable;\n        if (disposable != null)\n        {\n            disposable.Dispose();\n        }\n    }\n}", 
            "title": "Typed Factories"
        }, 
        {
            "location": "/#recursive-dependency-detection", 
            "text": "A recursive dependency graph is when a service depends directly or indirectly on itself.  public class FooWithRecursiveDependency : IFoo\n{\n    public FooWithRecursiveDependency(IFoo foo)\n    {\n    }\n}  The following code will throw an  InvalidOperationException  stating that there are existing recursive dependencies.   container.Register(typeof(IFoo), typeof(FooWithRecursiveDependency));\ncontainer.GetInstance IFoo ()", 
            "title": "Recursive dependency detection"
        }, 
        {
            "location": "/#internals", 
            "text": "When running under the .Net platform,  LightInject  is capable of creating instances of classes that has the  internal  modifier.   The only requirement is that the internal class exposes a public constructor.  internal class InternalFooWithPublicConstructor : IFoo\n{\n    public InternalFooWithPublicConstructor () {}\n}", 
            "title": "Internals"
        }, 
        {
            "location": "/interception/", 
            "text": "Interception\n\n\nLightInject\n supports \nAspect Oriented Programming\n through proxy-based method interceptors. \n\n\nInstalling\n\n\nLightInject.Interception\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Interception \n\n   \n\n\n\n\n\nThis adds a reference to the LightInject.Interception.dll in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Interception.Source \n\n   \n\n\n\n\n\nThis will install a single file (LightInject.Interception.cs) into the current project.\n\n\nInterceptors\n\n\nAn interceptor sits between the call site and the target instance and intercepts method calls.\n\n\npublic class SampleInterceptor : IInterceptor\n{\n    public object Invoke(IInvocationInfo invocationInfo)\n    {\n        // Perform logic before invoking the target method\n        var returnValue = invocationInfo.Proceed();\n        // Perform logic after invoking the target method\n        return returnValue;           \n    }        \n}\n\n\n\n\nThe \nIInvocationInfo\n instance passed into the \nInvoke\n method contains information about the method being intercepted.\n\n\nThe \nProceed\n method calls down the chain of interceptors and ultimately the actual target instance.   \n\n\nSingle Interceptor\n\n\nThis example shows how to configure the service container with a single interceptor to handle all method calls.\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), sf =\n new SampleInterceptor());\n\nvar instance = container.GetInstance\nIFoo\n();\n\n\n\nThe instance returned is a proxy object that forwards method calls to the \nSampleInterceptor\n class.\n\n\nThe first parameter of the \nIntercept\n method is a selector function used to select the services that should have this interceptor applied.       \n\nThe second parameter is a function delegate that used to create an \nIInterceptor\n instance. \n\n\nNote:\n \nProxy types are lazy in the sense that they will not create the target instance or any interceptors until the first method call is made.\n \n\n\nDependencies\n\n\nInterceptors might also have dependencies and by resolving the interceptor through the container, those dependencies can be injected into the interceptor itself. \n\n\npublic class SampleInterceptor : IInterceptor\n{\n    private IBar bar;\n\n    public SampleInterceptor(IBar bar) \n    {\n        this.bar = bar;    \n    }\n\n    public object Invoke(IInvocationInfo invocationInfo)\n\n        // Perform logic using the injected dependency before invoking the target method             \n        return invovationInfo.Proceed();                      \n        // Perform logic using the injected dependency after invoking the target method\n    }        \n}\n\n\n\nThe following example shows how to configure the container so that the \nSampleInterceptor\n instance is resolved through the container.\n\n\ncontainer.Register\nIFoo, Foo\n()\ncontainer.Register\nIBar, Bar\n();\ncontainer.Register\nIInterceptor, SampleInterceptor\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), sf =\n sf.GetInstance\nIInterceptor\n());\n\n\n\nNote:\n \nWhen injecting depndencies into an interceptor we must make sure that the injected dependency is NOT intercepted by the same interceptor as this would cause a \nStackOverFlowException\n.\n  \n\n\nMultiple Interceptors\n\n\nInterceptors can be set up to handle a lot of cross cutting concerns such as logging, caching, null check and so on.\nAccording to the \nSingle Responsibility Principle\n, we can separate the combined logic into a set of interceptor that each only does \"one\" thing.\n\n\nWe can do this by using another overload of the \nIntercept\n method that allows us to set up a \nProxyDefinition\n instance that gives us more control over the proxy type that is being created.\n\n\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), (sf,pd) =\n  DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(new FirstInterceptor());\n    proxyDefinition.Implement(new SecondInterceptor());\n}\n\n\n\nNote:\n \nThe interceptors are invoked in the same order as they are registered with the \nImplement\n method.\n\n\nMethod Selectors\n\n\nMethod selectors are used to select the methods that should be intercepted by an interceptor.\n\n\nThe following example shows how to set up the container so that only calls method \nA\n is passed to the interceptor.\n\n\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), (sf, pd) =\n  DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =\n new SampleInterceptor(), m =\n m.Name == \"SomeMethodName\");       \n}\n\n\n\nMethods that does not match the method selector predicate will NOT be intercepted and method calls will be passed directly down to the target instance.  \n\n\nIf we omit the method selector, \nLightInject\n will intercept all methods from the target type and any additional interface, except methods that are inherited from \nSystem.Object\n.    \n\n\n\n\nEquals(Object)\n\n\nGetHashCode\n\n\nGetType\n\n\nToString\n\n\n\n\nIf we choose to use a method selector, these methods will also be intercepted if they match the predicate in the method selector.\n\n\nproxyDefinition.Implement(() =\n new SampleInterceptor(), m =\n m.IsDeclaredBy\nobject\n());\n\n\n\nWe can also use a method selector with the \nIntercept\n method that allows easy interception of any method without implementing an \nIInterceptor\n.\n\n\ncontainer.Intercept(m =\n m.Name == \"SomeMethodName\", invocationInfo =\n invocationInfo.Proceed());\n\n\n\nExtension Methods\n\n\nLightInject provides a set of extension method that simplifies method selector predicates.\n\n\n\n\nIsPropertySetter - Returns \ntrue\n if the method represents a property setter, otherwise \nfalse\n. \n\n\nIsPropertyGetter - Returns \ntrue\n if the method represents a property getter, otherwise \nfalse\n.\n\n\nGetProperty - Returns the property for which the target method either represents the property getter or the property setter.\n\n\n\n\nChaining Interceptors\n\n\nAs already seen in the example with multiple interceptors,  we can chain interceptors together. We can also combine this with method selectors that will affect the call sequence from the call site down to the actual target instance.\n\n\nConsider an interface with three methods.\n\n\npublic interface IFoo \n{\n    void A();\n    void B();\n    void C();\n}\n\n\n\nThe following example shows how we can control the call sequence for each method.\n\n\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), (sf, pd) =\n  DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =\n new FirstInterceptor(), m =\n m.Name == \"A\");\n    proxyDefinition.Implement(() =\n new SecondInterceptor(), m =\n m.Name == \"B\");   \n    proxyDefinition.Implement(() =\n new ThirdInterceptor(), m =\n m.Name == \"A\" || m.Name == \"B\" || m.Name == \"C\");\n}\n\n\n\nMethod A call sequence\n\n\nFirstInterceptor -\n ThirdInterceptor -\n Target \n\n\nMethod B call sequence\n\n\nSecondInterceptor -\n ThirdInterceptor -\n Target\n\n\nMethod C call sequence\n\n\nThirdInterceptor -\n Target\n\n\nImplementing additional interfaces\n\n\nAnother powerful feature of proxy objects is the ability to implement additional interfaces that is not implemented by the target type.\n\n\nThe \nIntercept\n method has an overload that lets us specify a set of interfaces to be implemented by the proxy type.\n\n\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), new []{ typeof(IBar) }, (sf, pd) =\n  DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =\n new BarInterceptor(), m =\n m.IsDeclaredBy\nIBar\n());        \n}\n\n\n\nWhen implementing additional interfaces we must make sure that all methods are intercepted by either one or a combined set of interceptors. This is because we are now dealing with methods that does not exist in the target type and we must do all implementation through interceptors.  \n\n\nIProxy\n\n\n/// \nsummary\n\n/// Implemented by all proxy types.\n/// \n/summary\n\npublic interface IProxy\n{\n    /// \nsummary\n\n    /// Gets the proxy target.\n    /// \n/summary\n\n    object Target { get; }\n}\n\n\n\nWe can get to the underlying target instance through the \nIProxy\n interface\n\n\ncontainer.Register\nIFoo, Foo\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(IFoo), sf =\n new SampleInterceptor());\n\nvar instance = container.GetInstance\nIFoo\n();\nvar actualTarget = ((IProxy)instance).Target;\n\n\n\nThis\n\n\nOne of the things to be aware of when working with proxy based interception is that it all relies on method calls being made through the proxy.\nMethod calls that are made directly to the target instance will NOT be intercepted. \n\n\npublic interface IFoo\n{\n    void A();\n}\n\npublic class Foo : IFoo\n{\n    public void A() {}\n\n    private void B()\n    {\n        //Calls the target (this) directly and interceptors are not invoked.\n        this.A();\n    }\n}\n\n\n\nAnother scenario is when the proxy instance itself is leaking its target.\n\n\npublic interface IFoo\n{\n    IFoo A();\n}\n\npublic class Foo\n{\n    public IFoo A()\n    {\n        return this;\n    }\n}\n\n\n\nLightInject\n will take care of this scenario and detect that we are about to return \nthis\n from a method and replace the return value with the proxy instance instead. \n\n\nOther scenarios such as event handlers or passing \"this\" to another method is NOT taken care of by \nLightInject\n as it is not possible without modifying the code in the target type itself. \n\n\nClass Proxies\n\n\nStarting from version 1.0.0.4, \nLightInject.Interception\n can be used to intercept classes with virtual members.\n\n\npublic class Foo\n{\n    public virtual void A()\n    {\n    }\n}\n\n\n\nAny member that is marked as virtual can be intercepted.    \n\n\nvar container = new ServiceContainer();\ncontainer.Register\nFoo\n();\ncontainer.Intercept(sr =\n sr.ServiceType == typeof(Foo), factory =\n new SampleInterceptor());\n\n\n\nClass proxies are implemented internally by subclassing the target type and overriding virtual members to support interception.", 
            "title": "Interception"
        }, 
        {
            "location": "/interception/#interception", 
            "text": "LightInject  supports  Aspect Oriented Programming  through proxy-based method interceptors.", 
            "title": "Interception"
        }, 
        {
            "location": "/interception/#installing", 
            "text": "LightInject.Interception  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject.Interception  \n      This adds a reference to the LightInject.Interception.dll in the target project.  Source  \n    \n          PM  Install-Package LightInject.Interception.Source  \n      This will install a single file (LightInject.Interception.cs) into the current project.", 
            "title": "Installing"
        }, 
        {
            "location": "/interception/#interceptors", 
            "text": "An interceptor sits between the call site and the target instance and intercepts method calls.  public class SampleInterceptor : IInterceptor\n{\n    public object Invoke(IInvocationInfo invocationInfo)\n    {\n        // Perform logic before invoking the target method\n        var returnValue = invocationInfo.Proceed();\n        // Perform logic after invoking the target method\n        return returnValue;           \n    }        \n}  The  IInvocationInfo  instance passed into the  Invoke  method contains information about the method being intercepted.  The  Proceed  method calls down the chain of interceptors and ultimately the actual target instance.", 
            "title": "Interceptors"
        }, 
        {
            "location": "/interception/#single-interceptor", 
            "text": "This example shows how to configure the service container with a single interceptor to handle all method calls.  container.Register IFoo, Foo ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(IFoo), sf =  new SampleInterceptor());\n\nvar instance = container.GetInstance IFoo ();  The instance returned is a proxy object that forwards method calls to the  SampleInterceptor  class.  The first parameter of the  Intercept  method is a selector function used to select the services that should have this interceptor applied.        \nThe second parameter is a function delegate that used to create an  IInterceptor  instance.   Note:   Proxy types are lazy in the sense that they will not create the target instance or any interceptors until the first method call is made.", 
            "title": "Single Interceptor"
        }, 
        {
            "location": "/interception/#dependencies", 
            "text": "Interceptors might also have dependencies and by resolving the interceptor through the container, those dependencies can be injected into the interceptor itself.   public class SampleInterceptor : IInterceptor\n{\n    private IBar bar;\n\n    public SampleInterceptor(IBar bar) \n    {\n        this.bar = bar;    \n    }\n\n    public object Invoke(IInvocationInfo invocationInfo)\n\n        // Perform logic using the injected dependency before invoking the target method             \n        return invovationInfo.Proceed();                      \n        // Perform logic using the injected dependency after invoking the target method\n    }        \n}  The following example shows how to configure the container so that the  SampleInterceptor  instance is resolved through the container.  container.Register IFoo, Foo ()\ncontainer.Register IBar, Bar ();\ncontainer.Register IInterceptor, SampleInterceptor ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(IFoo), sf =  sf.GetInstance IInterceptor ());  Note:   When injecting depndencies into an interceptor we must make sure that the injected dependency is NOT intercepted by the same interceptor as this would cause a  StackOverFlowException .", 
            "title": "Dependencies"
        }, 
        {
            "location": "/interception/#multiple-interceptors", 
            "text": "Interceptors can be set up to handle a lot of cross cutting concerns such as logging, caching, null check and so on.\nAccording to the  Single Responsibility Principle , we can separate the combined logic into a set of interceptor that each only does \"one\" thing.  We can do this by using another overload of the  Intercept  method that allows us to set up a  ProxyDefinition  instance that gives us more control over the proxy type that is being created.  container.Intercept(sr =  sr.ServiceType == typeof(IFoo), (sf,pd) =   DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(new FirstInterceptor());\n    proxyDefinition.Implement(new SecondInterceptor());\n}  Note:   The interceptors are invoked in the same order as they are registered with the  Implement  method.", 
            "title": "Multiple Interceptors"
        }, 
        {
            "location": "/interception/#method-selectors", 
            "text": "Method selectors are used to select the methods that should be intercepted by an interceptor.  The following example shows how to set up the container so that only calls method  A  is passed to the interceptor.  container.Intercept(sr =  sr.ServiceType == typeof(IFoo), (sf, pd) =   DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =  new SampleInterceptor(), m =  m.Name == \"SomeMethodName\");       \n}  Methods that does not match the method selector predicate will NOT be intercepted and method calls will be passed directly down to the target instance.    If we omit the method selector,  LightInject  will intercept all methods from the target type and any additional interface, except methods that are inherited from  System.Object .       Equals(Object)  GetHashCode  GetType  ToString   If we choose to use a method selector, these methods will also be intercepted if they match the predicate in the method selector.  proxyDefinition.Implement(() =  new SampleInterceptor(), m =  m.IsDeclaredBy object ());  We can also use a method selector with the  Intercept  method that allows easy interception of any method without implementing an  IInterceptor .  container.Intercept(m =  m.Name == \"SomeMethodName\", invocationInfo =  invocationInfo.Proceed());  Extension Methods  LightInject provides a set of extension method that simplifies method selector predicates.   IsPropertySetter - Returns  true  if the method represents a property setter, otherwise  false .   IsPropertyGetter - Returns  true  if the method represents a property getter, otherwise  false .  GetProperty - Returns the property for which the target method either represents the property getter or the property setter.", 
            "title": "Method Selectors"
        }, 
        {
            "location": "/interception/#chaining-interceptors", 
            "text": "As already seen in the example with multiple interceptors,  we can chain interceptors together. We can also combine this with method selectors that will affect the call sequence from the call site down to the actual target instance.  Consider an interface with three methods.  public interface IFoo \n{\n    void A();\n    void B();\n    void C();\n}  The following example shows how we can control the call sequence for each method.  container.Intercept(sr =  sr.ServiceType == typeof(IFoo), (sf, pd) =   DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =  new FirstInterceptor(), m =  m.Name == \"A\");\n    proxyDefinition.Implement(() =  new SecondInterceptor(), m =  m.Name == \"B\");   \n    proxyDefinition.Implement(() =  new ThirdInterceptor(), m =  m.Name == \"A\" || m.Name == \"B\" || m.Name == \"C\");\n}  Method A call sequence  FirstInterceptor -  ThirdInterceptor -  Target   Method B call sequence  SecondInterceptor -  ThirdInterceptor -  Target  Method C call sequence  ThirdInterceptor -  Target", 
            "title": "Chaining Interceptors"
        }, 
        {
            "location": "/interception/#implementing-additional-interfaces", 
            "text": "Another powerful feature of proxy objects is the ability to implement additional interfaces that is not implemented by the target type.  The  Intercept  method has an overload that lets us specify a set of interfaces to be implemented by the proxy type.  container.Intercept(sr =  sr.ServiceType == typeof(IFoo), new []{ typeof(IBar) }, (sf, pd) =   DefineProxyType(pd));\n\nprivate void DefineProxyType(ProxyDefinition proxyDefinition)\n{\n    proxyDefinition.Implement(() =  new BarInterceptor(), m =  m.IsDeclaredBy IBar ());        \n}  When implementing additional interfaces we must make sure that all methods are intercepted by either one or a combined set of interceptors. This is because we are now dealing with methods that does not exist in the target type and we must do all implementation through interceptors.", 
            "title": "Implementing additional interfaces"
        }, 
        {
            "location": "/interception/#iproxy", 
            "text": "///  summary \n/// Implemented by all proxy types.\n///  /summary \npublic interface IProxy\n{\n    ///  summary \n    /// Gets the proxy target.\n    ///  /summary \n    object Target { get; }\n}  We can get to the underlying target instance through the  IProxy  interface  container.Register IFoo, Foo ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(IFoo), sf =  new SampleInterceptor());\n\nvar instance = container.GetInstance IFoo ();\nvar actualTarget = ((IProxy)instance).Target;", 
            "title": "IProxy"
        }, 
        {
            "location": "/interception/#this", 
            "text": "One of the things to be aware of when working with proxy based interception is that it all relies on method calls being made through the proxy.\nMethod calls that are made directly to the target instance will NOT be intercepted.   public interface IFoo\n{\n    void A();\n}\n\npublic class Foo : IFoo\n{\n    public void A() {}\n\n    private void B()\n    {\n        //Calls the target (this) directly and interceptors are not invoked.\n        this.A();\n    }\n}  Another scenario is when the proxy instance itself is leaking its target.  public interface IFoo\n{\n    IFoo A();\n}\n\npublic class Foo\n{\n    public IFoo A()\n    {\n        return this;\n    }\n}  LightInject  will take care of this scenario and detect that we are about to return  this  from a method and replace the return value with the proxy instance instead.   Other scenarios such as event handlers or passing \"this\" to another method is NOT taken care of by  LightInject  as it is not possible without modifying the code in the target type itself.", 
            "title": "This"
        }, 
        {
            "location": "/interception/#class-proxies", 
            "text": "Starting from version 1.0.0.4,  LightInject.Interception  can be used to intercept classes with virtual members.  public class Foo\n{\n    public virtual void A()\n    {\n    }\n}  Any member that is marked as virtual can be intercepted.      var container = new ServiceContainer();\ncontainer.Register Foo ();\ncontainer.Intercept(sr =  sr.ServiceType == typeof(Foo), factory =  new SampleInterceptor());  Class proxies are implemented internally by subclassing the target type and overriding virtual members to support interception.", 
            "title": "Class Proxies"
        }, 
        {
            "location": "/autofactory/", 
            "text": "AutoFactory\n\n\n\n\nLightInject.AutoFactory\n enables automatic implementation of factory interfaces.\n\n\nInstalling\n\n\nLightInject.AutoFactory\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.AutoFactory \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.AutoFactory.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.AutoFactory.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.AutoFactory.cs\n in the target project.\n\n\nFactory\n\n\nThe following interface represents a factory class used to resolve \nIFoo\n instances. \n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}\n\n\n\nInstead of having to manually implement the \nIFooFactory\n interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented.\n\n\ncontainer.Register\nIFoo, Foo\n();    \ncontainer.RegisterAutoFactory\nIFooFactory\n(); \nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo();\n\n\n\nParameters\n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo \n{\n    public Foo(int value) {}        \n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}\n\n\n\nRuntime arguments can now be passed to the factory method.\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));  \ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo(42);\n\n\n\nNamed Services\n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic class AnotherFoo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n    IFoo GetAnotherFoo();\n}\n\n\n\nThe name of the factory method is used to identify named services.\n\n\ncontainer.Register\nIFoo, Foo\n();    \ncontainer.Register\nIFoo, Foo\n(\"AnotherFoo\");    \ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo();\nvar anotherFoo = factory.GetAnotherFoo();\n\n\n\nOpen Generics\n\n\npublic interface IFoo\nT\n {}\n\npublic class Foo\nT\n : IFoo\nT\n {}\n\npublic interface IFooFactory\n{\n    IFoo\nT\n GetFoo\nT\n();    \n}\n\n\n\nThe generic type arguments from the factory method are used to create the service instance.\n\n\ncontainer.Register(typeof(IFoo\n), typeof(Foo\n));\ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo\nint\n();", 
            "title": "AutoFactory"
        }, 
        {
            "location": "/autofactory/#autofactory", 
            "text": "LightInject.AutoFactory  enables automatic implementation of factory interfaces.", 
            "title": "AutoFactory"
        }, 
        {
            "location": "/autofactory/#installing", 
            "text": "LightInject.AutoFactory  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject.AutoFactory  \n      This adds a reference to the  LightInject.AutoFactory.dll  in the target project.  Source  \n    \n          PM  Install-Package LightInject.AutoFactory.Source  \n      This will install a single file,  LightInject.AutoFactory.cs  in the target project.", 
            "title": "Installing"
        }, 
        {
            "location": "/autofactory/#factory", 
            "text": "The following interface represents a factory class used to resolve  IFoo  instances.   public interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}  Instead of having to manually implement the  IFooFactory  interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented.  container.Register IFoo, Foo ();    \ncontainer.RegisterAutoFactory IFooFactory (); \nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo();", 
            "title": "Factory"
        }, 
        {
            "location": "/autofactory/#parameters", 
            "text": "public interface IFoo {}\n\npublic class Foo : IFoo \n{\n    public Foo(int value) {}        \n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}  Runtime arguments can now be passed to the factory method.  container.Register int, IFoo ((factory, value) =  new Foo(value));  \ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo(42);", 
            "title": "Parameters"
        }, 
        {
            "location": "/autofactory/#named-services", 
            "text": "public interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic class AnotherFoo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n    IFoo GetAnotherFoo();\n}  The name of the factory method is used to identify named services.  container.Register IFoo, Foo ();    \ncontainer.Register IFoo, Foo (\"AnotherFoo\");    \ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo();\nvar anotherFoo = factory.GetAnotherFoo();", 
            "title": "Named Services"
        }, 
        {
            "location": "/autofactory/#open-generics", 
            "text": "public interface IFoo T  {}\n\npublic class Foo T  : IFoo T  {}\n\npublic interface IFooFactory\n{\n    IFoo T  GetFoo T ();    \n}  The generic type arguments from the factory method are used to create the service instance.  container.Register(typeof(IFoo ), typeof(Foo ));\ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo int ();", 
            "title": "Open Generics"
        }, 
        {
            "location": "/annotation/", 
            "text": "Annotation\n\n\nLightInject\n supports annotation of properties and constructor parameters through an extension LightInject. \n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Annotation \n\n   \n\n\n\n\n\nBy using the \nInjectAttribute\n we can be more explicit about the services that gets injected into properties and constructor dependencies.\n\n\nNote:\n \nAs opposed to all other types within \nLightInject\n, the \nInjectAttribute\n is marked with the public access modifier so that is can be used outside the assembly that contains the service container. This creates a dependency from our services to the assembly containing the attribute, but we still don't need to reference any of the specific types in \nLightInject\n making this an affordable sacrifice when it comes to services referencing container specific types.\n  \n\n\nProperty Injection\n\n\nTo enable annotated property injection, we must execute the following line before we start requesting services from the container.\n\n\ncontainer.EnableAnnotatedPropertyInjection();\n\n\n\nThe container now only try to inject dependencies for properties that is annotated with the \nInjectAttribute\n.\nThe container will throw an \nInvalidOperationException\n if the annotated property dependency is unable to be resolved.\n\n\npublic class FooWithAnnotatedProperyDependency : IFoo\n{\n    [Inject]\n    public IBar Bar { get; set; }\n}\n\n\n\nGiven that we have a registration for the \nIBar\n dependency, it will be injected into the \nBar\n property.\n\n\ncontainer.Register\nIFoo, FooWithAnnotatedProperyDependency\n();\ncontainer.Register\nIBar, Bar\n();\nvar instance = (FooWithAnnotatedProperyDependency)container.GetInstance\nIFoo\n();\nAssert.IsNotNull(instance.Bar);\n\n\n\nIf we have multiple registrations of the same interface, we can also use the \nInjectAttribute\n to specify the service to be injected. \n\n\npublic class FooWithNamedAnnotatedProperyDependency : IFoo\n{\n    [Inject(\"AnotherBar\")]\n    public IBar Bar { get; set; }\n}\n\n\n\nThe container will inject the service that matches the specified service name.\n\n\ncontainer.Register\nIFoo, FooWithNamedAnnotatedProperyDependency\n();\ncontainer.Register\nIBar, Bar\n(\"SomeBar\");\ncontainer.Register\nIBar, AnotherBar\n(\"AnotherBar\"); \nvar instance = (FooWithNamedAnnotatedProperyDependency)container.GetInstance\nIFoo\n();   \nAssert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));\n\n\n\nConstructor Injection\n\n\nTo enable annotated constructor injection, we must execute the following line before we start requesting services from the container.\n\n\ncontainer.EnableAnnotatedConstructorInjection();\n\n\n\nLightInject\n does consider all constructor parameters to be required dependencies and will try to satisfy all dependencies regardless of being annotated with the \nInjectAttribute\n. We can however use the \nInjectAttribute \n to specify the named service to be injected.\n\n\npublic class FooWithNamedAnnotatedDependency : IFoo\n{\n    public FooWithNamedAnnotatedDependency([Inject(ServiceName=\"AnotherBar\")]IBar bar)\n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; }\n}\n\n\n\nThe container will inject the service that matches the specified service name.\n\n\ncontainer.Register\nIFoo, FooWithNamedAnnotatedDependency\n();\ncontainer.Register\nIBar, Bar\n(\"SomeBar\");\ncontainer.Register\nIBar, AnotherBar\n(\"AnotherBar\"); \nvar instance = (FooWithNamedAnnotatedDependency)container.GetInstance\nIFoo\n();  \nAssert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));", 
            "title": "Annotation"
        }, 
        {
            "location": "/annotation/#annotation", 
            "text": "LightInject  supports annotation of properties and constructor parameters through an extension LightInject.   \n    \n          PM  Install-Package LightInject.Annotation  \n      By using the  InjectAttribute  we can be more explicit about the services that gets injected into properties and constructor dependencies.  Note:   As opposed to all other types within  LightInject , the  InjectAttribute  is marked with the public access modifier so that is can be used outside the assembly that contains the service container. This creates a dependency from our services to the assembly containing the attribute, but we still don't need to reference any of the specific types in  LightInject  making this an affordable sacrifice when it comes to services referencing container specific types.     Property Injection  To enable annotated property injection, we must execute the following line before we start requesting services from the container.  container.EnableAnnotatedPropertyInjection();  The container now only try to inject dependencies for properties that is annotated with the  InjectAttribute .\nThe container will throw an  InvalidOperationException  if the annotated property dependency is unable to be resolved.  public class FooWithAnnotatedProperyDependency : IFoo\n{\n    [Inject]\n    public IBar Bar { get; set; }\n}  Given that we have a registration for the  IBar  dependency, it will be injected into the  Bar  property.  container.Register IFoo, FooWithAnnotatedProperyDependency ();\ncontainer.Register IBar, Bar ();\nvar instance = (FooWithAnnotatedProperyDependency)container.GetInstance IFoo ();\nAssert.IsNotNull(instance.Bar);  If we have multiple registrations of the same interface, we can also use the  InjectAttribute  to specify the service to be injected.   public class FooWithNamedAnnotatedProperyDependency : IFoo\n{\n    [Inject(\"AnotherBar\")]\n    public IBar Bar { get; set; }\n}  The container will inject the service that matches the specified service name.  container.Register IFoo, FooWithNamedAnnotatedProperyDependency ();\ncontainer.Register IBar, Bar (\"SomeBar\");\ncontainer.Register IBar, AnotherBar (\"AnotherBar\"); \nvar instance = (FooWithNamedAnnotatedProperyDependency)container.GetInstance IFoo ();   \nAssert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));  Constructor Injection  To enable annotated constructor injection, we must execute the following line before we start requesting services from the container.  container.EnableAnnotatedConstructorInjection();  LightInject  does consider all constructor parameters to be required dependencies and will try to satisfy all dependencies regardless of being annotated with the  InjectAttribute . We can however use the  InjectAttribute   to specify the named service to be injected.  public class FooWithNamedAnnotatedDependency : IFoo\n{\n    public FooWithNamedAnnotatedDependency([Inject(ServiceName=\"AnotherBar\")]IBar bar)\n    {\n        Bar = bar;\n    }\n\n    public IBar Bar { get; private set; }\n}  The container will inject the service that matches the specified service name.  container.Register IFoo, FooWithNamedAnnotatedDependency ();\ncontainer.Register IBar, Bar (\"SomeBar\");\ncontainer.Register IBar, AnotherBar (\"AnotherBar\"); \nvar instance = (FooWithNamedAnnotatedDependency)container.GetInstance IFoo ();  \nAssert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));", 
            "title": "Annotation"
        }, 
        {
            "location": "/xunit/", 
            "text": "LightInject.xUnit\n\n\nLightInject.xUnit\n provides an integration that enables dependency injection in \nxUnit\n test methods.\n\n\nInstalling\n\n\nLightInject.xUnit\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.xUnit \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.Xunit.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.xUnit.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.Xunit.cs\n in the target project.\n\n\nInjecting services\n\n\nServices from \nLightInject\n are injected into methods that are decorated with the \nInjectData\n attribute. \n\n\n[Theory, InjectData]                \npublic void TestMethod(IFoo foo)\n{\n    Assert.NotNull(foo);\n}\n\n\n\nConfiguration\n\n\nLightInject\n will look for an \nICompositionRoot\n implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root.   \n\n\nIf such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature.\n\n\npublic static void Configure(IServiceContainer container)\n{\n    container.Register\nIFoo, Foo\n();            \n}\n\n\n\nThis method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.  \n\n\nScoping (xUnit \n= 1.9.2)\n\n\nServices registered with the \nPerScopeLifetime\n or \nPerRequestLifetime\n needs to be resolved within an active \nScope\n to ensure that any services that implements \nIDisposable\n are properly disposed.  \n\n\nBy decorating the test method with the \nScopedTheory\n attribute, a new \nScope\n will be started when the test method starts and it will end when the test method ends.   \n\n\n[ScopedTheory, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}\n\n\n\nScoping (xUnit \n= 2.0.0)\n\n\nServices registered with the \nPerScopeLifetime\n or \nPerRequestLifetime\n needs to be resolved within an active \nScope\n to ensure that any services that implements \nIDisposable\n are properly disposed.  \n\n\nBy decorating the test method with the \nScoped\n attribute, a new \nScope\n will be started when the test method starts and it will end when the test method ends.   \n\n\n[Theory, Scoped, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "xUnit"
        }, 
        {
            "location": "/xunit/#lightinjectxunit", 
            "text": "LightInject.xUnit  provides an integration that enables dependency injection in  xUnit  test methods.", 
            "title": "LightInject.xUnit"
        }, 
        {
            "location": "/xunit/#installing", 
            "text": "LightInject.xUnit  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject.xUnit  \n      This adds a reference to the  LightInject.Xunit.dll  in the target project.  Source  \n    \n          PM  Install-Package LightInject.xUnit.Source  \n      This will install a single file,  LightInject.Xunit.cs  in the target project.", 
            "title": "Installing"
        }, 
        {
            "location": "/xunit/#injecting-services", 
            "text": "Services from  LightInject  are injected into methods that are decorated with the  InjectData  attribute.   [Theory, InjectData]                \npublic void TestMethod(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Injecting services"
        }, 
        {
            "location": "/xunit/#configuration", 
            "text": "LightInject  will look for an  ICompositionRoot  implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root.     If such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature.  public static void Configure(IServiceContainer container)\n{\n    container.Register IFoo, Foo ();            \n}  This method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.", 
            "title": "Configuration"
        }, 
        {
            "location": "/xunit/#scoping-xunit-192", 
            "text": "Services registered with the  PerScopeLifetime  or  PerRequestLifetime  needs to be resolved within an active  Scope  to ensure that any services that implements  IDisposable  are properly disposed.    By decorating the test method with the  ScopedTheory  attribute, a new  Scope  will be started when the test method starts and it will end when the test method ends.     [ScopedTheory, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Scoping (xUnit &lt;= 1.9.2)"
        }, 
        {
            "location": "/xunit/#scoping-xunit-200", 
            "text": "Services registered with the  PerScopeLifetime  or  PerRequestLifetime  needs to be resolved within an active  Scope  to ensure that any services that implements  IDisposable  are properly disposed.    By decorating the test method with the  Scoped  attribute, a new  Scope  will be started when the test method starts and it will end when the test method ends.     [Theory, Scoped, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Scoping (xUnit &gt;= 2.0.0)"
        }, 
        {
            "location": "/web/", 
            "text": "Web\n\n\nEnables \nLightInject\n to be used in a web application and provides support for \nPerWebRequest\n scoped service instances.\n\n\nInstalling\n\n\nLightInject.Web\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Web \n\n   \n\n\n\n\n\nThis adds a reference to the LightInject.Web.dll in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.Web.Source \n\n   \n\n\n\n\n\nThis will install a single file (LightInject.Web.cs) into the current project.\n\n\nThe following example shows how to enable \nLightInject\n in the \nApplication_Start\n event.\n\n\nprotected void Application_Start()\n{\n    var container = new ServiceContainer();\n    container.EnablePerWebRequestScope();                   \n    container.Register\nIFoo, Foo\n(new PerScopeLifetime());      \n}\n\n\n\nA service    registered with \nPerScopeLifetime\n is scoped per web request and is disposed at the end of the request if it implements \nIDisposable\n.", 
            "title": "Web"
        }, 
        {
            "location": "/web/#web", 
            "text": "Enables  LightInject  to be used in a web application and provides support for  PerWebRequest  scoped service instances.", 
            "title": "Web"
        }, 
        {
            "location": "/web/#installing", 
            "text": "LightInject.Web  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject.Web  \n      This adds a reference to the LightInject.Web.dll in the target project.  Source  \n    \n          PM  Install-Package LightInject.Web.Source  \n      This will install a single file (LightInject.Web.cs) into the current project.  The following example shows how to enable  LightInject  in the  Application_Start  event.  protected void Application_Start()\n{\n    var container = new ServiceContainer();\n    container.EnablePerWebRequestScope();                   \n    container.Register IFoo, Foo (new PerScopeLifetime());      \n}  A service    registered with  PerScopeLifetime  is scoped per web request and is disposed at the end of the request if it implements  IDisposable .", 
            "title": "Installing"
        }
    ]
}