{
    "docs": [
        {
            "location": "/", 
            "text": "LightInject\n\n\nLightInject\n is an ultra lightweight IoC container that supports the most common features expected from a service container.\n\n\nSee \nhttp://www.lightinject.net\n for more information.", 
            "title": "Home"
        }, 
        {
            "location": "/#lightinject", 
            "text": "LightInject  is an ultra lightweight IoC container that supports the most common features expected from a service container.  See  http://www.lightinject.net  for more information.", 
            "title": "LightInject"
        }, 
        {
            "location": "/xunit/", 
            "text": "LightInject.xUnit\n\n\nLightInject.xUnit\n provides an integration that enables dependency injection in \nxUnit\n test methods.\n\n\nInstalling\n\n\nLightInject.xUnit\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.xUnit \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.Xunit.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.xUnit.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.Xunit.cs\n in the target project.\n\n\nInjecting services\n\n\nServices from \nLightInject\n are injected into methods that are decorated with the \nInjectData\n attribute. \n\n\n[Theory, InjectData]                \npublic void TestMethod(IFoo foo)\n{\n    Assert.NotNull(foo);\n}\n\n\n\nConfiguration\n\n\nLightInject\n will look for an \nICompositionRoot\n implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root.   \n\n\nIf such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature.\n\n\npublic static void Configure(IServiceContainer container)\n{\n    container.Register\nIFoo, Foo\n();            \n}\n\n\n\nThis method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.  \n\n\nScoping (xUnit \n= 1.9.2)\n\n\nServices registered with the \nPerScopeLifetime\n or \nPerRequestLifetime\n needs to be resolved within an active \nScope\n to ensure that any services that implements \nIDisposable\n are properly disposed.  \n\n\nBy decorating the test method with the \nScopedTheory\n attribute, a new \nScope\n will be started when the test method starts and it will end when the test method ends.   \n\n\n[ScopedTheory, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}\n\n\n\nScoping (xUnit \n= 2.0.0)\n\n\nServices registered with the \nPerScopeLifetime\n or \nPerRequestLifetime\n needs to be resolved within an active \nScope\n to ensure that any services that implements \nIDisposable\n are properly disposed.  \n\n\nBy decorating the test method with the \nScoped\n attribute, a new \nScope\n will be started when the test method starts and it will end when the test method ends.   \n\n\n[Theory, Scoped, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "xUnit"
        }, 
        {
            "location": "/xunit/#lightinjectxunit", 
            "text": "LightInject.xUnit  provides an integration that enables dependency injection in  xUnit  test methods.", 
            "title": "LightInject.xUnit"
        }, 
        {
            "location": "/xunit/#installing", 
            "text": "LightInject.xUnit  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject.xUnit  \n      This adds a reference to the  LightInject.Xunit.dll  in the target project.  Source  \n    \n          PM  Install-Package LightInject.xUnit.Source  \n      This will install a single file,  LightInject.Xunit.cs  in the target project.", 
            "title": "Installing"
        }, 
        {
            "location": "/xunit/#injecting-services", 
            "text": "Services from  LightInject  are injected into methods that are decorated with the  InjectData  attribute.   [Theory, InjectData]                \npublic void TestMethod(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Injecting services"
        }, 
        {
            "location": "/xunit/#configuration", 
            "text": "LightInject  will look for an  ICompositionRoot  implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root.     If such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature.  public static void Configure(IServiceContainer container)\n{\n    container.Register IFoo, Foo ();            \n}  This method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.", 
            "title": "Configuration"
        }, 
        {
            "location": "/xunit/#scoping-xunit-192", 
            "text": "Services registered with the  PerScopeLifetime  or  PerRequestLifetime  needs to be resolved within an active  Scope  to ensure that any services that implements  IDisposable  are properly disposed.    By decorating the test method with the  ScopedTheory  attribute, a new  Scope  will be started when the test method starts and it will end when the test method ends.     [ScopedTheory, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Scoping (xUnit &lt;= 1.9.2)"
        }, 
        {
            "location": "/xunit/#scoping-xunit-200", 
            "text": "Services registered with the  PerScopeLifetime  or  PerRequestLifetime  needs to be resolved within an active  Scope  to ensure that any services that implements  IDisposable  are properly disposed.    By decorating the test method with the  Scoped  attribute, a new  Scope  will be started when the test method starts and it will end when the test method ends.     [Theory, Scoped, InjectData]\npublic void MethodWithScopedArgument(IFoo foo)\n{\n    Assert.NotNull(foo);\n}", 
            "title": "Scoping (xUnit &gt;= 2.0.0)"
        }, 
        {
            "location": "/autofactory/", 
            "text": "AutoFactory\n\n\n\n\nLightInject.AutoFactory\n enables automatic implementation of factory interfaces.\n\n\nInstalling\n\n\nLightInject.AutoFactory\n provides two distribution models via NuGet\n\n\nBinary\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.AutoFactory \n\n   \n\n\n\n\n\nThis adds a reference to the \nLightInject.AutoFactory.dll\n in the target project.\n\n\nSource\n\n\n\n   \n\n         \nPM\n Install-Package LightInject.AutoFactory.Source \n\n   \n\n\n\n\n\nThis will install a single file, \nLightInject.AutoFactory.cs\n in the target project.\n\n\nFactory\n\n\nThe following interface represents a factory class used to resolve \nIFoo\n instances. \n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}\n\n\n\nInstead of having to manually implement the \nIFooFactory\n interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented.\n\n\ncontainer.Register\nIFoo, Foo\n();    \ncontainer.RegisterAutoFactory\nIFooFactory\n(); \nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo();\n\n\n\nParameters\n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo \n{\n    public Foo(int value) {}        \n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}\n\n\n\nRuntime arguments can now be passed to the factory method.\n\n\ncontainer.Register\nint, IFoo\n((factory, value) =\n new Foo(value));  \ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo(42);\n\n\n\nNamed Services\n\n\npublic interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic class AnotherFoo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n    IFoo GetAnotherFoo();\n}\n\n\n\nThe name of the factory method is used to identify named services.\n\n\ncontainer.Register\nIFoo, Foo\n();    \ncontainer.Register\nIFoo, Foo\n(\"AnotherFoo\");    \ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo();\nvar anotherFoo = factory.GetAnotherFoo();\n\n\n\nOpen Generics\n\n\npublic interface IFoo\nT\n {}\n\npublic class Foo\nT\n : IFoo\nT\n {}\n\npublic interface IFooFactory\n{\n    IFoo\nT\n GetFoo\nT\n();    \n}\n\n\n\nThe generic type arguments from the factory method are used to create the service instance.\n\n\ncontainer.Register(typeof(IFoo\n), typeof(Foo\n));\ncontainer.RegisterAutoFactory\nIFooFactory\n();\nvar factory = container.GetInstance\nIFooFactory\n();\nvar foo = factory.GetFoo\nint\n();", 
            "title": "AutoFactory"
        }, 
        {
            "location": "/autofactory/#autofactory", 
            "text": "LightInject.AutoFactory  enables automatic implementation of factory interfaces.", 
            "title": "AutoFactory"
        }, 
        {
            "location": "/autofactory/#installing", 
            "text": "LightInject.AutoFactory  provides two distribution models via NuGet  Binary  \n    \n          PM  Install-Package LightInject.AutoFactory  \n      This adds a reference to the  LightInject.AutoFactory.dll  in the target project.  Source  \n    \n          PM  Install-Package LightInject.AutoFactory.Source  \n      This will install a single file,  LightInject.AutoFactory.cs  in the target project.", 
            "title": "Installing"
        }, 
        {
            "location": "/autofactory/#factory", 
            "text": "The following interface represents a factory class used to resolve  IFoo  instances.   public interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n}  Instead of having to manually implement the  IFooFactory  interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented.  container.Register IFoo, Foo ();    \ncontainer.RegisterAutoFactory IFooFactory (); \nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo();", 
            "title": "Factory"
        }, 
        {
            "location": "/autofactory/#parameters", 
            "text": "public interface IFoo {}\n\npublic class Foo : IFoo \n{\n    public Foo(int value) {}        \n}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo(int value);\n}  Runtime arguments can now be passed to the factory method.  container.Register int, IFoo ((factory, value) =  new Foo(value));  \ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo(42);", 
            "title": "Parameters"
        }, 
        {
            "location": "/autofactory/#named-services", 
            "text": "public interface IFoo {}\n\npublic class Foo : IFoo {}\n\npublic class AnotherFoo : IFoo {}\n\npublic interface IFooFactory\n{\n    IFoo GetFoo();\n    IFoo GetAnotherFoo();\n}  The name of the factory method is used to identify named services.  container.Register IFoo, Foo ();    \ncontainer.Register IFoo, Foo (\"AnotherFoo\");    \ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo();\nvar anotherFoo = factory.GetAnotherFoo();", 
            "title": "Named Services"
        }, 
        {
            "location": "/autofactory/#open-generics", 
            "text": "public interface IFoo T  {}\n\npublic class Foo T  : IFoo T  {}\n\npublic interface IFooFactory\n{\n    IFoo T  GetFoo T ();    \n}  The generic type arguments from the factory method are used to create the service instance.  container.Register(typeof(IFoo ), typeof(Foo ));\ncontainer.RegisterAutoFactory IFooFactory ();\nvar factory = container.GetInstance IFooFactory ();\nvar foo = factory.GetFoo int ();", 
            "title": "Open Generics"
        }
    ]
}